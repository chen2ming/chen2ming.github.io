{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/toux.jpg","path":"img/toux.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/remarks.md","hash":"c0ee60fd80c828f2cb726537d8dfa984f60dd8f7","modified":1626663742165},{"_id":"source/_posts/this词法.md","hash":"76b9c53cc404ef7f08a8df3a78fde38bf406c50b","modified":1626501143886},{"_id":"source/_posts/js数据类型.md","hash":"26c4aa4ae9c9b666951452fab00bd3703f9d15d8","modified":1626663329199},{"_id":"source/CNAME","hash":"8e9eb789ad6415da2dc8f4a8dbc3234ef11c1970","modified":1626660182289},{"_id":"source/_posts/作用域是什么-词法作用域.md","hash":"dd2478777c5d7be806004027e28990ca9beb80aa","modified":1626501134244},{"_id":"source/_posts/函数作用域、作用域快.md","hash":"f207b4c03ff2117cddbaadcd3a863c7bd9aecf82","modified":1626501119116},{"_id":"source/_posts/深拷贝与浅拷贝.md","hash":"c8236c67f547fc6156a2a6b528ddce55d04f6c44","modified":1626675210427},{"_id":"source/_posts/闭包.md","hash":"76e79831fed84182a74602317ccb8a7ecf55b1f8","modified":1626501077777},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1626493683803},{"_id":"themes/yilia/_config.yml","hash":"d10a6ce2975152abcdbf4cc07be752ce70507604","modified":1626505415436},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1626493683786},{"_id":"themes/yilia/package.json","hash":"ee6aa61f1cb89fd549e3e087c0232207a9c9ee30","modified":1626493683806},{"_id":"themes/yilia/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1626493683787},{"_id":"themes/yilia/webpack.config.js","hash":"da7657347109ddb4ab8602b219778117254677fe","modified":1626493683845},{"_id":"themes/yilia/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1626493683787},{"_id":"themes/yilia/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1626493683788},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1626493683789},{"_id":"themes/yilia/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1626493683788},{"_id":"themes/yilia/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1626493683788},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1626493683789},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1626493683804},{"_id":"themes/yilia/layout/index.ejs","hash":"ec498c6c0606acde997ce195dad97b267418d980","modified":1626493683804},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1626493683804},{"_id":"themes/yilia/layout/layout.ejs","hash":"b471ab706d48e0be3f783eab1c94bf5878ef5a94","modified":1626493683805},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1626493683806},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1626493683805},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1626493683806},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1626493683842},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"c70f367f54064a441e574c913f5e0ea121d0f899","modified":1626493683790},{"_id":"themes/yilia/source/slider.e37972.js","hash":"ce5eac88301fe4f2fce0fb6203adfd58eb8313ac","modified":1626493683845},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"edc0154b30a4127acda10297bec6aacf754b4ac4","modified":1626493683791},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1626493683791},{"_id":"themes/yilia/source-src/script.ejs","hash":"28abac2426761d7e715b38aadd86ce6549c8ae77","modified":1626493683836},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"751e5deab5365348be5243688b419c82d337ab9a","modified":1626493683792},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"155327c23607f69989b58845f24d842a54e504b8","modified":1626493683792},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1626493683793},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"871f81cacd5d41cb2eb001cd56254217a857dc2f","modified":1626493683793},{"_id":"themes/yilia/source-src/css.ejs","hash":"cf7eab48d626433120d1ef9697f719a359817018","modified":1626493683807},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1626493683793},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"8dea8f5f93a60185439b330b0f1d1649a6ab4bd0","modified":1626493683791},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"12ca7d8dba56bc767b9309dda9526dcbaffc1614","modified":1626493683794},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1626493683794},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"fb1b8457b9eb15b55da1bf7b133e12c375dd26f8","modified":1626493683794},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"11550a418921d330e6553be0569a94ab5a217967","modified":1626493683795},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"ccec1fc70f021cb50ac85b524e7949878ab93a18","modified":1626493683795},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"0ffcb251b79e8a920c9b4cb6bb7a96a808816165","modified":1626493683803},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1626493683837},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"cc1c39903aed0a0601d104238d2bbd13ad2a36f3","modified":1626493683803},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1626493683838},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1626493683838},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1626493683840},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1626493683839},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1626493683841},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1626493683840},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1626493683841},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1626493683841},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"ce227b6f5a9af194fd5d455200630f32c05e151f","modified":1626493683808},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"d6a7dd88404b383b5b94e4c7ec675a410c41f3cc","modified":1626493683808},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"29ba600e98ed55f7af4ade8038272c84cba21188","modified":1626493683808},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"f7388f5c11370ef462f7cb913d8f72edf24ecaf9","modified":1626493683809},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"1577a2336b3ad122f49f60dff2bc1a97d4e7b18b","modified":1626493683809},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"8f82fe898ba1c1bd00c24a7d8270feddc7eba3bc","modified":1626493683810},{"_id":"themes/yilia/source-src/css/article.scss","hash":"55d082fec4c6bb341725567acaa29ce37d50320a","modified":1626493683810},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"07244c188f58ecfb90bb7c047b8cde977f1dc4b4","modified":1626493683810},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"b85f344f2c66d43d7094746e0a9ccb21d0534201","modified":1626493683811},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"96d7eb1d42c06fdcccb8ef969f6ecd30c3194903","modified":1626493683814},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1626493683818},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1626493683819},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"f53ea8270752b5919ec5d79224d22af91f2eda12","modified":1626493683819},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"40e5aa5056dc0b3b9f51c5b387370b612e265d4e","modified":1626493683820},{"_id":"themes/yilia/source-src/css/left.scss","hash":"80dac621e43581a254d0152d5df901e4d0b01c09","modified":1626493683822},{"_id":"themes/yilia/source-src/css/main.scss","hash":"9eba1fcf4805256697528fcf3b767cf6dd8d0591","modified":1626493683822},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"19f10fd2f0c3377aa4b165b3c2291ecf86dd9351","modified":1626493683823},{"_id":"themes/yilia/source-src/css/page.scss","hash":"244c4d75c375978ff9edb74acc68825e63c6b235","modified":1626493683824},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"d995dcd483a250fe61b426158afb61bf8923a927","modified":1626493683823},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"a557a9ed244c82b8b71e9da9de3339d92783499f","modified":1626493683824},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"2495f7e4e3b055735c531f944b5f40a118a351ec","modified":1626493683825},{"_id":"themes/yilia/source-src/css/share.scss","hash":"9d6f6884f40c191882e56a1e1e1192400944a515","modified":1626493683825},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"399744e98e7c67939ed9b23c2670d8baad044eda","modified":1626493683826},{"_id":"themes/yilia/source-src/css/social.scss","hash":"a10a038a1dac8953cb4ffc7e04272eff9fac54e4","modified":1626493683825},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"915c93edd67c5326695cc7dc84b14c5f154dbcc8","modified":1626493683826},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"2924fb6f77c4a9973cd928c2c7db0acb848ed483","modified":1626493683827},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"b81cedbe31accca82e597801186911a7b5e6841c","modified":1626493683827},{"_id":"themes/yilia/source-src/js/anm.js","hash":"d18f6276a352b871390a4112d479b9e58b8cdbbe","modified":1626493683829},{"_id":"themes/yilia/source-src/js/aside.js","hash":"5e4c3c3d61f1e1ce2f09688d3aff25fadc851fff","modified":1626493683829},{"_id":"themes/yilia/source-src/js/browser.js","hash":"4dc04845cf27f350922b63f1813a9c82e6e33b05","modified":1626493683829},{"_id":"themes/yilia/source-src/js/fix.js","hash":"67b8819abb886c9d066fb3b0624ca15e06f63fe0","modified":1626493683830},{"_id":"themes/yilia/source-src/js/main.js","hash":"fe98bf90ce61658fe16ae057f8b6a512a845af3b","modified":1626493683830},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"461c08ffcbc724d74ec7e0ff38e171eefe0f89fd","modified":1626493683831},{"_id":"themes/yilia/source-src/js/report.js","hash":"57680f9a23bd0a1eaafd64ae08cc33e20627ab15","modified":1626493683831},{"_id":"themes/yilia/source-src/js/Q.js","hash":"e56d9710afa79b31ca6b9fbd845f6d1895f5214b","modified":1626493683828},{"_id":"themes/yilia/source-src/js/slider.js","hash":"0beaa112657ad57c723d9e773d5b79de60c1dd74","modified":1626493683832},{"_id":"themes/yilia/source-src/js/share.js","hash":"d4ccff8266c37363b3904226f5d035b7db882c61","modified":1626493683831},{"_id":"themes/yilia/source-src/js/util.js","hash":"3bcdeb95072b85600874424e6929e3e22cfddaa0","modified":1626493683835},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"086c8a88fd3bcae7ec13258df58e25d6354af2fa","modified":1626493683796},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"c699cf3c89409ec8f044258e0715a470861b5d5d","modified":1626493683835},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"e777cbf959b11c4dfda649c562799899b90ab4a3","modified":1626493683796},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"25655016773aa5d0774c56115ae1736a9fc9ea1f","modified":1626493683797},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1626493683797},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"345b262e3c3b75c0cd9a93d9ecabcf06e33e54ff","modified":1626493683798},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"aae96de18d48cd3b9b7bf6fed0100e15b53cca97","modified":1626493683796},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1626493683799},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2c4e4ca36c9bb4318506c38aca7127f1f44d827f","modified":1626493683799},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"fb022502c741b4a26bad6b2ad37245c10ede3f1a","modified":1626493683801},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"b6a97043f9ec37e571aacacfedcda1d4d75e3c7c","modified":1626493683798},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"262ffcd88775080b7f511db37f58d2bcb1b2bfc7","modified":1626493683812},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"1834c3ed8560716e63bb3a50be94cac87fbbeaf3","modified":1626493683811},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"6e75bdaa46de83094ba0873099c6e7d656a22453","modified":1626493683813},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"91db061c9c17628291a005e5bd4936cf9d35a6c4","modified":1626493683812},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1626493683815},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1626493683815},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1626493683816},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1626493683821},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1626493683820},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"398a49913b4a47d928103562b1ce94520be4026a","modified":1626493683813},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1626493683821},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1626493683818},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"283ae27ea37ac3e0e45b2e05c2482a4c594b9c25","modified":1626493683843},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"1801ef448909ea23c0a48e9d63b80d0cfd5534ce","modified":1626493683844},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"e98ec0b3b56f14d1d79af99ceb42727719a584f3","modified":1626493683802},{"_id":"themes/yilia/source/img/toux.jpg","hash":"22a993db990c69e2e69fdd6c760b41f709a39723","modified":1626497191271},{"_id":"themes/yilia/package-lock.json","hash":"f62402ceba2b5a8daae76f880357eace6946ea8a","modified":1626674152299}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"js数据类型","_content":"\n> 基本数据类型、引用数据类型\n\nECMAScript包括两个不同类型的值：基本数据类型和引用数据类型。\n基本数据类型指的是简单的数据段，引用数据类型指的是有多个值构成的对象。\n当我们把变量赋值给一个变量时，解析器首先要确认的就是这个值是基本类型值还是引用类型值。\n\n### 常见的基本数据类型\n\nNumber、String 、Boolean、Null和Undefined。基本数据类型是按值访问的，因为可以直接操作保存在变量中的实际值。示例：\n　　var a = 10;\n　　var b = a;\n　　b = 20;\n　　console.log(a); // 10值\n　　上面，b获取的是a值得一份拷贝，虽然，两个变量的值相等，但是两个变量保存了两个不同的基本数据类型值。\n　　b只是保存了a复制的一个副本。所以，b的改变，对a没有影响。\n\n\n### 引用类型数据\n  也就是对象类型Object type，比如：Object 、Array 、Function 、Data等。\n　　javascript的引用数据类型是保存在堆内存中的对象。\n　　与其他语言的不同是，你不可以直接访问堆内存空间中的位置和操作堆内存空间。只能操作对象在栈内存中的引用地址。\n　　所以，引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存中堆内存中的对象。\n　　var obj1 = new Object();\n　　var obj2 = obj1;\n　　obj2.name = \"我有名字了\";\n　　console.log(obj1.name); // 我有名字了\n　　说明这两个引用数据类型指向了同一个堆内存对象。obj1赋值给onj2，实际上这个堆内存对象在栈内存的引用地址复制了一份给了obj2，\n　　但是实际上他们共同指向了同一个堆内存对象。实际上改变的是堆内存对象。\n\n> 总结区别\n\n### 声明变量时不同的内存分配：　\n　　1）原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。\n　　　　这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – 栈中。这样存储便于迅速查寻变量的值。\n　　2）引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。\n　　　  这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。\n　　　  地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。\n\n### 不同的内存分配机制也带来了不同的访问机制\n　　　\n　　1）在javascript中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，\n　　　　首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的按引用访问。\n　　2）而原始类型的值则是可以直接访问到的。\n　　\n　　c 复制变量时的不同\n　　\n　　1）原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的value而已。\n　　2）引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，\n　　　　也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。\n　　　　（这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了）。多了一个指针\n　\n### 参数传递的不同（把实参复制给形参的过程）\n\n　　首先我们应该明确一点：ECMAScript中所有函数的参数都是按值来传递的。\n　　但是为什么涉及到原始类型与引用类型的值时仍然有区别呢？还不就是因为内存分配时的差别。 　\n　　1）原始值：只是把变量里的值传递给参数，之后参数和这个变量互不影响。\n　　2）引用值：对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！\n　　　　因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象。\n","source":"_posts/js数据类型.md","raw":"---\ntitle: js数据类型\ntag: javaScript\n---\n\n> 基本数据类型、引用数据类型\n\nECMAScript包括两个不同类型的值：基本数据类型和引用数据类型。\n基本数据类型指的是简单的数据段，引用数据类型指的是有多个值构成的对象。\n当我们把变量赋值给一个变量时，解析器首先要确认的就是这个值是基本类型值还是引用类型值。\n\n### 常见的基本数据类型\n\nNumber、String 、Boolean、Null和Undefined。基本数据类型是按值访问的，因为可以直接操作保存在变量中的实际值。示例：\n　　var a = 10;\n　　var b = a;\n　　b = 20;\n　　console.log(a); // 10值\n　　上面，b获取的是a值得一份拷贝，虽然，两个变量的值相等，但是两个变量保存了两个不同的基本数据类型值。\n　　b只是保存了a复制的一个副本。所以，b的改变，对a没有影响。\n\n\n### 引用类型数据\n  也就是对象类型Object type，比如：Object 、Array 、Function 、Data等。\n　　javascript的引用数据类型是保存在堆内存中的对象。\n　　与其他语言的不同是，你不可以直接访问堆内存空间中的位置和操作堆内存空间。只能操作对象在栈内存中的引用地址。\n　　所以，引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存中堆内存中的对象。\n　　var obj1 = new Object();\n　　var obj2 = obj1;\n　　obj2.name = \"我有名字了\";\n　　console.log(obj1.name); // 我有名字了\n　　说明这两个引用数据类型指向了同一个堆内存对象。obj1赋值给onj2，实际上这个堆内存对象在栈内存的引用地址复制了一份给了obj2，\n　　但是实际上他们共同指向了同一个堆内存对象。实际上改变的是堆内存对象。\n\n> 总结区别\n\n### 声明变量时不同的内存分配：　\n　　1）原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。\n　　　　这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – 栈中。这样存储便于迅速查寻变量的值。\n　　2）引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。\n　　　  这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。\n　　　  地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。\n\n### 不同的内存分配机制也带来了不同的访问机制\n　　　\n　　1）在javascript中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，\n　　　　首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的按引用访问。\n　　2）而原始类型的值则是可以直接访问到的。\n　　\n　　c 复制变量时的不同\n　　\n　　1）原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的value而已。\n　　2）引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，\n　　　　也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。\n　　　　（这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了）。多了一个指针\n　\n### 参数传递的不同（把实参复制给形参的过程）\n\n　　首先我们应该明确一点：ECMAScript中所有函数的参数都是按值来传递的。\n　　但是为什么涉及到原始类型与引用类型的值时仍然有区别呢？还不就是因为内存分配时的差别。 　\n　　1）原始值：只是把变量里的值传递给参数，之后参数和这个变量互不影响。\n　　2）引用值：对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！\n　　　　因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象。\n","slug":"js数据类型","published":1,"date":"2021-07-19T02:06:09.362Z","updated":"2021-07-19T02:55:29.199Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckra8m0qh00001vanf7p48o7m","content":"<blockquote>\n<p>基本数据类型、引用数据类型</p>\n</blockquote>\n<p>ECMAScript包括两个不同类型的值：基本数据类型和引用数据类型。<br>基本数据类型指的是简单的数据段，引用数据类型指的是有多个值构成的对象。<br>当我们把变量赋值给一个变量时，解析器首先要确认的就是这个值是基本类型值还是引用类型值。</p>\n<h3 id=\"常见的基本数据类型\"><a href=\"#常见的基本数据类型\" class=\"headerlink\" title=\"常见的基本数据类型\"></a>常见的基本数据类型</h3><p>Number、String 、Boolean、Null和Undefined。基本数据类型是按值访问的，因为可以直接操作保存在变量中的实际值。示例：<br>　　var a = 10;<br>　　var b = a;<br>　　b = 20;<br>　　console.log(a); // 10值<br>　　上面，b获取的是a值得一份拷贝，虽然，两个变量的值相等，但是两个变量保存了两个不同的基本数据类型值。<br>　　b只是保存了a复制的一个副本。所以，b的改变，对a没有影响。</p>\n<h3 id=\"引用类型数据\"><a href=\"#引用类型数据\" class=\"headerlink\" title=\"引用类型数据\"></a>引用类型数据</h3><p>  也就是对象类型Object type，比如：Object 、Array 、Function 、Data等。<br>　　javascript的引用数据类型是保存在堆内存中的对象。<br>　　与其他语言的不同是，你不可以直接访问堆内存空间中的位置和操作堆内存空间。只能操作对象在栈内存中的引用地址。<br>　　所以，引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存中堆内存中的对象。<br>　　var obj1 = new Object();<br>　　var obj2 = obj1;<br>　　obj2.name = “我有名字了”;<br>　　console.log(obj1.name); // 我有名字了<br>　　说明这两个引用数据类型指向了同一个堆内存对象。obj1赋值给onj2，实际上这个堆内存对象在栈内存的引用地址复制了一份给了obj2，<br>　　但是实际上他们共同指向了同一个堆内存对象。实际上改变的是堆内存对象。</p>\n<blockquote>\n<p>总结区别</p>\n</blockquote>\n<h3 id=\"声明变量时不同的内存分配：\"><a href=\"#声明变量时不同的内存分配：\" class=\"headerlink\" title=\"声明变量时不同的内存分配：\"></a>声明变量时不同的内存分配：</h3><p>　　1）原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。<br>　　　　这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – 栈中。这样存储便于迅速查寻变量的值。<br>　　2）引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。<br>　　　  这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。<br>　　　  地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。</p>\n<h3 id=\"不同的内存分配机制也带来了不同的访问机制\"><a href=\"#不同的内存分配机制也带来了不同的访问机制\" class=\"headerlink\" title=\"不同的内存分配机制也带来了不同的访问机制\"></a>不同的内存分配机制也带来了不同的访问机制</h3><p>　　　<br>　　1）在javascript中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，<br>　　　　首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的按引用访问。<br>　　2）而原始类型的值则是可以直接访问到的。<br>　　<br>　　c 复制变量时的不同<br>　　<br>　　1）原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的value而已。<br>　　2）引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，<br>　　　　也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。<br>　　　　（这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了）。多了一个指针\n　</p>\n<h3 id=\"参数传递的不同（把实参复制给形参的过程）\"><a href=\"#参数传递的不同（把实参复制给形参的过程）\" class=\"headerlink\" title=\"参数传递的不同（把实参复制给形参的过程）\"></a>参数传递的不同（把实参复制给形参的过程）</h3><p>　　首先我们应该明确一点：ECMAScript中所有函数的参数都是按值来传递的。<br>　　但是为什么涉及到原始类型与引用类型的值时仍然有区别呢？还不就是因为内存分配时的差别。 　<br>　　1）原始值：只是把变量里的值传递给参数，之后参数和这个变量互不影响。<br>　　2）引用值：对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！<br>　　　　因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>基本数据类型、引用数据类型</p>\n</blockquote>\n<p>ECMAScript包括两个不同类型的值：基本数据类型和引用数据类型。<br>基本数据类型指的是简单的数据段，引用数据类型指的是有多个值构成的对象。<br>当我们把变量赋值给一个变量时，解析器首先要确认的就是这个值是基本类型值还是引用类型值。</p>\n<h3 id=\"常见的基本数据类型\"><a href=\"#常见的基本数据类型\" class=\"headerlink\" title=\"常见的基本数据类型\"></a>常见的基本数据类型</h3><p>Number、String 、Boolean、Null和Undefined。基本数据类型是按值访问的，因为可以直接操作保存在变量中的实际值。示例：<br>　　var a = 10;<br>　　var b = a;<br>　　b = 20;<br>　　console.log(a); // 10值<br>　　上面，b获取的是a值得一份拷贝，虽然，两个变量的值相等，但是两个变量保存了两个不同的基本数据类型值。<br>　　b只是保存了a复制的一个副本。所以，b的改变，对a没有影响。</p>\n<h3 id=\"引用类型数据\"><a href=\"#引用类型数据\" class=\"headerlink\" title=\"引用类型数据\"></a>引用类型数据</h3><p>  也就是对象类型Object type，比如：Object 、Array 、Function 、Data等。<br>　　javascript的引用数据类型是保存在堆内存中的对象。<br>　　与其他语言的不同是，你不可以直接访问堆内存空间中的位置和操作堆内存空间。只能操作对象在栈内存中的引用地址。<br>　　所以，引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存中堆内存中的对象。<br>　　var obj1 = new Object();<br>　　var obj2 = obj1;<br>　　obj2.name = “我有名字了”;<br>　　console.log(obj1.name); // 我有名字了<br>　　说明这两个引用数据类型指向了同一个堆内存对象。obj1赋值给onj2，实际上这个堆内存对象在栈内存的引用地址复制了一份给了obj2，<br>　　但是实际上他们共同指向了同一个堆内存对象。实际上改变的是堆内存对象。</p>\n<blockquote>\n<p>总结区别</p>\n</blockquote>\n<h3 id=\"声明变量时不同的内存分配：\"><a href=\"#声明变量时不同的内存分配：\" class=\"headerlink\" title=\"声明变量时不同的内存分配：\"></a>声明变量时不同的内存分配：</h3><p>　　1）原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。<br>　　　　这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – 栈中。这样存储便于迅速查寻变量的值。<br>　　2）引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。<br>　　　  这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。<br>　　　  地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。</p>\n<h3 id=\"不同的内存分配机制也带来了不同的访问机制\"><a href=\"#不同的内存分配机制也带来了不同的访问机制\" class=\"headerlink\" title=\"不同的内存分配机制也带来了不同的访问机制\"></a>不同的内存分配机制也带来了不同的访问机制</h3><p>　　　<br>　　1）在javascript中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，<br>　　　　首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的按引用访问。<br>　　2）而原始类型的值则是可以直接访问到的。<br>　　<br>　　c 复制变量时的不同<br>　　<br>　　1）原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的value而已。<br>　　2）引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，<br>　　　　也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。<br>　　　　（这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了）。多了一个指针\n　</p>\n<h3 id=\"参数传递的不同（把实参复制给形参的过程）\"><a href=\"#参数传递的不同（把实参复制给形参的过程）\" class=\"headerlink\" title=\"参数传递的不同（把实参复制给形参的过程）\"></a>参数传递的不同（把实参复制给形参的过程）</h3><p>　　首先我们应该明确一点：ECMAScript中所有函数的参数都是按值来传递的。<br>　　但是为什么涉及到原始类型与引用类型的值时仍然有区别呢？还不就是因为内存分配时的差别。 　<br>　　1）原始值：只是把变量里的值传递给参数，之后参数和这个变量互不影响。<br>　　2）引用值：对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！<br>　　　　因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象。</p>\n"},{"title":"markdown 写法备注","_content":"\n> 标题\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n\n> 无序列表\n* 1\n+ 2\n- 3\n\n> 有序列表\n1. 列表  \n2. 列表\n3. 列表\n\n>分割线\n***\n---\n\n>代码块 ```\n\n>文本样式\n\n  *字体倾斜*                >        <em>字体倾斜</em>\n  _字体倾斜_\n  **字体加粗**              >        <strong>字体加粗</strong>\n  __字体加粗__\n  ~~字体删除~~              >        <del>字体删除</del>\n ! 符号与字体之间不要有空格\n","source":"_posts/remarks.md","raw":"---\ntitle: markdown 写法备注\ntag: markdown\n---\n\n> 标题\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n\n> 无序列表\n* 1\n+ 2\n- 3\n\n> 有序列表\n1. 列表  \n2. 列表\n3. 列表\n\n>分割线\n***\n---\n\n>代码块 ```\n\n>文本样式\n\n  *字体倾斜*                >        <em>字体倾斜</em>\n  _字体倾斜_\n  **字体加粗**              >        <strong>字体加粗</strong>\n  __字体加粗__\n  ~~字体删除~~              >        <del>字体删除</del>\n ! 符号与字体之间不要有空格\n","slug":"remarks","published":1,"date":"2021-07-19T02:24:31.489Z","updated":"2021-07-19T03:02:22.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckra8m0qr00011van6o2m2k9r","content":"<blockquote>\n<p>标题</p>\n</blockquote>\n<h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><blockquote>\n<p>无序列表</p>\n</blockquote>\n<ul>\n<li>1</li>\n</ul>\n<ul>\n<li>2</li>\n</ul>\n<ul>\n<li>3</li>\n</ul>\n<blockquote>\n<p>有序列表</p>\n</blockquote>\n<ol>\n<li>列表  </li>\n<li>列表</li>\n<li>列表</li>\n</ol>\n<blockquote>\n<p>分割线</p>\n</blockquote>\n<hr>\n<hr>\n<blockquote>\n<p>代码块 ```</p>\n</blockquote>\n<blockquote>\n<p>文本样式</p>\n</blockquote>\n<p>  <em>字体倾斜</em>                &gt;        <em>字体倾斜</em><br>  <em>字体倾斜</em><br>  <strong>字体加粗</strong>              &gt;        <strong>字体加粗</strong><br>  <strong>字体加粗</strong><br>  <del>字体删除</del>              &gt;        <del>字体删除</del><br> ! 符号与字体之间不要有空格</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>标题</p>\n</blockquote>\n<h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><blockquote>\n<p>无序列表</p>\n</blockquote>\n<ul>\n<li>1</li>\n</ul>\n<ul>\n<li>2</li>\n</ul>\n<ul>\n<li>3</li>\n</ul>\n<blockquote>\n<p>有序列表</p>\n</blockquote>\n<ol>\n<li>列表  </li>\n<li>列表</li>\n<li>列表</li>\n</ol>\n<blockquote>\n<p>分割线</p>\n</blockquote>\n<hr>\n<hr>\n<blockquote>\n<p>代码块 ```</p>\n</blockquote>\n<blockquote>\n<p>文本样式</p>\n</blockquote>\n<p>  <em>字体倾斜</em>                &gt;        <em>字体倾斜</em><br>  <em>字体倾斜</em><br>  <strong>字体加粗</strong>              &gt;        <strong>字体加粗</strong><br>  <strong>字体加粗</strong><br>  <del>字体删除</del>              &gt;        <del>字体删除</del><br> ! 符号与字体之间不要有空格</p>\n"},{"title":"this词法","_content":"\nES6添加了一个特殊的词法形式的函数声明，叫做箭头函数，箭头函数在涉及this绑定的行为和普通函数的行为完全不一样，他放弃了所有的普通函数this绑定的规则，取而代之的是用当前的词法作用域覆盖了this原本的值。\n\n```JavaScript\nvar obj = {\n    count: 0,\n    cool: function coolFn() {\n        if(this.count < 1) {\n            setTimeout(() => {\n                this.count++;\n                console.log('awesome?');\n            },1000);\n        }\n    }\n}\nobj.cool();//awesome?\n```\n这个箭头函数中的this直接是cool()的this绑定（因此调用它并不会出错）\n\n它将程序员们经常犯的一个错误给标准化了，也就是混淆了this绑定规则和词法作用域规则。\n\n另一个导致箭头函数不够理想的原因是他不是具名的，而是一个匿名函数。\n\n\n### 误解：\n\n1. 人们很容易把this理解成指向函数自身。那么为什么函数要从内部引用函数自身呢？常见的原因是递归（从函数内部调用这个函数）或者可以写在第一次被调用后自己解除绑定事件处理器。\n2. 新手通常会认为，既然把函数看做一个对象，那就可以在调用函数时储存状态。\n\n\ncall\n```JavaScript\nfunction foo(num) {\n    console.log(\"foo\" + num);\n    this.count ++;\n}\nfoo.count = 0;\nvar i;\nfor(i = 0; i < 10; i++){\n    if(i > 5) {\n        // 使用call(...) 可以确保this指向函数本身\n        foo.call(foo, i)\n    }\n}\n// foo: 6\n// foo: 7\n// foo: 8\n// foo: 9\n\ncnosole.log(foo.count); // 4\n```\n\n### 它的作用域\n还有一种常见的错误是，this指向函数的作用域。这个问题在某中情况下是正确的，但是有时候又是错误的。需要明确的是this在任何情况下都不指向函数的词法作域。\n\n```JavaScript\nfunction foo(){\n    var a = 2;\n    this.bar(); //  能调用到bar也是意外，正常应该通过词法作用域，直接执行\n}\nfunction bar(){\n    console.log(this.a)\n}\n\nfoo();  // a not defined\n```\n\n\n==当你想把this和词法作用域的查找混合使用的时候，一定要提醒自己这是无法实现的==\n\n### 是什么\n\nthis不是在写代码时候绑定的而是代码在执行的时候绑定的，它的上下文取决于函数调用时的各种条件。\n\nthis的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。\n\n==当一个函数被执行时，会创建一个活动记录（有时候也被称之为执行上下文）。这个记录会包含函数在哪里被调用、函数的调用方式、传入参数等信息。this就是这个记录的一个属性，会在函数执行的过程中调用到。==\n\nthis实际上是在函数被调用的时候发生绑定，他指向什么完全取决于函数在哪里被调用。","source":"_posts/this词法.md","raw":"---\ntitle: this词法\ntag: javaScript\n---\n\nES6添加了一个特殊的词法形式的函数声明，叫做箭头函数，箭头函数在涉及this绑定的行为和普通函数的行为完全不一样，他放弃了所有的普通函数this绑定的规则，取而代之的是用当前的词法作用域覆盖了this原本的值。\n\n```JavaScript\nvar obj = {\n    count: 0,\n    cool: function coolFn() {\n        if(this.count < 1) {\n            setTimeout(() => {\n                this.count++;\n                console.log('awesome?');\n            },1000);\n        }\n    }\n}\nobj.cool();//awesome?\n```\n这个箭头函数中的this直接是cool()的this绑定（因此调用它并不会出错）\n\n它将程序员们经常犯的一个错误给标准化了，也就是混淆了this绑定规则和词法作用域规则。\n\n另一个导致箭头函数不够理想的原因是他不是具名的，而是一个匿名函数。\n\n\n### 误解：\n\n1. 人们很容易把this理解成指向函数自身。那么为什么函数要从内部引用函数自身呢？常见的原因是递归（从函数内部调用这个函数）或者可以写在第一次被调用后自己解除绑定事件处理器。\n2. 新手通常会认为，既然把函数看做一个对象，那就可以在调用函数时储存状态。\n\n\ncall\n```JavaScript\nfunction foo(num) {\n    console.log(\"foo\" + num);\n    this.count ++;\n}\nfoo.count = 0;\nvar i;\nfor(i = 0; i < 10; i++){\n    if(i > 5) {\n        // 使用call(...) 可以确保this指向函数本身\n        foo.call(foo, i)\n    }\n}\n// foo: 6\n// foo: 7\n// foo: 8\n// foo: 9\n\ncnosole.log(foo.count); // 4\n```\n\n### 它的作用域\n还有一种常见的错误是，this指向函数的作用域。这个问题在某中情况下是正确的，但是有时候又是错误的。需要明确的是this在任何情况下都不指向函数的词法作域。\n\n```JavaScript\nfunction foo(){\n    var a = 2;\n    this.bar(); //  能调用到bar也是意外，正常应该通过词法作用域，直接执行\n}\nfunction bar(){\n    console.log(this.a)\n}\n\nfoo();  // a not defined\n```\n\n\n==当你想把this和词法作用域的查找混合使用的时候，一定要提醒自己这是无法实现的==\n\n### 是什么\n\nthis不是在写代码时候绑定的而是代码在执行的时候绑定的，它的上下文取决于函数调用时的各种条件。\n\nthis的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。\n\n==当一个函数被执行时，会创建一个活动记录（有时候也被称之为执行上下文）。这个记录会包含函数在哪里被调用、函数的调用方式、传入参数等信息。this就是这个记录的一个属性，会在函数执行的过程中调用到。==\n\nthis实际上是在函数被调用的时候发生绑定，他指向什么完全取决于函数在哪里被调用。","slug":"this词法","published":1,"date":"2021-07-17T05:52:23.886Z","updated":"2021-07-17T05:52:23.886Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckra8m0qu00031vanayuq8350","content":"<p>ES6添加了一个特殊的词法形式的函数声明，叫做箭头函数，箭头函数在涉及this绑定的行为和普通函数的行为完全不一样，他放弃了所有的普通函数this绑定的规则，取而代之的是用当前的词法作用域覆盖了this原本的值。</p>\n<pre><code class=\"JavaScript\">var obj = &#123;\n    count: 0,\n    cool: function coolFn() &#123;\n        if(this.count &lt; 1) &#123;\n            setTimeout(() =&gt; &#123;\n                this.count++;\n                console.log(&#39;awesome?&#39;);\n            &#125;,1000);\n        &#125;\n    &#125;\n&#125;\nobj.cool();//awesome?\n</code></pre>\n<p>这个箭头函数中的this直接是cool()的this绑定（因此调用它并不会出错）</p>\n<p>它将程序员们经常犯的一个错误给标准化了，也就是混淆了this绑定规则和词法作用域规则。</p>\n<p>另一个导致箭头函数不够理想的原因是他不是具名的，而是一个匿名函数。</p>\n<h3 id=\"误解：\"><a href=\"#误解：\" class=\"headerlink\" title=\"误解：\"></a>误解：</h3><ol>\n<li>人们很容易把this理解成指向函数自身。那么为什么函数要从内部引用函数自身呢？常见的原因是递归（从函数内部调用这个函数）或者可以写在第一次被调用后自己解除绑定事件处理器。</li>\n<li>新手通常会认为，既然把函数看做一个对象，那就可以在调用函数时储存状态。</li>\n</ol>\n<p>call</p>\n<pre><code class=\"JavaScript\">function foo(num) &#123;\n    console.log(&quot;foo&quot; + num);\n    this.count ++;\n&#125;\nfoo.count = 0;\nvar i;\nfor(i = 0; i &lt; 10; i++)&#123;\n    if(i &gt; 5) &#123;\n        // 使用call(...) 可以确保this指向函数本身\n        foo.call(foo, i)\n    &#125;\n&#125;\n// foo: 6\n// foo: 7\n// foo: 8\n// foo: 9\n\ncnosole.log(foo.count); // 4\n</code></pre>\n<h3 id=\"它的作用域\"><a href=\"#它的作用域\" class=\"headerlink\" title=\"它的作用域\"></a>它的作用域</h3><p>还有一种常见的错误是，this指向函数的作用域。这个问题在某中情况下是正确的，但是有时候又是错误的。需要明确的是this在任何情况下都不指向函数的词法作域。</p>\n<pre><code class=\"JavaScript\">function foo()&#123;\n    var a = 2;\n    this.bar(); //  能调用到bar也是意外，正常应该通过词法作用域，直接执行\n&#125;\nfunction bar()&#123;\n    console.log(this.a)\n&#125;\n\nfoo();  // a not defined\n</code></pre>\n<p>==当你想把this和词法作用域的查找混合使用的时候，一定要提醒自己这是无法实现的==</p>\n<h3 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h3><p>this不是在写代码时候绑定的而是代码在执行的时候绑定的，它的上下文取决于函数调用时的各种条件。</p>\n<p>this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</p>\n<p>==当一个函数被执行时，会创建一个活动记录（有时候也被称之为执行上下文）。这个记录会包含函数在哪里被调用、函数的调用方式、传入参数等信息。this就是这个记录的一个属性，会在函数执行的过程中调用到。==</p>\n<p>this实际上是在函数被调用的时候发生绑定，他指向什么完全取决于函数在哪里被调用。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>ES6添加了一个特殊的词法形式的函数声明，叫做箭头函数，箭头函数在涉及this绑定的行为和普通函数的行为完全不一样，他放弃了所有的普通函数this绑定的规则，取而代之的是用当前的词法作用域覆盖了this原本的值。</p>\n<pre><code class=\"JavaScript\">var obj = &#123;\n    count: 0,\n    cool: function coolFn() &#123;\n        if(this.count &lt; 1) &#123;\n            setTimeout(() =&gt; &#123;\n                this.count++;\n                console.log(&#39;awesome?&#39;);\n            &#125;,1000);\n        &#125;\n    &#125;\n&#125;\nobj.cool();//awesome?\n</code></pre>\n<p>这个箭头函数中的this直接是cool()的this绑定（因此调用它并不会出错）</p>\n<p>它将程序员们经常犯的一个错误给标准化了，也就是混淆了this绑定规则和词法作用域规则。</p>\n<p>另一个导致箭头函数不够理想的原因是他不是具名的，而是一个匿名函数。</p>\n<h3 id=\"误解：\"><a href=\"#误解：\" class=\"headerlink\" title=\"误解：\"></a>误解：</h3><ol>\n<li>人们很容易把this理解成指向函数自身。那么为什么函数要从内部引用函数自身呢？常见的原因是递归（从函数内部调用这个函数）或者可以写在第一次被调用后自己解除绑定事件处理器。</li>\n<li>新手通常会认为，既然把函数看做一个对象，那就可以在调用函数时储存状态。</li>\n</ol>\n<p>call</p>\n<pre><code class=\"JavaScript\">function foo(num) &#123;\n    console.log(&quot;foo&quot; + num);\n    this.count ++;\n&#125;\nfoo.count = 0;\nvar i;\nfor(i = 0; i &lt; 10; i++)&#123;\n    if(i &gt; 5) &#123;\n        // 使用call(...) 可以确保this指向函数本身\n        foo.call(foo, i)\n    &#125;\n&#125;\n// foo: 6\n// foo: 7\n// foo: 8\n// foo: 9\n\ncnosole.log(foo.count); // 4\n</code></pre>\n<h3 id=\"它的作用域\"><a href=\"#它的作用域\" class=\"headerlink\" title=\"它的作用域\"></a>它的作用域</h3><p>还有一种常见的错误是，this指向函数的作用域。这个问题在某中情况下是正确的，但是有时候又是错误的。需要明确的是this在任何情况下都不指向函数的词法作域。</p>\n<pre><code class=\"JavaScript\">function foo()&#123;\n    var a = 2;\n    this.bar(); //  能调用到bar也是意外，正常应该通过词法作用域，直接执行\n&#125;\nfunction bar()&#123;\n    console.log(this.a)\n&#125;\n\nfoo();  // a not defined\n</code></pre>\n<p>==当你想把this和词法作用域的查找混合使用的时候，一定要提醒自己这是无法实现的==</p>\n<h3 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h3><p>this不是在写代码时候绑定的而是代码在执行的时候绑定的，它的上下文取决于函数调用时的各种条件。</p>\n<p>this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</p>\n<p>==当一个函数被执行时，会创建一个活动记录（有时候也被称之为执行上下文）。这个记录会包含函数在哪里被调用、函数的调用方式、传入参数等信息。this就是这个记录的一个属性，会在函数执行的过程中调用到。==</p>\n<p>this实际上是在函数被调用的时候发生绑定，他指向什么完全取决于函数在哪里被调用。</p>\n"},{"title":"作用域是什么-词法作用域","_content":"\n作用域是什么\n-\n- 存储变量的规则\n存储在哪里？怎么获取？\n\nvar a = 2\n\n为一个变量分配内存，名字为a，将值为2保存进这个变量（不完全正确）\n\n1. var a 编译器会询问作用域是否已经存在这样一个变量存在于同一个作用域内，如果有编译器会忽略该声明，继续编译，如果没有，他会要求作用域在当前作用域内声明一个新的变量，并命名为a。\n2. 接下载编译器会为引擎生成运行时所需要的代码，这些代码被用来处理a = 2 的操作，引擎运行时会询问作用域当前作用域集合中是否存在叫做a的变量，如果有，就是用该变量，如果没有会再向再外层的作用域询问，最终会到全局作用域。找到后会将2赋值给它，找不到就会抛出异常\n\n>总结：变量的赋值操作会执行两个动作，编译器在作用域中声明，运行时引擎会查找该变量并进行赋值。\n\n>编译器：LHS查询   查找类型RHS（LHS，RHS），当变量出现在赋值操作的左侧时进行进行LHS查询，出现在右侧时进行RHS查询。\n\nconsole.log（a） 执行的是RHS，要去找a的值；\n\na = 2 执行的是LHS 要为=2找到赋值的目标。\n\nLHS：赋值操作的目标是谁；目的是对变量进行赋值\n\nRHS：谁是赋值操作的源头；目的是获取变量的值\n\n\nReferenceError 这个错误是找不到定义的变量\n\n词法作用域\n-\n作用域有两种主要的工作模型：词法作用域，动态作用域。\n\n词法作用域：定义在词法阶段的作用域，就是由你写代码时将变量和块作用域写在哪里决定的，因此词法解析器处理代码时会保持作用域不变（大部分情况下是这样）\n\n词法欺骗：\n>eval( )\n```JavaScript\nfunction foo(str, a) {\n    eval(str); // 欺骗\n    console.log(a, b);\n}\nvar b = 2;\n\nfoo('val b = 3;', 1); // 1, 3\n```\n>with(){}\n```JavaScript\nfunction foo(obj) {\n    with(obj){\n        a = 2;\n    }\n}\n\nvar o1 = {\n    a: 3\n}\n\nvar o2 = {\n    a: 3\n}\n\nfoo(o1);\nconsole.log(o1.a) // 2\n\nfoo(o2);\nconsole.log(o2.a) // undefined\nconsole.log(a) // 2  ==a被泄漏到全局上面去了==\n\n```\n\n>总结\neval（）函数如果接受了一个或多个声明的代码，就会修改其所处的词法作用域；\nwith声明实际上是根据传递给他的对象凭空创建了一个全新的词法作用域\n\neval，with会降低性能，所以不建议使用\n\n\n\n\n\n\n\n","source":"_posts/作用域是什么-词法作用域.md","raw":"---\ntitle: 作用域是什么-词法作用域\ntag: javaScript\n---\n\n作用域是什么\n-\n- 存储变量的规则\n存储在哪里？怎么获取？\n\nvar a = 2\n\n为一个变量分配内存，名字为a，将值为2保存进这个变量（不完全正确）\n\n1. var a 编译器会询问作用域是否已经存在这样一个变量存在于同一个作用域内，如果有编译器会忽略该声明，继续编译，如果没有，他会要求作用域在当前作用域内声明一个新的变量，并命名为a。\n2. 接下载编译器会为引擎生成运行时所需要的代码，这些代码被用来处理a = 2 的操作，引擎运行时会询问作用域当前作用域集合中是否存在叫做a的变量，如果有，就是用该变量，如果没有会再向再外层的作用域询问，最终会到全局作用域。找到后会将2赋值给它，找不到就会抛出异常\n\n>总结：变量的赋值操作会执行两个动作，编译器在作用域中声明，运行时引擎会查找该变量并进行赋值。\n\n>编译器：LHS查询   查找类型RHS（LHS，RHS），当变量出现在赋值操作的左侧时进行进行LHS查询，出现在右侧时进行RHS查询。\n\nconsole.log（a） 执行的是RHS，要去找a的值；\n\na = 2 执行的是LHS 要为=2找到赋值的目标。\n\nLHS：赋值操作的目标是谁；目的是对变量进行赋值\n\nRHS：谁是赋值操作的源头；目的是获取变量的值\n\n\nReferenceError 这个错误是找不到定义的变量\n\n词法作用域\n-\n作用域有两种主要的工作模型：词法作用域，动态作用域。\n\n词法作用域：定义在词法阶段的作用域，就是由你写代码时将变量和块作用域写在哪里决定的，因此词法解析器处理代码时会保持作用域不变（大部分情况下是这样）\n\n词法欺骗：\n>eval( )\n```JavaScript\nfunction foo(str, a) {\n    eval(str); // 欺骗\n    console.log(a, b);\n}\nvar b = 2;\n\nfoo('val b = 3;', 1); // 1, 3\n```\n>with(){}\n```JavaScript\nfunction foo(obj) {\n    with(obj){\n        a = 2;\n    }\n}\n\nvar o1 = {\n    a: 3\n}\n\nvar o2 = {\n    a: 3\n}\n\nfoo(o1);\nconsole.log(o1.a) // 2\n\nfoo(o2);\nconsole.log(o2.a) // undefined\nconsole.log(a) // 2  ==a被泄漏到全局上面去了==\n\n```\n\n>总结\neval（）函数如果接受了一个或多个声明的代码，就会修改其所处的词法作用域；\nwith声明实际上是根据传递给他的对象凭空创建了一个全新的词法作用域\n\neval，with会降低性能，所以不建议使用\n\n\n\n\n\n\n\n","slug":"作用域是什么-词法作用域","published":1,"date":"2021-07-17T05:52:14.244Z","updated":"2021-07-17T05:52:14.244Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckra8m0qv00041vanay4ifg1s","content":"<h2 id=\"作用域是什么\"><a href=\"#作用域是什么\" class=\"headerlink\" title=\"作用域是什么\"></a>作用域是什么</h2><ul>\n<li>存储变量的规则<br>存储在哪里？怎么获取？</li>\n</ul>\n<p>var a = 2</p>\n<p>为一个变量分配内存，名字为a，将值为2保存进这个变量（不完全正确）</p>\n<ol>\n<li>var a 编译器会询问作用域是否已经存在这样一个变量存在于同一个作用域内，如果有编译器会忽略该声明，继续编译，如果没有，他会要求作用域在当前作用域内声明一个新的变量，并命名为a。</li>\n<li>接下载编译器会为引擎生成运行时所需要的代码，这些代码被用来处理a = 2 的操作，引擎运行时会询问作用域当前作用域集合中是否存在叫做a的变量，如果有，就是用该变量，如果没有会再向再外层的作用域询问，最终会到全局作用域。找到后会将2赋值给它，找不到就会抛出异常</li>\n</ol>\n<blockquote>\n<p>总结：变量的赋值操作会执行两个动作，编译器在作用域中声明，运行时引擎会查找该变量并进行赋值。</p>\n</blockquote>\n<blockquote>\n<p>编译器：LHS查询   查找类型RHS（LHS，RHS），当变量出现在赋值操作的左侧时进行进行LHS查询，出现在右侧时进行RHS查询。</p>\n</blockquote>\n<p>console.log（a） 执行的是RHS，要去找a的值；</p>\n<p>a = 2 执行的是LHS 要为=2找到赋值的目标。</p>\n<p>LHS：赋值操作的目标是谁；目的是对变量进行赋值</p>\n<p>RHS：谁是赋值操作的源头；目的是获取变量的值</p>\n<p>ReferenceError 这个错误是找不到定义的变量</p>\n<h2 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h2><p>作用域有两种主要的工作模型：词法作用域，动态作用域。</p>\n<p>词法作用域：定义在词法阶段的作用域，就是由你写代码时将变量和块作用域写在哪里决定的，因此词法解析器处理代码时会保持作用域不变（大部分情况下是这样）</p>\n<p>词法欺骗：</p>\n<blockquote>\n<p>eval( )</p>\n</blockquote>\n<pre><code class=\"JavaScript\">function foo(str, a) &#123;\n    eval(str); // 欺骗\n    console.log(a, b);\n&#125;\nvar b = 2;\n\nfoo(&#39;val b = 3;&#39;, 1); // 1, 3\n</code></pre>\n<blockquote>\n<p>with(){}</p>\n</blockquote>\n<pre><code class=\"JavaScript\">function foo(obj) &#123;\n    with(obj)&#123;\n        a = 2;\n    &#125;\n&#125;\n\nvar o1 = &#123;\n    a: 3\n&#125;\n\nvar o2 = &#123;\n    a: 3\n&#125;\n\nfoo(o1);\nconsole.log(o1.a) // 2\n\nfoo(o2);\nconsole.log(o2.a) // undefined\nconsole.log(a) // 2  ==a被泄漏到全局上面去了==\n</code></pre>\n<blockquote>\n<p>总结<br>eval（）函数如果接受了一个或多个声明的代码，就会修改其所处的词法作用域；<br>with声明实际上是根据传递给他的对象凭空创建了一个全新的词法作用域</p>\n</blockquote>\n<p>eval，with会降低性能，所以不建议使用</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"作用域是什么\"><a href=\"#作用域是什么\" class=\"headerlink\" title=\"作用域是什么\"></a>作用域是什么</h2><ul>\n<li>存储变量的规则<br>存储在哪里？怎么获取？</li>\n</ul>\n<p>var a = 2</p>\n<p>为一个变量分配内存，名字为a，将值为2保存进这个变量（不完全正确）</p>\n<ol>\n<li>var a 编译器会询问作用域是否已经存在这样一个变量存在于同一个作用域内，如果有编译器会忽略该声明，继续编译，如果没有，他会要求作用域在当前作用域内声明一个新的变量，并命名为a。</li>\n<li>接下载编译器会为引擎生成运行时所需要的代码，这些代码被用来处理a = 2 的操作，引擎运行时会询问作用域当前作用域集合中是否存在叫做a的变量，如果有，就是用该变量，如果没有会再向再外层的作用域询问，最终会到全局作用域。找到后会将2赋值给它，找不到就会抛出异常</li>\n</ol>\n<blockquote>\n<p>总结：变量的赋值操作会执行两个动作，编译器在作用域中声明，运行时引擎会查找该变量并进行赋值。</p>\n</blockquote>\n<blockquote>\n<p>编译器：LHS查询   查找类型RHS（LHS，RHS），当变量出现在赋值操作的左侧时进行进行LHS查询，出现在右侧时进行RHS查询。</p>\n</blockquote>\n<p>console.log（a） 执行的是RHS，要去找a的值；</p>\n<p>a = 2 执行的是LHS 要为=2找到赋值的目标。</p>\n<p>LHS：赋值操作的目标是谁；目的是对变量进行赋值</p>\n<p>RHS：谁是赋值操作的源头；目的是获取变量的值</p>\n<p>ReferenceError 这个错误是找不到定义的变量</p>\n<h2 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h2><p>作用域有两种主要的工作模型：词法作用域，动态作用域。</p>\n<p>词法作用域：定义在词法阶段的作用域，就是由你写代码时将变量和块作用域写在哪里决定的，因此词法解析器处理代码时会保持作用域不变（大部分情况下是这样）</p>\n<p>词法欺骗：</p>\n<blockquote>\n<p>eval( )</p>\n</blockquote>\n<pre><code class=\"JavaScript\">function foo(str, a) &#123;\n    eval(str); // 欺骗\n    console.log(a, b);\n&#125;\nvar b = 2;\n\nfoo(&#39;val b = 3;&#39;, 1); // 1, 3\n</code></pre>\n<blockquote>\n<p>with(){}</p>\n</blockquote>\n<pre><code class=\"JavaScript\">function foo(obj) &#123;\n    with(obj)&#123;\n        a = 2;\n    &#125;\n&#125;\n\nvar o1 = &#123;\n    a: 3\n&#125;\n\nvar o2 = &#123;\n    a: 3\n&#125;\n\nfoo(o1);\nconsole.log(o1.a) // 2\n\nfoo(o2);\nconsole.log(o2.a) // undefined\nconsole.log(a) // 2  ==a被泄漏到全局上面去了==\n</code></pre>\n<blockquote>\n<p>总结<br>eval（）函数如果接受了一个或多个声明的代码，就会修改其所处的词法作用域；<br>with声明实际上是根据传递给他的对象凭空创建了一个全新的词法作用域</p>\n</blockquote>\n<p>eval，with会降低性能，所以不建议使用</p>\n"},{"title":"函数中的作用域","_content":"\n函数中的作用域\n---\njs有基于函数的作用域，每声明一个函数都会为其自身创建一个气泡，可以在附属气泡里获取外层的变量，但是不能从外层气泡中获取附属气泡种的变量\n\n隐藏内部实现\n---\n>暴露在外面的写法，很不安全\n```JavaScript\nfunction foo(a) {\n    b = a + fff(a * 2);\n    console.log(b * 3);\n}\nfunction fff(a) {\n    return a - 1;\n}\n\nvar b;\nfoo(2) // 15\n```\n\n>隐藏的写法\n\n```JavaScript\nfunction foo(a) {\n    function fff(a) {\n        return a - 1;\n    }\n    var b;\n    b = a + fff(a * 2);\n    console.log(b * 3);\n}\nfoo(2) // 15\n```\n\n>规避冲突，\n可以避免同名标识符之间的冲突，避免被覆盖\n\n方法：\n1. 全局命名空间，在全局声明一个独特的变量，通常是一个对象，所有需要暴露给外界的功能都会成为这个对象的属性，而不是将自己的标识符暴露在顶级的词法作用域种。\n2. 模块管理，从众多模块中挑选一个来使用，任何库都无需将标识符加入到全局作用域中。\n\n\n函数作用域\n---\n在任意代码片段外部添加包装函数都可以将内部的变量和函数定义‘隐藏’起来，外部作用域无法访问包装函数内部的任何内容\n\n通过定义一个函数来达到是变量在函数作用域之内，虽然可以解决问题，但是并不理想，因为这个函数名称本身污染了所在的作用域，其次是必须通过显式的调用这个函数才能运行其中的代码。\n\n\n```JavaScript\nvar a = 2;\n(function foo(){\n    var a = 3;\n    console.log( a ); // 3\n})();\nconsole.log( a ); // 2\n\n```\n这样函数会被当作函数表达式而不是一个标准的函数声明来处理。-- 如果function是声明中的第一个第一个词，那么就是函数声明，否则就是函数表达式。\n\n函数表达式和函数声明最大的区别是它们的名称标识符将会绑定在何处。  foo只能在所代表的位置中被访问，外部不行。\n\n匿名和具名\n---\n>匿名函数表达式\n```JavaScript\nsetTimeout( function(){\n    console.log('aaa');\n},1000);\n```\nfun没有标识符，函数声明则是不可以省略函数名称\n\n1. 匿名函数在栈追踪中不会显示出有意义的函数名称，使得调用很困难。\n2. 如果没有函数名，需要引用的时候就只能使用已经过期的arguments.callee引用，比如在递归中\n3. 匿名函数省略了对于代码的可读性/可理解性很重要的函数名\n\n行内函数表达式\n```JavaScript\nsetTimeout( function timeoutHandler(){\n    console.log('aaa');\n},1000);\n```\n\n立即执行函数表达式\n---\n\n```JavaScript\nvar a = 2;\n(function foo(){\n    var a = 3;\n    console.log( a ); // 3\n})();\nconsole.log( a ); // 2\n```\n第一个（）将函数变成了表达式，第二个（）执行了这个函数\n\n>IIFE代表立即执行函数表达式\n```JavaScript\nvar a = 2;\n(function IIFE(){ //传统的形式\n    var a = 3;\n    console.log( a ); // 3\n})();\nconsole.log( a ); // 2\n```\n==以上两种写法功能上是一样的==\n\n用途：\n\n可以传参数进去\n```JavaScript\nvar a = 2;\n(function IIFE(global){ //传统的形式\n    var a = 3;\n    console.log( a ); // 3\n    console.log( global.a ); // 3\n})(window);\nconsole.log( a ); // 2\n```\n\n块作用域\n---\n除了函数能产生一个作用域气泡，for循环，if，with,try/catch等都会产生一个作用域气泡。\n\n块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块，通常指{..}的内部\n>var\n\n其实val一个变量无论在什么地方，都会提升到全局变量，把它写在作用域内部，只是为了风格更易读而伪装出的形式上的块作用域，如果使用这种，要确保在其他地方没有重复的使用同名的变量。\n\n>let\n\nES6引入了关键字let，可以将变量绑定到所在的任意作用域中，为其声明的变量隐式的劫持了所在的块作用域。\n\nlet进行声明的不会在代码在块作用域中进行提升，声明的代码在运行前，声明并不‘存在’。\n```JavaScript\n{\n    console.log(a); // ReferenceError(没有找到)\n    let a = 2;\n}\n\n```\nlet 声明附属于一个新的作用域而不是当前函数作用域（也不属于全局作用域）\n\n>const\n\n同样可以用来创建块作用域变量，但其值是固定的，之后的任何试图修改值的操作都会引起错误。\n\n```JavaScript\nvar foo = true;\nif(foo){\n    var a = 2;\n    const b = 3;\n    a = 4; // 正确\n    b = 6; // 错误\n}\nconsole.log(a) // 4\nconsole.log(b) // ReferenceError\n```\n任何声明在某个作用域内部的变量，都将附属于这个作用域\n\n小思考\n---\n\n```JavaScript\na = 2;\nval a;\nconsole.log(a);//2\n```\n输出2的原因是：声明会提升，也就是先声明再赋值，在执行查询\n\n```JavaScript\nconsole.log(a); // undefind\nvar a = 2;\n\n// 执行顺序\n\nval a;\nconsole.log(a); // undefind\na = 2;\n```\n原因：函数声明会提升，然后执行查询，此时是没有赋值的，所以是undefind\n\n\n```JavaScript\nfoo(); // 不是ReferenceError，而是TypeEerror\n\nvar foo = funcyion bar() {\n    //...\n};\n```\n原因：函数表达式不会被提升\n\n>函数优先\n\n函数声明和变量声明都会被提升，但是一个值得注意的细节是函数会被首先提升，然后才是变量。\n\n```JavaScript\nfoo(); //1\nvar foo;\nfunction foo() {\n    console.log(1);\n}\nfoo = function() {\n    console.log(2);\n}\n```\n输出的是1而不是2是因为函数声明先被提升到上面，然后在执行。var foo 尽管出现在function foo... 之前，但是他是重复声明会被忽略。\n>后面的声明会覆盖掉前面的声明\n\n```JavaScript\nfoo(); //3\nfunction foo() {\n    console.log(1);\n}\nvar foo = function() {\n    console.log(2);\n}\nfunction foo() {\n    console.log(3);\n}\n```\n\n\n\n\n","source":"_posts/函数作用域、作用域快.md","raw":"---\ntitle: 函数中的作用域\ntags: javaScript\n---\n\n函数中的作用域\n---\njs有基于函数的作用域，每声明一个函数都会为其自身创建一个气泡，可以在附属气泡里获取外层的变量，但是不能从外层气泡中获取附属气泡种的变量\n\n隐藏内部实现\n---\n>暴露在外面的写法，很不安全\n```JavaScript\nfunction foo(a) {\n    b = a + fff(a * 2);\n    console.log(b * 3);\n}\nfunction fff(a) {\n    return a - 1;\n}\n\nvar b;\nfoo(2) // 15\n```\n\n>隐藏的写法\n\n```JavaScript\nfunction foo(a) {\n    function fff(a) {\n        return a - 1;\n    }\n    var b;\n    b = a + fff(a * 2);\n    console.log(b * 3);\n}\nfoo(2) // 15\n```\n\n>规避冲突，\n可以避免同名标识符之间的冲突，避免被覆盖\n\n方法：\n1. 全局命名空间，在全局声明一个独特的变量，通常是一个对象，所有需要暴露给外界的功能都会成为这个对象的属性，而不是将自己的标识符暴露在顶级的词法作用域种。\n2. 模块管理，从众多模块中挑选一个来使用，任何库都无需将标识符加入到全局作用域中。\n\n\n函数作用域\n---\n在任意代码片段外部添加包装函数都可以将内部的变量和函数定义‘隐藏’起来，外部作用域无法访问包装函数内部的任何内容\n\n通过定义一个函数来达到是变量在函数作用域之内，虽然可以解决问题，但是并不理想，因为这个函数名称本身污染了所在的作用域，其次是必须通过显式的调用这个函数才能运行其中的代码。\n\n\n```JavaScript\nvar a = 2;\n(function foo(){\n    var a = 3;\n    console.log( a ); // 3\n})();\nconsole.log( a ); // 2\n\n```\n这样函数会被当作函数表达式而不是一个标准的函数声明来处理。-- 如果function是声明中的第一个第一个词，那么就是函数声明，否则就是函数表达式。\n\n函数表达式和函数声明最大的区别是它们的名称标识符将会绑定在何处。  foo只能在所代表的位置中被访问，外部不行。\n\n匿名和具名\n---\n>匿名函数表达式\n```JavaScript\nsetTimeout( function(){\n    console.log('aaa');\n},1000);\n```\nfun没有标识符，函数声明则是不可以省略函数名称\n\n1. 匿名函数在栈追踪中不会显示出有意义的函数名称，使得调用很困难。\n2. 如果没有函数名，需要引用的时候就只能使用已经过期的arguments.callee引用，比如在递归中\n3. 匿名函数省略了对于代码的可读性/可理解性很重要的函数名\n\n行内函数表达式\n```JavaScript\nsetTimeout( function timeoutHandler(){\n    console.log('aaa');\n},1000);\n```\n\n立即执行函数表达式\n---\n\n```JavaScript\nvar a = 2;\n(function foo(){\n    var a = 3;\n    console.log( a ); // 3\n})();\nconsole.log( a ); // 2\n```\n第一个（）将函数变成了表达式，第二个（）执行了这个函数\n\n>IIFE代表立即执行函数表达式\n```JavaScript\nvar a = 2;\n(function IIFE(){ //传统的形式\n    var a = 3;\n    console.log( a ); // 3\n})();\nconsole.log( a ); // 2\n```\n==以上两种写法功能上是一样的==\n\n用途：\n\n可以传参数进去\n```JavaScript\nvar a = 2;\n(function IIFE(global){ //传统的形式\n    var a = 3;\n    console.log( a ); // 3\n    console.log( global.a ); // 3\n})(window);\nconsole.log( a ); // 2\n```\n\n块作用域\n---\n除了函数能产生一个作用域气泡，for循环，if，with,try/catch等都会产生一个作用域气泡。\n\n块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块，通常指{..}的内部\n>var\n\n其实val一个变量无论在什么地方，都会提升到全局变量，把它写在作用域内部，只是为了风格更易读而伪装出的形式上的块作用域，如果使用这种，要确保在其他地方没有重复的使用同名的变量。\n\n>let\n\nES6引入了关键字let，可以将变量绑定到所在的任意作用域中，为其声明的变量隐式的劫持了所在的块作用域。\n\nlet进行声明的不会在代码在块作用域中进行提升，声明的代码在运行前，声明并不‘存在’。\n```JavaScript\n{\n    console.log(a); // ReferenceError(没有找到)\n    let a = 2;\n}\n\n```\nlet 声明附属于一个新的作用域而不是当前函数作用域（也不属于全局作用域）\n\n>const\n\n同样可以用来创建块作用域变量，但其值是固定的，之后的任何试图修改值的操作都会引起错误。\n\n```JavaScript\nvar foo = true;\nif(foo){\n    var a = 2;\n    const b = 3;\n    a = 4; // 正确\n    b = 6; // 错误\n}\nconsole.log(a) // 4\nconsole.log(b) // ReferenceError\n```\n任何声明在某个作用域内部的变量，都将附属于这个作用域\n\n小思考\n---\n\n```JavaScript\na = 2;\nval a;\nconsole.log(a);//2\n```\n输出2的原因是：声明会提升，也就是先声明再赋值，在执行查询\n\n```JavaScript\nconsole.log(a); // undefind\nvar a = 2;\n\n// 执行顺序\n\nval a;\nconsole.log(a); // undefind\na = 2;\n```\n原因：函数声明会提升，然后执行查询，此时是没有赋值的，所以是undefind\n\n\n```JavaScript\nfoo(); // 不是ReferenceError，而是TypeEerror\n\nvar foo = funcyion bar() {\n    //...\n};\n```\n原因：函数表达式不会被提升\n\n>函数优先\n\n函数声明和变量声明都会被提升，但是一个值得注意的细节是函数会被首先提升，然后才是变量。\n\n```JavaScript\nfoo(); //1\nvar foo;\nfunction foo() {\n    console.log(1);\n}\nfoo = function() {\n    console.log(2);\n}\n```\n输出的是1而不是2是因为函数声明先被提升到上面，然后在执行。var foo 尽管出现在function foo... 之前，但是他是重复声明会被忽略。\n>后面的声明会覆盖掉前面的声明\n\n```JavaScript\nfoo(); //3\nfunction foo() {\n    console.log(1);\n}\nvar foo = function() {\n    console.log(2);\n}\nfunction foo() {\n    console.log(3);\n}\n```\n\n\n\n\n","slug":"函数作用域、作用域快","published":1,"date":"2021-07-17T05:51:59.116Z","updated":"2021-07-17T05:51:59.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckra8m0qw00051van7ij3cjvj","content":"<h2 id=\"函数中的作用域\"><a href=\"#函数中的作用域\" class=\"headerlink\" title=\"函数中的作用域\"></a>函数中的作用域</h2><p>js有基于函数的作用域，每声明一个函数都会为其自身创建一个气泡，可以在附属气泡里获取外层的变量，但是不能从外层气泡中获取附属气泡种的变量</p>\n<h2 id=\"隐藏内部实现\"><a href=\"#隐藏内部实现\" class=\"headerlink\" title=\"隐藏内部实现\"></a>隐藏内部实现</h2><blockquote>\n<p>暴露在外面的写法，很不安全</p>\n</blockquote>\n<pre><code class=\"JavaScript\">function foo(a) &#123;\n    b = a + fff(a * 2);\n    console.log(b * 3);\n&#125;\nfunction fff(a) &#123;\n    return a - 1;\n&#125;\n\nvar b;\nfoo(2) // 15\n</code></pre>\n<blockquote>\n<p>隐藏的写法</p>\n</blockquote>\n<pre><code class=\"JavaScript\">function foo(a) &#123;\n    function fff(a) &#123;\n        return a - 1;\n    &#125;\n    var b;\n    b = a + fff(a * 2);\n    console.log(b * 3);\n&#125;\nfoo(2) // 15\n</code></pre>\n<blockquote>\n<p>规避冲突，<br>可以避免同名标识符之间的冲突，避免被覆盖</p>\n</blockquote>\n<p>方法：</p>\n<ol>\n<li>全局命名空间，在全局声明一个独特的变量，通常是一个对象，所有需要暴露给外界的功能都会成为这个对象的属性，而不是将自己的标识符暴露在顶级的词法作用域种。</li>\n<li>模块管理，从众多模块中挑选一个来使用，任何库都无需将标识符加入到全局作用域中。</li>\n</ol>\n<h2 id=\"函数作用域\"><a href=\"#函数作用域\" class=\"headerlink\" title=\"函数作用域\"></a>函数作用域</h2><p>在任意代码片段外部添加包装函数都可以将内部的变量和函数定义‘隐藏’起来，外部作用域无法访问包装函数内部的任何内容</p>\n<p>通过定义一个函数来达到是变量在函数作用域之内，虽然可以解决问题，但是并不理想，因为这个函数名称本身污染了所在的作用域，其次是必须通过显式的调用这个函数才能运行其中的代码。</p>\n<pre><code class=\"JavaScript\">var a = 2;\n(function foo()&#123;\n    var a = 3;\n    console.log( a ); // 3\n&#125;)();\nconsole.log( a ); // 2\n</code></pre>\n<p>这样函数会被当作函数表达式而不是一个标准的函数声明来处理。– 如果function是声明中的第一个第一个词，那么就是函数声明，否则就是函数表达式。</p>\n<p>函数表达式和函数声明最大的区别是它们的名称标识符将会绑定在何处。  foo只能在所代表的位置中被访问，外部不行。</p>\n<h2 id=\"匿名和具名\"><a href=\"#匿名和具名\" class=\"headerlink\" title=\"匿名和具名\"></a>匿名和具名</h2><blockquote>\n<p>匿名函数表达式</p>\n</blockquote>\n<pre><code class=\"JavaScript\">setTimeout( function()&#123;\n    console.log(&#39;aaa&#39;);\n&#125;,1000);\n</code></pre>\n<p>fun没有标识符，函数声明则是不可以省略函数名称</p>\n<ol>\n<li>匿名函数在栈追踪中不会显示出有意义的函数名称，使得调用很困难。</li>\n<li>如果没有函数名，需要引用的时候就只能使用已经过期的arguments.callee引用，比如在递归中</li>\n<li>匿名函数省略了对于代码的可读性/可理解性很重要的函数名</li>\n</ol>\n<p>行内函数表达式</p>\n<pre><code class=\"JavaScript\">setTimeout( function timeoutHandler()&#123;\n    console.log(&#39;aaa&#39;);\n&#125;,1000);\n</code></pre>\n<h2 id=\"立即执行函数表达式\"><a href=\"#立即执行函数表达式\" class=\"headerlink\" title=\"立即执行函数表达式\"></a>立即执行函数表达式</h2><pre><code class=\"JavaScript\">var a = 2;\n(function foo()&#123;\n    var a = 3;\n    console.log( a ); // 3\n&#125;)();\nconsole.log( a ); // 2\n</code></pre>\n<p>第一个（）将函数变成了表达式，第二个（）执行了这个函数</p>\n<blockquote>\n<p>IIFE代表立即执行函数表达式</p>\n</blockquote>\n<pre><code class=\"JavaScript\">var a = 2;\n(function IIFE()&#123; //传统的形式\n    var a = 3;\n    console.log( a ); // 3\n&#125;)();\nconsole.log( a ); // 2\n</code></pre>\n<p>==以上两种写法功能上是一样的==</p>\n<p>用途：</p>\n<p>可以传参数进去</p>\n<pre><code class=\"JavaScript\">var a = 2;\n(function IIFE(global)&#123; //传统的形式\n    var a = 3;\n    console.log( a ); // 3\n    console.log( global.a ); // 3\n&#125;)(window);\nconsole.log( a ); // 2\n</code></pre>\n<h2 id=\"块作用域\"><a href=\"#块作用域\" class=\"headerlink\" title=\"块作用域\"></a>块作用域</h2><p>除了函数能产生一个作用域气泡，for循环，if，with,try/catch等都会产生一个作用域气泡。</p>\n<p>块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块，通常指{..}的内部</p>\n<blockquote>\n<p>var</p>\n</blockquote>\n<p>其实val一个变量无论在什么地方，都会提升到全局变量，把它写在作用域内部，只是为了风格更易读而伪装出的形式上的块作用域，如果使用这种，要确保在其他地方没有重复的使用同名的变量。</p>\n<blockquote>\n<p>let</p>\n</blockquote>\n<p>ES6引入了关键字let，可以将变量绑定到所在的任意作用域中，为其声明的变量隐式的劫持了所在的块作用域。</p>\n<p>let进行声明的不会在代码在块作用域中进行提升，声明的代码在运行前，声明并不‘存在’。</p>\n<pre><code class=\"JavaScript\">&#123;\n    console.log(a); // ReferenceError(没有找到)\n    let a = 2;\n&#125;\n</code></pre>\n<p>let 声明附属于一个新的作用域而不是当前函数作用域（也不属于全局作用域）</p>\n<blockquote>\n<p>const</p>\n</blockquote>\n<p>同样可以用来创建块作用域变量，但其值是固定的，之后的任何试图修改值的操作都会引起错误。</p>\n<pre><code class=\"JavaScript\">var foo = true;\nif(foo)&#123;\n    var a = 2;\n    const b = 3;\n    a = 4; // 正确\n    b = 6; // 错误\n&#125;\nconsole.log(a) // 4\nconsole.log(b) // ReferenceError\n</code></pre>\n<p>任何声明在某个作用域内部的变量，都将附属于这个作用域</p>\n<h2 id=\"小思考\"><a href=\"#小思考\" class=\"headerlink\" title=\"小思考\"></a>小思考</h2><pre><code class=\"JavaScript\">a = 2;\nval a;\nconsole.log(a);//2\n</code></pre>\n<p>输出2的原因是：声明会提升，也就是先声明再赋值，在执行查询</p>\n<pre><code class=\"JavaScript\">console.log(a); // undefind\nvar a = 2;\n\n// 执行顺序\n\nval a;\nconsole.log(a); // undefind\na = 2;\n</code></pre>\n<p>原因：函数声明会提升，然后执行查询，此时是没有赋值的，所以是undefind</p>\n<pre><code class=\"JavaScript\">foo(); // 不是ReferenceError，而是TypeEerror\n\nvar foo = funcyion bar() &#123;\n    //...\n&#125;;\n</code></pre>\n<p>原因：函数表达式不会被提升</p>\n<blockquote>\n<p>函数优先</p>\n</blockquote>\n<p>函数声明和变量声明都会被提升，但是一个值得注意的细节是函数会被首先提升，然后才是变量。</p>\n<pre><code class=\"JavaScript\">foo(); //1\nvar foo;\nfunction foo() &#123;\n    console.log(1);\n&#125;\nfoo = function() &#123;\n    console.log(2);\n&#125;\n</code></pre>\n<p>输出的是1而不是2是因为函数声明先被提升到上面，然后在执行。var foo 尽管出现在function foo… 之前，但是他是重复声明会被忽略。</p>\n<blockquote>\n<p>后面的声明会覆盖掉前面的声明</p>\n</blockquote>\n<pre><code class=\"JavaScript\">foo(); //3\nfunction foo() &#123;\n    console.log(1);\n&#125;\nvar foo = function() &#123;\n    console.log(2);\n&#125;\nfunction foo() &#123;\n    console.log(3);\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"函数中的作用域\"><a href=\"#函数中的作用域\" class=\"headerlink\" title=\"函数中的作用域\"></a>函数中的作用域</h2><p>js有基于函数的作用域，每声明一个函数都会为其自身创建一个气泡，可以在附属气泡里获取外层的变量，但是不能从外层气泡中获取附属气泡种的变量</p>\n<h2 id=\"隐藏内部实现\"><a href=\"#隐藏内部实现\" class=\"headerlink\" title=\"隐藏内部实现\"></a>隐藏内部实现</h2><blockquote>\n<p>暴露在外面的写法，很不安全</p>\n</blockquote>\n<pre><code class=\"JavaScript\">function foo(a) &#123;\n    b = a + fff(a * 2);\n    console.log(b * 3);\n&#125;\nfunction fff(a) &#123;\n    return a - 1;\n&#125;\n\nvar b;\nfoo(2) // 15\n</code></pre>\n<blockquote>\n<p>隐藏的写法</p>\n</blockquote>\n<pre><code class=\"JavaScript\">function foo(a) &#123;\n    function fff(a) &#123;\n        return a - 1;\n    &#125;\n    var b;\n    b = a + fff(a * 2);\n    console.log(b * 3);\n&#125;\nfoo(2) // 15\n</code></pre>\n<blockquote>\n<p>规避冲突，<br>可以避免同名标识符之间的冲突，避免被覆盖</p>\n</blockquote>\n<p>方法：</p>\n<ol>\n<li>全局命名空间，在全局声明一个独特的变量，通常是一个对象，所有需要暴露给外界的功能都会成为这个对象的属性，而不是将自己的标识符暴露在顶级的词法作用域种。</li>\n<li>模块管理，从众多模块中挑选一个来使用，任何库都无需将标识符加入到全局作用域中。</li>\n</ol>\n<h2 id=\"函数作用域\"><a href=\"#函数作用域\" class=\"headerlink\" title=\"函数作用域\"></a>函数作用域</h2><p>在任意代码片段外部添加包装函数都可以将内部的变量和函数定义‘隐藏’起来，外部作用域无法访问包装函数内部的任何内容</p>\n<p>通过定义一个函数来达到是变量在函数作用域之内，虽然可以解决问题，但是并不理想，因为这个函数名称本身污染了所在的作用域，其次是必须通过显式的调用这个函数才能运行其中的代码。</p>\n<pre><code class=\"JavaScript\">var a = 2;\n(function foo()&#123;\n    var a = 3;\n    console.log( a ); // 3\n&#125;)();\nconsole.log( a ); // 2\n</code></pre>\n<p>这样函数会被当作函数表达式而不是一个标准的函数声明来处理。– 如果function是声明中的第一个第一个词，那么就是函数声明，否则就是函数表达式。</p>\n<p>函数表达式和函数声明最大的区别是它们的名称标识符将会绑定在何处。  foo只能在所代表的位置中被访问，外部不行。</p>\n<h2 id=\"匿名和具名\"><a href=\"#匿名和具名\" class=\"headerlink\" title=\"匿名和具名\"></a>匿名和具名</h2><blockquote>\n<p>匿名函数表达式</p>\n</blockquote>\n<pre><code class=\"JavaScript\">setTimeout( function()&#123;\n    console.log(&#39;aaa&#39;);\n&#125;,1000);\n</code></pre>\n<p>fun没有标识符，函数声明则是不可以省略函数名称</p>\n<ol>\n<li>匿名函数在栈追踪中不会显示出有意义的函数名称，使得调用很困难。</li>\n<li>如果没有函数名，需要引用的时候就只能使用已经过期的arguments.callee引用，比如在递归中</li>\n<li>匿名函数省略了对于代码的可读性/可理解性很重要的函数名</li>\n</ol>\n<p>行内函数表达式</p>\n<pre><code class=\"JavaScript\">setTimeout( function timeoutHandler()&#123;\n    console.log(&#39;aaa&#39;);\n&#125;,1000);\n</code></pre>\n<h2 id=\"立即执行函数表达式\"><a href=\"#立即执行函数表达式\" class=\"headerlink\" title=\"立即执行函数表达式\"></a>立即执行函数表达式</h2><pre><code class=\"JavaScript\">var a = 2;\n(function foo()&#123;\n    var a = 3;\n    console.log( a ); // 3\n&#125;)();\nconsole.log( a ); // 2\n</code></pre>\n<p>第一个（）将函数变成了表达式，第二个（）执行了这个函数</p>\n<blockquote>\n<p>IIFE代表立即执行函数表达式</p>\n</blockquote>\n<pre><code class=\"JavaScript\">var a = 2;\n(function IIFE()&#123; //传统的形式\n    var a = 3;\n    console.log( a ); // 3\n&#125;)();\nconsole.log( a ); // 2\n</code></pre>\n<p>==以上两种写法功能上是一样的==</p>\n<p>用途：</p>\n<p>可以传参数进去</p>\n<pre><code class=\"JavaScript\">var a = 2;\n(function IIFE(global)&#123; //传统的形式\n    var a = 3;\n    console.log( a ); // 3\n    console.log( global.a ); // 3\n&#125;)(window);\nconsole.log( a ); // 2\n</code></pre>\n<h2 id=\"块作用域\"><a href=\"#块作用域\" class=\"headerlink\" title=\"块作用域\"></a>块作用域</h2><p>除了函数能产生一个作用域气泡，for循环，if，with,try/catch等都会产生一个作用域气泡。</p>\n<p>块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块，通常指{..}的内部</p>\n<blockquote>\n<p>var</p>\n</blockquote>\n<p>其实val一个变量无论在什么地方，都会提升到全局变量，把它写在作用域内部，只是为了风格更易读而伪装出的形式上的块作用域，如果使用这种，要确保在其他地方没有重复的使用同名的变量。</p>\n<blockquote>\n<p>let</p>\n</blockquote>\n<p>ES6引入了关键字let，可以将变量绑定到所在的任意作用域中，为其声明的变量隐式的劫持了所在的块作用域。</p>\n<p>let进行声明的不会在代码在块作用域中进行提升，声明的代码在运行前，声明并不‘存在’。</p>\n<pre><code class=\"JavaScript\">&#123;\n    console.log(a); // ReferenceError(没有找到)\n    let a = 2;\n&#125;\n</code></pre>\n<p>let 声明附属于一个新的作用域而不是当前函数作用域（也不属于全局作用域）</p>\n<blockquote>\n<p>const</p>\n</blockquote>\n<p>同样可以用来创建块作用域变量，但其值是固定的，之后的任何试图修改值的操作都会引起错误。</p>\n<pre><code class=\"JavaScript\">var foo = true;\nif(foo)&#123;\n    var a = 2;\n    const b = 3;\n    a = 4; // 正确\n    b = 6; // 错误\n&#125;\nconsole.log(a) // 4\nconsole.log(b) // ReferenceError\n</code></pre>\n<p>任何声明在某个作用域内部的变量，都将附属于这个作用域</p>\n<h2 id=\"小思考\"><a href=\"#小思考\" class=\"headerlink\" title=\"小思考\"></a>小思考</h2><pre><code class=\"JavaScript\">a = 2;\nval a;\nconsole.log(a);//2\n</code></pre>\n<p>输出2的原因是：声明会提升，也就是先声明再赋值，在执行查询</p>\n<pre><code class=\"JavaScript\">console.log(a); // undefind\nvar a = 2;\n\n// 执行顺序\n\nval a;\nconsole.log(a); // undefind\na = 2;\n</code></pre>\n<p>原因：函数声明会提升，然后执行查询，此时是没有赋值的，所以是undefind</p>\n<pre><code class=\"JavaScript\">foo(); // 不是ReferenceError，而是TypeEerror\n\nvar foo = funcyion bar() &#123;\n    //...\n&#125;;\n</code></pre>\n<p>原因：函数表达式不会被提升</p>\n<blockquote>\n<p>函数优先</p>\n</blockquote>\n<p>函数声明和变量声明都会被提升，但是一个值得注意的细节是函数会被首先提升，然后才是变量。</p>\n<pre><code class=\"JavaScript\">foo(); //1\nvar foo;\nfunction foo() &#123;\n    console.log(1);\n&#125;\nfoo = function() &#123;\n    console.log(2);\n&#125;\n</code></pre>\n<p>输出的是1而不是2是因为函数声明先被提升到上面，然后在执行。var foo 尽管出现在function foo… 之前，但是他是重复声明会被忽略。</p>\n<blockquote>\n<p>后面的声明会覆盖掉前面的声明</p>\n</blockquote>\n<pre><code class=\"JavaScript\">foo(); //3\nfunction foo() &#123;\n    console.log(1);\n&#125;\nvar foo = function() &#123;\n    console.log(2);\n&#125;\nfunction foo() &#123;\n    console.log(3);\n&#125;\n</code></pre>\n"},{"title":"浅拷贝与深拷贝","_content":"\n> 浅拷贝与深拷贝 (深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的)\n\n**浅拷贝只复制指向某个对象的指针而不复制对象本身，新旧对象还是共享同一块内存。**\n**但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。**\n\n\n>赋值和浅拷贝的区别\n\n+ 当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。\n+ 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即：默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。\n  \n\n>浅拷贝的实现方式\n\n**.Object.assign()**\nObject.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。\n","source":"_posts/深拷贝与浅拷贝.md","raw":"---\ntitle: 浅拷贝与深拷贝\ntag: javsScript\n---\n\n> 浅拷贝与深拷贝 (深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的)\n\n**浅拷贝只复制指向某个对象的指针而不复制对象本身，新旧对象还是共享同一块内存。**\n**但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。**\n\n\n>赋值和浅拷贝的区别\n\n+ 当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。\n+ 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即：默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。\n  \n\n>浅拷贝的实现方式\n\n**.Object.assign()**\nObject.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。\n","slug":"深拷贝与浅拷贝","published":1,"date":"2021-07-19T02:20:15.846Z","updated":"2021-07-19T06:13:30.427Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckra8m0qx00081vanhyvq1kht","content":"<blockquote>\n<p>浅拷贝与深拷贝 (深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的)</p>\n</blockquote>\n<p><strong>浅拷贝只复制指向某个对象的指针而不复制对象本身，新旧对象还是共享同一块内存。</strong><br><strong>但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</strong></p>\n<blockquote>\n<p>赋值和浅拷贝的区别</p>\n</blockquote>\n<ul>\n<li>当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。</li>\n<li>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即：默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。</li>\n</ul>\n<blockquote>\n<p>浅拷贝的实现方式</p>\n</blockquote>\n<p><strong>.Object.assign()</strong><br>Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>浅拷贝与深拷贝 (深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的)</p>\n</blockquote>\n<p><strong>浅拷贝只复制指向某个对象的指针而不复制对象本身，新旧对象还是共享同一块内存。</strong><br><strong>但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</strong></p>\n<blockquote>\n<p>赋值和浅拷贝的区别</p>\n</blockquote>\n<ul>\n<li>当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。</li>\n<li>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即：默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。</li>\n</ul>\n<blockquote>\n<p>浅拷贝的实现方式</p>\n</blockquote>\n<p><strong>.Object.assign()</strong><br>Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。</p>\n"},{"title":"闭包","_content":"\n>闭包是基于词法作用域书写代码时所产生的自然结果\n\n闭包的产生：\n函数在被定义的地方之外被执行就会产生闭包！！！\n\n```JavaScript\nfunction foo() {\n    var a = 2;\n    function bar(){\n        console.log(a);\n    }\n    return bar;\n}\nvar bza = foo();\n\nbaz(); // 2  这就是闭包！\n```\n通常情况下foo执行之后整个内部作用域都会被销毁，因为引擎会销毁不再使用的空间来释放内存空间。\n\n然而闭包会阻止这一情况的发生，会让作用域依然存在，因为bar函数还在使用foo这个作用域，需要给bar在任何时候执行提供支持。所以foo的作用域不会被销毁，bar依然持有对该作用域的引用，这个引用就是闭包！\n\n==无论通过何种手段将内部函数传递到所在的词法作用域以外，他都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。==\n\n```JavaScript\nfunction wait(message){\n    setTimeout( function timer() {\n        console.log(message);\n    },1000)\n}\nwait('hello')\n```\nwait执行1000毫秒以后，他的内部作用域并不会消失，还能保持message的引用。\n\n==只要是使用了回调函数，实际上就是在使用闭包。==\n\n### 闭包和循环\n\n```JavaScript\nfor(var i = 1;i <= 5; i++;){\n    setTimeout(function timer() {\n        console.log(i);\n    },1*1000)\n}\n// 每秒一次输出五个6\n```\n这个循环终止的条件是6.条件首次成立的时候i === 6\n，因此输出的显示是循环结束时i的值。\n因为这里所用的i，是同一个作用域下的i，所有的函数共享一个i。\n\n```JavaScript\nfor(var i = 1;i <= 5; i++;){\n    (function() {\n        setTimeout(function timer() {\n            console.log(i);\n        },1*1000)\n    }();\n}\n//这样也不行\n```\n因为我们的IIFE的作用域是空的，我们使用的依然是外层的i，他要包含一点实质的内容才能够我们使用。\n\n\n```JavaScript\nfor(var i = 1;i <= 5; i++;){\n    (function(j) {\n        setTimeout(function timer() {\n            console.log(j);\n        },j*1000)\n    }(i);\n}\n// 这样就达到我们预期的目的，每秒一个，一次输出1-5\n```\n\n### 重返块作用域\n前面说let可以劫持块级作用域，，并且在这个块级作用域中声明一个变量。看下面代码\n\n```JavaScript\nfor(var i = 1; i <= 5; i++) {\n    let j = i;\n    setTimeout(function timer() {\n        console.log(j);\n    },j*1000)\n};\n```\n还可以更完善\n\n```JavaScript\nfor(let i = 1; i <= 5; i++) {\n    setTimeout(function timer() {\n        console.log(i);\n    },i*1000)\n};\n```\n\n### 模块\n```JavaScript\nfunction foo(){\n    var a = 'cool';\n    var b = [1,2,3];\n    function bar() {\n        console.log(a);\n    }\n    function baz() {\n        console.log(b);\n    }\n}\n```\n这里并没有明显的闭包，只有两个私有数据变量a和b，以及bar和baz两个内部函数，他们的词法作用域就是闭包，\n也就是foo（）的内部作用域。\n```JavaScript\nfunction CoolModule() {\n    var something = 'cool';\n    var another = [1,2,3];\n    function doSomething() {\n        console.log(something));\n    }\n    function doAnother() {\n        console.log(another.join(\"!\"));\n    }\n    return {\n        doSomething: doSomething,\n        doAnother: doAnother,\n    };\n}\nvar foo = CoolModule;\nfoo.doSomething(); // cool\nfoo.doAnother(); // 1!2!3\n```\n首先，CoolModule() 只是一个函数，必须通过调用它来创建一个模块实例，如果不执行外部函数，内部作用域和闭包都无法被创建。\n\n其次，CoolModule() 返回一个用对象字面量语法来表示的对象，这个返回的对象中含有内部函数，而不是内部数据变量的引用。我们保持内部数据变量是隐藏且私有状态。\n\n这个对象类型的返回值最终被赋值给外部变量foo，然后我们就可以通过它来访问API中的属性方法。 \n\n>模块模式必须具有两个条件\n1. 必须有外部的封闭函数，该函数必须至少被调用一次。（每次调用都会创建一个新的模块实例）\n2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。\n\n一个具有函数属性的对象本身并不是真正的模块。从方便观察角度来看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。\n\n改进上面的代码\n```JavaScript\nvar foo = (function CoolModule() {\n    var something = 'cool';\n    var another = [1,2,3];\n    function doSomething() {\n        console.log(something));\n    }\n    function doAnother() {\n        console.log(another.join(\"!\"));\n    }\n    return {\n        doSomething: doSomething,\n        doAnother: doAnother,\n    };\n})();\n\nfoo.doSomething(); // cool\nfoo.doAnother(); // 1!2!3\n```\n\n模块是普通函数，因此也可以传参。\n```JavaScript\nfunction CoolModule(id) {\n    function doSomething() {\n        console.log(id);\n    }\n    return {\n        doSomething: doSomething,\n    };\n}\nvar foo = CoolModule('foo');\nfoo.doSomething(); // foo\n```\n\n>模块另一个简单但又强大的用法是命名将要作为公共API返回的对象。\n```JavaScript\nvar foo = (function Cool(id){\n    function change() {\n        publicAPI.identify = identify2;\n    };\n    function identify1() {\n        console.log(id);\n    };\n    function identify2() {\n        console.log(id.toUppeCase());\n    };\n    var publicAPI = {\n        change: change,\n        identify: identify1\n    }\n    return publicAPI;\n})('foo module');\n\nfoo.identify(); // foo module\nfoo.change();\nfoo.identify(); // FOO MODULE\n```\n通过模块在实例的内部保留的公共API对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法，以及修改他们的值。\n\n现代的模块机制\n---\n创建一个模块\n```JavaScript\nvar MyModules = (function Manager(){\n    // 存储方法\n    var modules = {};\n    \n    // 添加方法\n    function define(name,deps,impl){\n        for(var i = 0;i < deps.length; i++) {\n            deps[i] = modules[deps[i]];\n        }\n        modules[name] = impl.apply(impl,deps);\n    }\n    \n    // 根据名字获取方法\n    function get(name) {\n        return modules[name];\n    }\n    \n    // 返回内部函数（方法）\n    return {\n        define: define,\n        get: get\n    }\n})()\n```\nFunction.apply(obj,args)方法能接收两个参数\n\nobj：这个对象将代替Function类里this对象\n\nargs：这个是数组，它将作为参数传给Function(args-->arguments)\n\n使用它来定义模块：\n```JavaScript\nMyModules.define(\"bar\",[], function() {\n    function hello(who) {\n        return \"let me introduce:\" + who;\n    }\n    retrun {\n        hello : hello\n    };\n});\n\nMyModules.define(\"foo\",['bar'], function(bar) {\n    var hungry = 'hippo';\n    function awesome(who) {\n        console.log(bar.hello(hungry).toUpperCase());\n    }\n    retrun {\n        awesome : awesome\n    };\n});\n\nvar bar = MyModules.get('bar');\nvar foo = MyModules.get('foo');\n\nconsole.log(bar.hello('hippo'));// let me introduce: hippo\n\nfoo.awesome(); // 大写的\n```\n\nfoo 和 bar 都是通过一个返回的公共的API的函数来定义的。foo 甚至接受 bar 的实例作为依赖参数，并且相应地使用它。\n","source":"_posts/闭包.md","raw":"---\ntitle: 闭包\ntag: javaScript\n---\n\n>闭包是基于词法作用域书写代码时所产生的自然结果\n\n闭包的产生：\n函数在被定义的地方之外被执行就会产生闭包！！！\n\n```JavaScript\nfunction foo() {\n    var a = 2;\n    function bar(){\n        console.log(a);\n    }\n    return bar;\n}\nvar bza = foo();\n\nbaz(); // 2  这就是闭包！\n```\n通常情况下foo执行之后整个内部作用域都会被销毁，因为引擎会销毁不再使用的空间来释放内存空间。\n\n然而闭包会阻止这一情况的发生，会让作用域依然存在，因为bar函数还在使用foo这个作用域，需要给bar在任何时候执行提供支持。所以foo的作用域不会被销毁，bar依然持有对该作用域的引用，这个引用就是闭包！\n\n==无论通过何种手段将内部函数传递到所在的词法作用域以外，他都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。==\n\n```JavaScript\nfunction wait(message){\n    setTimeout( function timer() {\n        console.log(message);\n    },1000)\n}\nwait('hello')\n```\nwait执行1000毫秒以后，他的内部作用域并不会消失，还能保持message的引用。\n\n==只要是使用了回调函数，实际上就是在使用闭包。==\n\n### 闭包和循环\n\n```JavaScript\nfor(var i = 1;i <= 5; i++;){\n    setTimeout(function timer() {\n        console.log(i);\n    },1*1000)\n}\n// 每秒一次输出五个6\n```\n这个循环终止的条件是6.条件首次成立的时候i === 6\n，因此输出的显示是循环结束时i的值。\n因为这里所用的i，是同一个作用域下的i，所有的函数共享一个i。\n\n```JavaScript\nfor(var i = 1;i <= 5; i++;){\n    (function() {\n        setTimeout(function timer() {\n            console.log(i);\n        },1*1000)\n    }();\n}\n//这样也不行\n```\n因为我们的IIFE的作用域是空的，我们使用的依然是外层的i，他要包含一点实质的内容才能够我们使用。\n\n\n```JavaScript\nfor(var i = 1;i <= 5; i++;){\n    (function(j) {\n        setTimeout(function timer() {\n            console.log(j);\n        },j*1000)\n    }(i);\n}\n// 这样就达到我们预期的目的，每秒一个，一次输出1-5\n```\n\n### 重返块作用域\n前面说let可以劫持块级作用域，，并且在这个块级作用域中声明一个变量。看下面代码\n\n```JavaScript\nfor(var i = 1; i <= 5; i++) {\n    let j = i;\n    setTimeout(function timer() {\n        console.log(j);\n    },j*1000)\n};\n```\n还可以更完善\n\n```JavaScript\nfor(let i = 1; i <= 5; i++) {\n    setTimeout(function timer() {\n        console.log(i);\n    },i*1000)\n};\n```\n\n### 模块\n```JavaScript\nfunction foo(){\n    var a = 'cool';\n    var b = [1,2,3];\n    function bar() {\n        console.log(a);\n    }\n    function baz() {\n        console.log(b);\n    }\n}\n```\n这里并没有明显的闭包，只有两个私有数据变量a和b，以及bar和baz两个内部函数，他们的词法作用域就是闭包，\n也就是foo（）的内部作用域。\n```JavaScript\nfunction CoolModule() {\n    var something = 'cool';\n    var another = [1,2,3];\n    function doSomething() {\n        console.log(something));\n    }\n    function doAnother() {\n        console.log(another.join(\"!\"));\n    }\n    return {\n        doSomething: doSomething,\n        doAnother: doAnother,\n    };\n}\nvar foo = CoolModule;\nfoo.doSomething(); // cool\nfoo.doAnother(); // 1!2!3\n```\n首先，CoolModule() 只是一个函数，必须通过调用它来创建一个模块实例，如果不执行外部函数，内部作用域和闭包都无法被创建。\n\n其次，CoolModule() 返回一个用对象字面量语法来表示的对象，这个返回的对象中含有内部函数，而不是内部数据变量的引用。我们保持内部数据变量是隐藏且私有状态。\n\n这个对象类型的返回值最终被赋值给外部变量foo，然后我们就可以通过它来访问API中的属性方法。 \n\n>模块模式必须具有两个条件\n1. 必须有外部的封闭函数，该函数必须至少被调用一次。（每次调用都会创建一个新的模块实例）\n2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。\n\n一个具有函数属性的对象本身并不是真正的模块。从方便观察角度来看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。\n\n改进上面的代码\n```JavaScript\nvar foo = (function CoolModule() {\n    var something = 'cool';\n    var another = [1,2,3];\n    function doSomething() {\n        console.log(something));\n    }\n    function doAnother() {\n        console.log(another.join(\"!\"));\n    }\n    return {\n        doSomething: doSomething,\n        doAnother: doAnother,\n    };\n})();\n\nfoo.doSomething(); // cool\nfoo.doAnother(); // 1!2!3\n```\n\n模块是普通函数，因此也可以传参。\n```JavaScript\nfunction CoolModule(id) {\n    function doSomething() {\n        console.log(id);\n    }\n    return {\n        doSomething: doSomething,\n    };\n}\nvar foo = CoolModule('foo');\nfoo.doSomething(); // foo\n```\n\n>模块另一个简单但又强大的用法是命名将要作为公共API返回的对象。\n```JavaScript\nvar foo = (function Cool(id){\n    function change() {\n        publicAPI.identify = identify2;\n    };\n    function identify1() {\n        console.log(id);\n    };\n    function identify2() {\n        console.log(id.toUppeCase());\n    };\n    var publicAPI = {\n        change: change,\n        identify: identify1\n    }\n    return publicAPI;\n})('foo module');\n\nfoo.identify(); // foo module\nfoo.change();\nfoo.identify(); // FOO MODULE\n```\n通过模块在实例的内部保留的公共API对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法，以及修改他们的值。\n\n现代的模块机制\n---\n创建一个模块\n```JavaScript\nvar MyModules = (function Manager(){\n    // 存储方法\n    var modules = {};\n    \n    // 添加方法\n    function define(name,deps,impl){\n        for(var i = 0;i < deps.length; i++) {\n            deps[i] = modules[deps[i]];\n        }\n        modules[name] = impl.apply(impl,deps);\n    }\n    \n    // 根据名字获取方法\n    function get(name) {\n        return modules[name];\n    }\n    \n    // 返回内部函数（方法）\n    return {\n        define: define,\n        get: get\n    }\n})()\n```\nFunction.apply(obj,args)方法能接收两个参数\n\nobj：这个对象将代替Function类里this对象\n\nargs：这个是数组，它将作为参数传给Function(args-->arguments)\n\n使用它来定义模块：\n```JavaScript\nMyModules.define(\"bar\",[], function() {\n    function hello(who) {\n        return \"let me introduce:\" + who;\n    }\n    retrun {\n        hello : hello\n    };\n});\n\nMyModules.define(\"foo\",['bar'], function(bar) {\n    var hungry = 'hippo';\n    function awesome(who) {\n        console.log(bar.hello(hungry).toUpperCase());\n    }\n    retrun {\n        awesome : awesome\n    };\n});\n\nvar bar = MyModules.get('bar');\nvar foo = MyModules.get('foo');\n\nconsole.log(bar.hello('hippo'));// let me introduce: hippo\n\nfoo.awesome(); // 大写的\n```\n\nfoo 和 bar 都是通过一个返回的公共的API的函数来定义的。foo 甚至接受 bar 的实例作为依赖参数，并且相应地使用它。\n","slug":"闭包","published":1,"date":"2021-07-17T05:51:17.777Z","updated":"2021-07-17T05:51:17.777Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckra8m0r8000g1vanhrdbgklm","content":"<blockquote>\n<p>闭包是基于词法作用域书写代码时所产生的自然结果</p>\n</blockquote>\n<p>闭包的产生：<br>函数在被定义的地方之外被执行就会产生闭包！！！</p>\n<pre><code class=\"JavaScript\">function foo() &#123;\n    var a = 2;\n    function bar()&#123;\n        console.log(a);\n    &#125;\n    return bar;\n&#125;\nvar bza = foo();\n\nbaz(); // 2  这就是闭包！\n</code></pre>\n<p>通常情况下foo执行之后整个内部作用域都会被销毁，因为引擎会销毁不再使用的空间来释放内存空间。</p>\n<p>然而闭包会阻止这一情况的发生，会让作用域依然存在，因为bar函数还在使用foo这个作用域，需要给bar在任何时候执行提供支持。所以foo的作用域不会被销毁，bar依然持有对该作用域的引用，这个引用就是闭包！</p>\n<p>==无论通过何种手段将内部函数传递到所在的词法作用域以外，他都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。==</p>\n<pre><code class=\"JavaScript\">function wait(message)&#123;\n    setTimeout( function timer() &#123;\n        console.log(message);\n    &#125;,1000)\n&#125;\nwait(&#39;hello&#39;)\n</code></pre>\n<p>wait执行1000毫秒以后，他的内部作用域并不会消失，还能保持message的引用。</p>\n<p>==只要是使用了回调函数，实际上就是在使用闭包。==</p>\n<h3 id=\"闭包和循环\"><a href=\"#闭包和循环\" class=\"headerlink\" title=\"闭包和循环\"></a>闭包和循环</h3><pre><code class=\"JavaScript\">for(var i = 1;i &lt;= 5; i++;)&#123;\n    setTimeout(function timer() &#123;\n        console.log(i);\n    &#125;,1*1000)\n&#125;\n// 每秒一次输出五个6\n</code></pre>\n<p>这个循环终止的条件是6.条件首次成立的时候i === 6<br>，因此输出的显示是循环结束时i的值。<br>因为这里所用的i，是同一个作用域下的i，所有的函数共享一个i。</p>\n<pre><code class=\"JavaScript\">for(var i = 1;i &lt;= 5; i++;)&#123;\n    (function() &#123;\n        setTimeout(function timer() &#123;\n            console.log(i);\n        &#125;,1*1000)\n    &#125;();\n&#125;\n//这样也不行\n</code></pre>\n<p>因为我们的IIFE的作用域是空的，我们使用的依然是外层的i，他要包含一点实质的内容才能够我们使用。</p>\n<pre><code class=\"JavaScript\">for(var i = 1;i &lt;= 5; i++;)&#123;\n    (function(j) &#123;\n        setTimeout(function timer() &#123;\n            console.log(j);\n        &#125;,j*1000)\n    &#125;(i);\n&#125;\n// 这样就达到我们预期的目的，每秒一个，一次输出1-5\n</code></pre>\n<h3 id=\"重返块作用域\"><a href=\"#重返块作用域\" class=\"headerlink\" title=\"重返块作用域\"></a>重返块作用域</h3><p>前面说let可以劫持块级作用域，，并且在这个块级作用域中声明一个变量。看下面代码</p>\n<pre><code class=\"JavaScript\">for(var i = 1; i &lt;= 5; i++) &#123;\n    let j = i;\n    setTimeout(function timer() &#123;\n        console.log(j);\n    &#125;,j*1000)\n&#125;;\n</code></pre>\n<p>还可以更完善</p>\n<pre><code class=\"JavaScript\">for(let i = 1; i &lt;= 5; i++) &#123;\n    setTimeout(function timer() &#123;\n        console.log(i);\n    &#125;,i*1000)\n&#125;;\n</code></pre>\n<h3 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h3><pre><code class=\"JavaScript\">function foo()&#123;\n    var a = &#39;cool&#39;;\n    var b = [1,2,3];\n    function bar() &#123;\n        console.log(a);\n    &#125;\n    function baz() &#123;\n        console.log(b);\n    &#125;\n&#125;\n</code></pre>\n<p>这里并没有明显的闭包，只有两个私有数据变量a和b，以及bar和baz两个内部函数，他们的词法作用域就是闭包，<br>也就是foo（）的内部作用域。</p>\n<pre><code class=\"JavaScript\">function CoolModule() &#123;\n    var something = &#39;cool&#39;;\n    var another = [1,2,3];\n    function doSomething() &#123;\n        console.log(something));\n    &#125;\n    function doAnother() &#123;\n        console.log(another.join(&quot;!&quot;));\n    &#125;\n    return &#123;\n        doSomething: doSomething,\n        doAnother: doAnother,\n    &#125;;\n&#125;\nvar foo = CoolModule;\nfoo.doSomething(); // cool\nfoo.doAnother(); // 1!2!3\n</code></pre>\n<p>首先，CoolModule() 只是一个函数，必须通过调用它来创建一个模块实例，如果不执行外部函数，内部作用域和闭包都无法被创建。</p>\n<p>其次，CoolModule() 返回一个用对象字面量语法来表示的对象，这个返回的对象中含有内部函数，而不是内部数据变量的引用。我们保持内部数据变量是隐藏且私有状态。</p>\n<p>这个对象类型的返回值最终被赋值给外部变量foo，然后我们就可以通过它来访问API中的属性方法。 </p>\n<blockquote>\n<p>模块模式必须具有两个条件</p>\n</blockquote>\n<ol>\n<li>必须有外部的封闭函数，该函数必须至少被调用一次。（每次调用都会创建一个新的模块实例）</li>\n<li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li>\n</ol>\n<p>一个具有函数属性的对象本身并不是真正的模块。从方便观察角度来看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。</p>\n<p>改进上面的代码</p>\n<pre><code class=\"JavaScript\">var foo = (function CoolModule() &#123;\n    var something = &#39;cool&#39;;\n    var another = [1,2,3];\n    function doSomething() &#123;\n        console.log(something));\n    &#125;\n    function doAnother() &#123;\n        console.log(another.join(&quot;!&quot;));\n    &#125;\n    return &#123;\n        doSomething: doSomething,\n        doAnother: doAnother,\n    &#125;;\n&#125;)();\n\nfoo.doSomething(); // cool\nfoo.doAnother(); // 1!2!3\n</code></pre>\n<p>模块是普通函数，因此也可以传参。</p>\n<pre><code class=\"JavaScript\">function CoolModule(id) &#123;\n    function doSomething() &#123;\n        console.log(id);\n    &#125;\n    return &#123;\n        doSomething: doSomething,\n    &#125;;\n&#125;\nvar foo = CoolModule(&#39;foo&#39;);\nfoo.doSomething(); // foo\n</code></pre>\n<blockquote>\n<p>模块另一个简单但又强大的用法是命名将要作为公共API返回的对象。</p>\n</blockquote>\n<pre><code class=\"JavaScript\">var foo = (function Cool(id)&#123;\n    function change() &#123;\n        publicAPI.identify = identify2;\n    &#125;;\n    function identify1() &#123;\n        console.log(id);\n    &#125;;\n    function identify2() &#123;\n        console.log(id.toUppeCase());\n    &#125;;\n    var publicAPI = &#123;\n        change: change,\n        identify: identify1\n    &#125;\n    return publicAPI;\n&#125;)(&#39;foo module&#39;);\n\nfoo.identify(); // foo module\nfoo.change();\nfoo.identify(); // FOO MODULE\n</code></pre>\n<p>通过模块在实例的内部保留的公共API对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法，以及修改他们的值。</p>\n<h2 id=\"现代的模块机制\"><a href=\"#现代的模块机制\" class=\"headerlink\" title=\"现代的模块机制\"></a>现代的模块机制</h2><p>创建一个模块</p>\n<pre><code class=\"JavaScript\">var MyModules = (function Manager()&#123;\n    // 存储方法\n    var modules = &#123;&#125;;\n    \n    // 添加方法\n    function define(name,deps,impl)&#123;\n        for(var i = 0;i &lt; deps.length; i++) &#123;\n            deps[i] = modules[deps[i]];\n        &#125;\n        modules[name] = impl.apply(impl,deps);\n    &#125;\n    \n    // 根据名字获取方法\n    function get(name) &#123;\n        return modules[name];\n    &#125;\n    \n    // 返回内部函数（方法）\n    return &#123;\n        define: define,\n        get: get\n    &#125;\n&#125;)()\n</code></pre>\n<p>Function.apply(obj,args)方法能接收两个参数</p>\n<p>obj：这个对象将代替Function类里this对象</p>\n<p>args：这个是数组，它将作为参数传给Function(args–&gt;arguments)</p>\n<p>使用它来定义模块：</p>\n<pre><code class=\"JavaScript\">MyModules.define(&quot;bar&quot;,[], function() &#123;\n    function hello(who) &#123;\n        return &quot;let me introduce:&quot; + who;\n    &#125;\n    retrun &#123;\n        hello : hello\n    &#125;;\n&#125;);\n\nMyModules.define(&quot;foo&quot;,[&#39;bar&#39;], function(bar) &#123;\n    var hungry = &#39;hippo&#39;;\n    function awesome(who) &#123;\n        console.log(bar.hello(hungry).toUpperCase());\n    &#125;\n    retrun &#123;\n        awesome : awesome\n    &#125;;\n&#125;);\n\nvar bar = MyModules.get(&#39;bar&#39;);\nvar foo = MyModules.get(&#39;foo&#39;);\n\nconsole.log(bar.hello(&#39;hippo&#39;));// let me introduce: hippo\n\nfoo.awesome(); // 大写的\n</code></pre>\n<p>foo 和 bar 都是通过一个返回的公共的API的函数来定义的。foo 甚至接受 bar 的实例作为依赖参数，并且相应地使用它。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>闭包是基于词法作用域书写代码时所产生的自然结果</p>\n</blockquote>\n<p>闭包的产生：<br>函数在被定义的地方之外被执行就会产生闭包！！！</p>\n<pre><code class=\"JavaScript\">function foo() &#123;\n    var a = 2;\n    function bar()&#123;\n        console.log(a);\n    &#125;\n    return bar;\n&#125;\nvar bza = foo();\n\nbaz(); // 2  这就是闭包！\n</code></pre>\n<p>通常情况下foo执行之后整个内部作用域都会被销毁，因为引擎会销毁不再使用的空间来释放内存空间。</p>\n<p>然而闭包会阻止这一情况的发生，会让作用域依然存在，因为bar函数还在使用foo这个作用域，需要给bar在任何时候执行提供支持。所以foo的作用域不会被销毁，bar依然持有对该作用域的引用，这个引用就是闭包！</p>\n<p>==无论通过何种手段将内部函数传递到所在的词法作用域以外，他都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。==</p>\n<pre><code class=\"JavaScript\">function wait(message)&#123;\n    setTimeout( function timer() &#123;\n        console.log(message);\n    &#125;,1000)\n&#125;\nwait(&#39;hello&#39;)\n</code></pre>\n<p>wait执行1000毫秒以后，他的内部作用域并不会消失，还能保持message的引用。</p>\n<p>==只要是使用了回调函数，实际上就是在使用闭包。==</p>\n<h3 id=\"闭包和循环\"><a href=\"#闭包和循环\" class=\"headerlink\" title=\"闭包和循环\"></a>闭包和循环</h3><pre><code class=\"JavaScript\">for(var i = 1;i &lt;= 5; i++;)&#123;\n    setTimeout(function timer() &#123;\n        console.log(i);\n    &#125;,1*1000)\n&#125;\n// 每秒一次输出五个6\n</code></pre>\n<p>这个循环终止的条件是6.条件首次成立的时候i === 6<br>，因此输出的显示是循环结束时i的值。<br>因为这里所用的i，是同一个作用域下的i，所有的函数共享一个i。</p>\n<pre><code class=\"JavaScript\">for(var i = 1;i &lt;= 5; i++;)&#123;\n    (function() &#123;\n        setTimeout(function timer() &#123;\n            console.log(i);\n        &#125;,1*1000)\n    &#125;();\n&#125;\n//这样也不行\n</code></pre>\n<p>因为我们的IIFE的作用域是空的，我们使用的依然是外层的i，他要包含一点实质的内容才能够我们使用。</p>\n<pre><code class=\"JavaScript\">for(var i = 1;i &lt;= 5; i++;)&#123;\n    (function(j) &#123;\n        setTimeout(function timer() &#123;\n            console.log(j);\n        &#125;,j*1000)\n    &#125;(i);\n&#125;\n// 这样就达到我们预期的目的，每秒一个，一次输出1-5\n</code></pre>\n<h3 id=\"重返块作用域\"><a href=\"#重返块作用域\" class=\"headerlink\" title=\"重返块作用域\"></a>重返块作用域</h3><p>前面说let可以劫持块级作用域，，并且在这个块级作用域中声明一个变量。看下面代码</p>\n<pre><code class=\"JavaScript\">for(var i = 1; i &lt;= 5; i++) &#123;\n    let j = i;\n    setTimeout(function timer() &#123;\n        console.log(j);\n    &#125;,j*1000)\n&#125;;\n</code></pre>\n<p>还可以更完善</p>\n<pre><code class=\"JavaScript\">for(let i = 1; i &lt;= 5; i++) &#123;\n    setTimeout(function timer() &#123;\n        console.log(i);\n    &#125;,i*1000)\n&#125;;\n</code></pre>\n<h3 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h3><pre><code class=\"JavaScript\">function foo()&#123;\n    var a = &#39;cool&#39;;\n    var b = [1,2,3];\n    function bar() &#123;\n        console.log(a);\n    &#125;\n    function baz() &#123;\n        console.log(b);\n    &#125;\n&#125;\n</code></pre>\n<p>这里并没有明显的闭包，只有两个私有数据变量a和b，以及bar和baz两个内部函数，他们的词法作用域就是闭包，<br>也就是foo（）的内部作用域。</p>\n<pre><code class=\"JavaScript\">function CoolModule() &#123;\n    var something = &#39;cool&#39;;\n    var another = [1,2,3];\n    function doSomething() &#123;\n        console.log(something));\n    &#125;\n    function doAnother() &#123;\n        console.log(another.join(&quot;!&quot;));\n    &#125;\n    return &#123;\n        doSomething: doSomething,\n        doAnother: doAnother,\n    &#125;;\n&#125;\nvar foo = CoolModule;\nfoo.doSomething(); // cool\nfoo.doAnother(); // 1!2!3\n</code></pre>\n<p>首先，CoolModule() 只是一个函数，必须通过调用它来创建一个模块实例，如果不执行外部函数，内部作用域和闭包都无法被创建。</p>\n<p>其次，CoolModule() 返回一个用对象字面量语法来表示的对象，这个返回的对象中含有内部函数，而不是内部数据变量的引用。我们保持内部数据变量是隐藏且私有状态。</p>\n<p>这个对象类型的返回值最终被赋值给外部变量foo，然后我们就可以通过它来访问API中的属性方法。 </p>\n<blockquote>\n<p>模块模式必须具有两个条件</p>\n</blockquote>\n<ol>\n<li>必须有外部的封闭函数，该函数必须至少被调用一次。（每次调用都会创建一个新的模块实例）</li>\n<li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li>\n</ol>\n<p>一个具有函数属性的对象本身并不是真正的模块。从方便观察角度来看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。</p>\n<p>改进上面的代码</p>\n<pre><code class=\"JavaScript\">var foo = (function CoolModule() &#123;\n    var something = &#39;cool&#39;;\n    var another = [1,2,3];\n    function doSomething() &#123;\n        console.log(something));\n    &#125;\n    function doAnother() &#123;\n        console.log(another.join(&quot;!&quot;));\n    &#125;\n    return &#123;\n        doSomething: doSomething,\n        doAnother: doAnother,\n    &#125;;\n&#125;)();\n\nfoo.doSomething(); // cool\nfoo.doAnother(); // 1!2!3\n</code></pre>\n<p>模块是普通函数，因此也可以传参。</p>\n<pre><code class=\"JavaScript\">function CoolModule(id) &#123;\n    function doSomething() &#123;\n        console.log(id);\n    &#125;\n    return &#123;\n        doSomething: doSomething,\n    &#125;;\n&#125;\nvar foo = CoolModule(&#39;foo&#39;);\nfoo.doSomething(); // foo\n</code></pre>\n<blockquote>\n<p>模块另一个简单但又强大的用法是命名将要作为公共API返回的对象。</p>\n</blockquote>\n<pre><code class=\"JavaScript\">var foo = (function Cool(id)&#123;\n    function change() &#123;\n        publicAPI.identify = identify2;\n    &#125;;\n    function identify1() &#123;\n        console.log(id);\n    &#125;;\n    function identify2() &#123;\n        console.log(id.toUppeCase());\n    &#125;;\n    var publicAPI = &#123;\n        change: change,\n        identify: identify1\n    &#125;\n    return publicAPI;\n&#125;)(&#39;foo module&#39;);\n\nfoo.identify(); // foo module\nfoo.change();\nfoo.identify(); // FOO MODULE\n</code></pre>\n<p>通过模块在实例的内部保留的公共API对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法，以及修改他们的值。</p>\n<h2 id=\"现代的模块机制\"><a href=\"#现代的模块机制\" class=\"headerlink\" title=\"现代的模块机制\"></a>现代的模块机制</h2><p>创建一个模块</p>\n<pre><code class=\"JavaScript\">var MyModules = (function Manager()&#123;\n    // 存储方法\n    var modules = &#123;&#125;;\n    \n    // 添加方法\n    function define(name,deps,impl)&#123;\n        for(var i = 0;i &lt; deps.length; i++) &#123;\n            deps[i] = modules[deps[i]];\n        &#125;\n        modules[name] = impl.apply(impl,deps);\n    &#125;\n    \n    // 根据名字获取方法\n    function get(name) &#123;\n        return modules[name];\n    &#125;\n    \n    // 返回内部函数（方法）\n    return &#123;\n        define: define,\n        get: get\n    &#125;\n&#125;)()\n</code></pre>\n<p>Function.apply(obj,args)方法能接收两个参数</p>\n<p>obj：这个对象将代替Function类里this对象</p>\n<p>args：这个是数组，它将作为参数传给Function(args–&gt;arguments)</p>\n<p>使用它来定义模块：</p>\n<pre><code class=\"JavaScript\">MyModules.define(&quot;bar&quot;,[], function() &#123;\n    function hello(who) &#123;\n        return &quot;let me introduce:&quot; + who;\n    &#125;\n    retrun &#123;\n        hello : hello\n    &#125;;\n&#125;);\n\nMyModules.define(&quot;foo&quot;,[&#39;bar&#39;], function(bar) &#123;\n    var hungry = &#39;hippo&#39;;\n    function awesome(who) &#123;\n        console.log(bar.hello(hungry).toUpperCase());\n    &#125;\n    retrun &#123;\n        awesome : awesome\n    &#125;;\n&#125;);\n\nvar bar = MyModules.get(&#39;bar&#39;);\nvar foo = MyModules.get(&#39;foo&#39;);\n\nconsole.log(bar.hello(&#39;hippo&#39;));// let me introduce: hippo\n\nfoo.awesome(); // 大写的\n</code></pre>\n<p>foo 和 bar 都是通过一个返回的公共的API的函数来定义的。foo 甚至接受 bar 的实例作为依赖参数，并且相应地使用它。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckra8m0qv00041vanay4ifg1s","tag_id":"ckra8m0qt00021vanf0byfi96","_id":"ckra8m0qx00071van970z9h0f"},{"post_id":"ckra8m0qh00001vanf7p48o7m","tag_id":"ckra8m0qt00021vanf0byfi96","_id":"ckra8m0qy00091van8y0lfh5g"},{"post_id":"ckra8m0qw00051van7ij3cjvj","tag_id":"ckra8m0qt00021vanf0byfi96","_id":"ckra8m0qz000b1vanaxbt3c8r"},{"post_id":"ckra8m0qr00011van6o2m2k9r","tag_id":"ckra8m0qw00061vand96adfxz","_id":"ckra8m0qz000c1van9db557ch"},{"post_id":"ckra8m0qu00031vanayuq8350","tag_id":"ckra8m0qt00021vanf0byfi96","_id":"ckra8m0r0000e1vanhuo6fwgi"},{"post_id":"ckra8m0qx00081vanhyvq1kht","tag_id":"ckra8m0r0000d1van9ict52hm","_id":"ckra8m0r0000f1vanaxxyg40p"},{"post_id":"ckra8m0r8000g1vanhrdbgklm","tag_id":"ckra8m0qt00021vanf0byfi96","_id":"ckra8m0r9000h1van3sd12ggg"}],"Tag":[{"name":"javaScript","_id":"ckra8m0qt00021vanf0byfi96"},{"name":"markdown","_id":"ckra8m0qw00061vand96adfxz"},{"name":"javsScript","_id":"ckra8m0r0000d1van9ict52hm"}]}}