<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue模板编译</title>
      <link href="/2021/07/23/vue-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/"/>
      <url>/2021/07/23/vue-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h1 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h1><p>把用户在<template></template>标签中写的类似于原生HTML的内容进行编译，把原生HTML的内容找出来，再把非原生HTML找出来，经过一系列的逻辑处理生成渲染函数，也就是render函数的这一段过程称之为模板编译过程</p><h1 id="整体渲染流程"><a href="#整体渲染流程" class="headerlink" title="整体渲染流程"></a>整体渲染流程</h1><p><img src="/imgs/vue3.png" alt="Image text"></p><h1 id="模板编译内部流程"><a href="#模板编译内部流程" class="headerlink" title="模板编译内部流程"></a>模板编译内部流程</h1><h2 id="抽象语法树AST"><a href="#抽象语法树AST" class="headerlink" title="抽象语法树AST"></a>抽象语法树AST</h2><p>抽象语法树，在计算机科学中，抽象语法树（AbstractSyntaxTree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现；而类似于if-condition-then这样的条件跳转语句，可以使用带有两个分支的节点来表示</p><h2 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h2><ul><li>模板解析阶段：将一堆模板字符串用正则等方式解析成抽象语法树AST；</li><li>优化阶段：遍历AST，找出其中的静态节点，并打上标记；</li><li>代码生成阶段：将AST转换成渲染函数；</li></ul><pre class="line-numbers language-javaScript" data-language="javaScript"><code class="language-javaScript">export const createCompiler &#x3D; createCompilerCreator(function baseCompile (  template: string,  options: CompilerOptions): CompiledResult &#123;  &#x2F;&#x2F; 模板解析阶段：用正则等方式解析 template 模板中的指令、class、style等数据，形成AST  const ast &#x3D; parse(template.trim(), options)  if (options.optimize !&#x3D;&#x3D; false) &#123;    &#x2F;&#x2F; 优化阶段：遍历AST，找出其中的静态节点，并打上标记；    optimize(ast, options)  &#125;  &#x2F;&#x2F; 代码生成阶段：将AST转换成渲染函数；  const code &#x3D; generate(ast, options)  return &#123;    ast,    render: code.render,    staticRenderFns: code.staticRenderFns  &#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/imgs/vue4.png" alt="image text"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>大致分为三个阶段，分别是模板解析阶段、优化阶段和代码生成阶段</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue.2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>diff算法</title>
      <link href="/2021/07/23/vue-diff%E7%AE%97%E6%B3%95/"/>
      <url>/2021/07/23/vue-diff%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ul><li>创建节点</li><li>删除节点</li><li>更新节点</li></ul><h1 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h1><p>在Vue中，把 DOM-Diff过程叫做patch过程。patch,意为“补丁”，即指对旧的VNode修补，打补丁从而得到新的VNode，非常形象哈。那不管叫什么，其本质都是把对比新旧两份VNode的过程。我们在下面研究patch过程的时候，一定把握住这样一个思想：所谓旧的VNode(即oldVNode)就是数据变化之前视图所对应的虚拟DOM节点，而新的VNode是数据变化之后将要渲染的新的视图所对应的虚拟DOM节点，所以我们要以生成的新的VNode为基准，对比旧的oldVNode，如果新的VNode上有的节点而旧的oldVNode上没有，那么就在旧的oldVNode上加上去；如果新的VNode上没有的节点而旧的oldVNode上有，那么就在旧的oldVNode上去掉；如果某些节点在新的VNode和旧的oldVNode上都有，那么就以新的VNode为准，更新旧的oldVNode，从而让新旧VNode相同。<br><strong>总体来说就是以新的标准，多的加上去，少的删掉，将老的改成新的</strong></p><h2 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h2><ul><li>判断是否为元素节点只需判断该VNode节点是否有tag标签即可。如果有tag属性即认为是元素节点，则调用createElement方法创建元素节点，通常元素节点还会有子节点，那就递归遍历创建所有子节点，将所有子节点创建好之后insert插入到当前元素节点里面，最后把当前元素节点插入到DOM中。</li><li>判断是否为注释节点，只需判断VNode的isComment属性是否为true即可，若为true则为注释节点，则调用createComment方法创建注释节点，再插入到DOM中。</li><li>如果既不是元素节点，也不是注释节点，那就认为是文本节点，则调用createTextNode方法创建文本节点，再插入到DOM中。<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 源码位置: &#x2F;src&#x2F;core&#x2F;vdom&#x2F;patch.jsfunction createElm (vnode, parentElm, refElm) &#123;    const data &#x3D; vnode.data    const children &#x3D; vnode.children    const tag &#x3D; vnode.tag    if (isDef(tag)) &#123;      vnode.elm &#x3D; nodeOps.createElement(tag, vnode)   &#x2F;&#x2F; 创建元素节点        createChildren(vnode, children, insertedVnodeQueue) &#x2F;&#x2F; 创建元素节点的子节点        insert(parentElm, vnode.elm, refElm)       &#x2F;&#x2F; 插入到DOM中    &#125; else if (isTrue(vnode.isComment)) &#123;      vnode.elm &#x3D; nodeOps.createComment(vnode.text)  &#x2F;&#x2F; 创建注释节点      insert(parentElm, vnode.elm, refElm)           &#x2F;&#x2F; 插入到DOM中    &#125; else &#123;      vnode.elm &#x3D; nodeOps.createTextNode(vnode.text)  &#x2F;&#x2F; 创建文本节点      insert(parentElm, vnode.elm, refElm)           &#x2F;&#x2F; 插入到DOM中    &#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><p>如果某些节点再新的VNode中没有而在旧的oldVNode中有，那么就需要把这些节点从旧的oldVNode中删除。删除节点非常简单，只需在要删除节点的父元素上调用removeChild方法即可。源码如下：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function removeNode (el) &#123;    const parent &#x3D; nodeOps.parentNode(el)  &#x2F;&#x2F; 获取父节点    if (isDef(parent)) &#123;      nodeOps.removeChild(parent, el)  &#x2F;&#x2F; 调用父节点的removeChild方法    &#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="更新节点"><a href="#更新节点" class="headerlink" title="更新节点"></a>更新节点</h2><p>更新节点就是当某些节点在新的VNode和旧的oldVNode中都有时，我们就需要细致比较一下，找出不一样的地方进行更新。</p><ul><li><p>如果VNode和oldVNode均为静态节点,我们说了，静态节点无论数据发生任何变化都与它无关，所以都为静态节点的话则直接跳过，无需处理。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&lt;p&gt;我是不会变化的文字&lt;&#x2F;p&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>如果VNode是文本节点<br>如果VNode是文本节点即表示这个节点内只包含纯文本，那么只需看oldVNode是否也是文本节点，如果是，那就比较两个文本是否不同，如果不同则把oldVNode里的文本改成跟VNode的文本一样。如果oldVNode不是文本节点，那么不论它是什么，直接调用setTextNode方法把它改成文本节点，并且文本内容跟VNode相同。</p></li><li><p>如果VNode是元素节点<br>如果VNode是元素节点，则又细分以下两种情况</p><ul><li>该节点包含子节点<br>如果新的节点内包含了子节点，那么此时要看旧的节点是否包含子节点，如果旧的节点里也包含了子节点，那就需要递归对比更新子节点；如果旧的节点里不包含子节点，那么这个旧节点有可能是空节点或者是文本节点，如果旧的节点是空节点就把新的节点里的子节点创建一份然后插入到旧的节点里面，如果旧的节点是文本节点，则把文本清空，然后把新的节点里的子节点创建一份然后插入到旧的节点里面。</li><li>该节点不包含子节点<br>如果该节点不包含子节点，同时它又不是文本节点，那就说明该节点是个空节点，那就好办了，不管旧节点之前里面都有啥，直接清空即可。<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 更新节点function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) &#123;  &#x2F;&#x2F; vnode与oldVnode是否完全一样？若是，退出程序  if (oldVnode &#x3D;&#x3D;&#x3D; vnode) &#123;    return  &#125;  const elm &#x3D; vnode.elm &#x3D; oldVnode.elm  &#x2F;&#x2F; vnode与oldVnode是否都是静态节点？若是，退出程序  if (isTrue(vnode.isStatic) &amp;&amp;    isTrue(oldVnode.isStatic) &amp;&amp;    vnode.key &#x3D;&#x3D;&#x3D; oldVnode.key &amp;&amp;    (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))  ) &#123;    return  &#125;  const oldCh &#x3D; oldVnode.children  const ch &#x3D; vnode.children  &#x2F;&#x2F; vnode有text属性？若没有：  if (isUndef(vnode.text)) &#123;    &#x2F;&#x2F; vnode的子节点与oldVnode的子节点是否都存在？    if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;      &#x2F;&#x2F; 若都存在，判断子节点是否相同，不同则更新子节点      if (oldCh !&#x3D;&#x3D; ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)    &#125;    &#x2F;&#x2F; 若只有vnode的子节点存在    else if (isDef(ch)) &#123;      &#x2F;**       * 判断oldVnode是否有文本？       * 若没有，则把vnode的子节点添加到真实DOM中       * 若有，则清空Dom中的文本，再把vnode的子节点添加到真实DOM中       *&#x2F;      if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &#39;&#39;)      addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)    &#125;    &#x2F;&#x2F; 若只有oldnode的子节点存在    else if (isDef(oldCh)) &#123;      &#x2F;&#x2F; 清空DOM中的子节点      removeVnodes(elm, oldCh, 0, oldCh.length - 1)    &#125;    &#x2F;&#x2F; 若vnode和oldnode都没有子节点，但是oldnode中有文本    else if (isDef(oldVnode.text)) &#123;      &#x2F;&#x2F; 清空oldnode文本      nodeOps.setTextContent(elm, &#39;&#39;)    &#125;    &#x2F;&#x2F; 上面两个判断一句话概括就是，如果vnode中既没有text，也没有子节点，那么对应的oldnode中有什么就清空什么  &#125;  &#x2F;&#x2F; 若有，vnode的text属性与oldVnode的text属性是否相同？  else if (oldVnode.text !&#x3D;&#x3D; vnode.text) &#123;    &#x2F;&#x2F; 若不相同：则用vnode的text替换真实DOM的文本    nodeOps.setTextContent(elm, vnode.text)  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/imgs/vue2.png" alt="Image text"></li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Vue中的DOM-Diff算法：patch过程。<br>patch过程干了三件事，分别是：创建节点，删除节点，更新节点。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue虚拟dom</title>
      <link href="/2021/07/22/vue-%E8%99%9A%E6%8B%9Fdom/"/>
      <url>/2021/07/22/vue-%E8%99%9A%E6%8B%9Fdom/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟DOM简介"><a href="#虚拟DOM简介" class="headerlink" title="虚拟DOM简介"></a>虚拟DOM简介</h1><h2 id="什么是虚拟dom"><a href="#什么是虚拟dom" class="headerlink" title="什么是虚拟dom"></a>什么是虚拟dom</h2><p>所谓虚拟DOM，就是用一个JS对象来描述一个DOM节点，像如下示例:</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&lt;div class&#x3D;&quot;a&quot; id&#x3D;&quot;b&quot;&gt;我是内容&lt;&#x2F;div&gt;&#123;  tag:&#39;div&#39;,        &#x2F;&#x2F; 元素标签  attrs:&#123;           &#x2F;&#x2F; 属性    class:&#39;a&#39;,    id:&#39;b&#39;  &#125;,  text:&#39;我是内容&#39;,  &#x2F;&#x2F; 文本内容  children:[]       &#x2F;&#x2F; 子元素&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="为什么要有虚拟DOM？"><a href="#为什么要有虚拟DOM？" class="headerlink" title="为什么要有虚拟DOM？"></a>为什么要有虚拟DOM？</h2><p>我们知道，Vue是数据驱动视图的，数据发生变化视图就要随之更新，在更新视图的时候难免要操作DOM,而操作真实DOM又是非常耗费性能的，这是因为浏览器的标准就把 DOM 设计的非常复杂，所以一个真正的 DOM 元素是非常庞大的，如下所示：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let div &#x3D; document.createElement(&#39;div&#39;)let str &#x3D; &#39;&#39;for (const key in div) &#123;  str +&#x3D; key + &#39;&#39;&#125;console.log(str) &#x2F;&#x2F; 结果是非常长的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在页面直接操作一个dom是非常消耗新能的、所以我们再操作dom之前使用js模拟一个虚拟dom，在数据发生变化的时候通过新老虚拟dom进行比较（diff算法），从而直接更新需要改变的视图。</p><h1 id="Vue中的虚拟DOM"><a href="#Vue中的虚拟DOM" class="headerlink" title="Vue中的虚拟DOM"></a>Vue中的虚拟DOM</h1><h2 id="VNode类"><a href="#VNode类" class="headerlink" title="VNode类"></a>VNode类</h2><p>虚拟DOM就是用JS来描述一个真实的DOM节点。而在Vue中就存在了一个VNode类，通过这个类，我们就可以实例化出不同类型的虚拟DOM节点，源码如下</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 源码位置：src&#x2F;core&#x2F;vdom&#x2F;vnode.jsexport default class VNode &#123;  constructor (    tag?: string,    data?: VNodeData,    children?: ?Array&lt;VNode&gt;,    text?: string,    elm?: Node,    context?: Component,    componentOptions?: VNodeComponentOptions,    asyncFactory?: Function  ) &#123;    this.tag &#x3D; tag                                &#x2F;*当前节点的标签名*&#x2F;    this.data &#x3D; data        &#x2F;*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*&#x2F;    this.children &#x3D; children  &#x2F;*当前节点的子节点，是一个数组*&#x2F;    this.text &#x3D; text     &#x2F;*当前节点的文本*&#x2F;    this.elm &#x3D; elm       &#x2F;*当前虚拟节点对应的真实dom节点*&#x2F;    this.ns &#x3D; undefined            &#x2F;*当前节点的名字空间*&#x2F;    this.context &#x3D; context          &#x2F;*当前组件节点对应的Vue实例*&#x2F;    this.fnContext &#x3D; undefined       &#x2F;*函数式组件对应的Vue实例*&#x2F;    this.fnOptions &#x3D; undefined    this.fnScopeId &#x3D; undefined    this.key &#x3D; data &amp;&amp; data.key           &#x2F;*节点的key属性，被当作节点的标志，用以优化*&#x2F;    this.componentOptions &#x3D; componentOptions   &#x2F;*组件的option选项*&#x2F;    this.componentInstance &#x3D; undefined       &#x2F;*当前节点对应的组件的实例*&#x2F;    this.parent &#x3D; undefined           &#x2F;*当前节点的父节点*&#x2F;    this.raw &#x3D; false         &#x2F;*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*&#x2F;    this.isStatic &#x3D; false         &#x2F;*静态节点标志*&#x2F;    this.isRootInsert &#x3D; true      &#x2F;*是否作为跟节点插入*&#x2F;    this.isComment &#x3D; false             &#x2F;*是否为注释节点*&#x2F;    this.isCloned &#x3D; false           &#x2F;*是否为克隆节点*&#x2F;    this.isOnce &#x3D; false                &#x2F;*是否有v-once指令*&#x2F;    this.asyncFactory &#x3D; asyncFactory    this.asyncMeta &#x3D; undefined    this.isAsyncPlaceholder &#x3D; false  &#125;  get child (): Component | void &#123;    return this.componentInstance  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的代码中可以看出：VNode类中包含了描述一个真实DOM节点所需要的一系列属性，如tag表示节点的标签名，text表示节点中包含的文本，children表示该节点包含的子节点等。通过属性之间不同的搭配，就可以描述出各种类型的真实DOM节点。</p><h2 id="VNode的类型"><a href="#VNode的类型" class="headerlink" title="VNode的类型"></a>VNode的类型</h2><ul><li>注释节点</li><li>文本节点</li><li>元素节点</li><li>组件节点</li><li>函数式组件节点</li><li>克隆节点</li></ul><h1 id="VNode的作用"><a href="#VNode的作用" class="headerlink" title="VNode的作用"></a>VNode的作用</h1><p>我们在视图渲染之前，把写好的template模板先编译成VNode并缓存下来，等到数据发生变化页面需要重新渲染的时候，我们把数据发生变化后生成的VNode与前一次缓存下来的VNode进行对比，找出差异，然后有差异的VNode对应的真实DOM节点就是需要重新渲染的节点，最后根据有差异的VNode创建出真实的DOM节点再插入到视图中，最终完成一次视图更新</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本章首先介绍了虚拟DOM的一些基本概念和为什么要有虚拟DOM，其实说白了就是以JS的计算性能来换取操作真实DOM所消耗的性能。接着从源码角度我们知道了在Vue中是通过VNode类来实例化出不同类型的虚拟DOM节点，并且学习了不同类型节点生成的属性的不同，所谓不同类型的节点其本质还是一样的，都是VNode类的实例，只是在实例化时传入的属性参数不同罢了。最后探究了VNode的作用，有了数据变化前后的VNode，我们才能进行后续的DOM-Diff找出差异，最终做到只更新有差异的视图，从而达到尽可能少的操作真实DOM的目的，以节省性能</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue双向绑定原理</title>
      <link href="/2021/07/21/vue-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/"/>
      <url>/2021/07/21/vue-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Vue双向绑定分为两个部分：对象和数组</p></blockquote><h1 id="object双向绑定原理"><a href="#object双向绑定原理" class="headerlink" title="object双向绑定原理"></a><strong>object</strong>双向绑定原理</h1><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li><p>通过Object.defineProperty()定义一个observer类，将正常的object转换成一个可观测的object，并且加上了_ob_属性，如果读取了会通过触发get，如果改变了会触发set</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">  &#x2F;&#x2F; 源码位置：src&#x2F;core&#x2F;observer&#x2F;index.js&#x2F;** * Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象 *&#x2F;export class Observer &#123;  constructor (value) &#123;    this.value &#x3D; value    &#x2F;&#x2F; 给value新增一个__ob__属性，值为该value的Observer实例    &#x2F;&#x2F; 相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作    def(value,&#39;__ob__&#39;,this)    if (Array.isArray(value)) &#123;      &#x2F;&#x2F; 当value为数组时的逻辑      &#x2F;&#x2F; ...    &#125; else &#123;      this.walk(value)    &#125;  &#125;  walk (obj: Object) &#123;    const keys &#x3D; Object.keys(obj)    for (let i &#x3D; 0; i &lt; keys.length; i++) &#123;      defineReactive(obj, keys[i])    &#125;  &#125;&#125;&#x2F;** * 使一个对象转化成可观测对象 * @param &#123; Object &#125; obj 对象 * @param &#123; String &#125; key 对象的key * @param &#123; Any &#125; val 对象的某个key的值 *&#x2F;function defineReactive (obj,key,val) &#123;  &#x2F;&#x2F; 如果只传了obj和key，那么val &#x3D; obj[key]  if (arguments.length &#x3D;&#x3D;&#x3D; 2) &#123;    val &#x3D; obj[key]  &#125;  if(typeof val &#x3D;&#x3D;&#x3D; &#39;object&#39;)&#123;      new Observer(val)  &#125;  Object.defineProperty(obj, key, &#123;    enumerable: true,    configurable: true,    get()&#123;      console.log(&#96;$&#123;key&#125;属性被读取了&#96;);      return val;    &#125;,    set(newVal)&#123;      if(val &#x3D;&#x3D;&#x3D; newVal)&#123;          return      &#125;      console.log(&#96;$&#123;key&#125;属性被修改了&#96;);      val &#x3D; newVal;    &#125;  &#125;)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>收集依赖，也就是收集那里用到了这个数据的。具体做法是定义一个dep类，其实就是一个数组，那里用到了就在数据里面push进去。dep里面有几个方法，在observer的get里面depend负责收集依赖（其实就是Watcher），在set里面notify通知所有依赖更新（通知的也是Watcher，最后由Watcher通知视图更新）</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 源码位置：src&#x2F;core&#x2F;observer&#x2F;dep.jsexport default class Dep &#123;  constructor () &#123;    this.subs &#x3D; []  &#125;  addSub (sub) &#123;    this.subs.push(sub)  &#125;  &#x2F;&#x2F; 删除一个依赖  removeSub (sub) &#123;    remove(this.subs, sub)  &#125;  &#x2F;&#x2F; 添加一个依赖  depend () &#123;    if (window.target) &#123;      this.addSub(window.target)    &#125;  &#125;  &#x2F;&#x2F; 通知所有依赖更新  notify () &#123;    const subs &#x3D; this.subs.slice()    for (let i &#x3D; 0, l &#x3D; subs.length; i &lt; l; i++) &#123;      subs[i].update()    &#125;  &#125;&#125;&#x2F;** * Remove an item from an array *&#x2F;export function remove (arr, item) &#123;  if (arr.length) &#123;    const index &#x3D; arr.indexOf(item)    if (index &gt; -1) &#123;      return arr.splice(index, 1)    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Watcher类，Watcher先把自己设置到全局唯一的指定位置（window.target），然后读取数据。因为读取了数据，所以会触发这个数据的getter。接着，在getter中就会从全局唯一的那个位置读取当前正在读取数据的Watcher，并把这个watcher收集到Dep中去。收集好之后，当数据发生变化时，会向Dep中的每个Watcher发送通知。通过这样的方式，Watcher可以主动去订阅任意一个数据的变化。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">export default class Watcher &#123;  constructor (vm,expOrFn,cb) &#123;    this.vm &#x3D; vm;    this.cb &#x3D; cb;    this.getter &#x3D; parsePath(expOrFn)    this.value &#x3D; this.get()  &#125;  get () &#123;    window.target &#x3D; this;    const vm &#x3D; this.vm    let value &#x3D; this.getter.call(vm, vm)    window.target &#x3D; undefined;    return value  &#125;  update () &#123;    const oldValue &#x3D; this.value    this.value &#x3D; this.get()    this.cb.call(this.vm, this.value, oldValue)  &#125;&#125;&#x2F;** * Parse simple path. * 把一个形如&#39;data.a.b.c&#39;的字符串路径所表示的值，从真实的data对象中取出来 * 例如： * data &#x3D; &#123;a:&#123;b:&#123;c:2&#125;&#125;&#125; * parsePath(&#39;a.b.c&#39;)(data)  &#x2F;&#x2F; 2 *&#x2F;const bailRE &#x3D; &#x2F;[^\w.$]&#x2F;export function parsePath (path) &#123;  if (bailRE.test(path)) &#123;    return  &#125;  const segments &#x3D; path.split(&#39;.&#39;)  return function (obj) &#123;    for (let i &#x3D; 0; i &lt; segments.length; i++) &#123;      if (!obj) return      obj &#x3D; obj[segments[i]]    &#125;    return obj  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Data通过observer转换成了getter/setter的形式来追踪变化。<br>当外界通过Watcher读取数据时，会触发getter从而将Watcher添加到依赖中。<br>当数据发生了变化时，会触发setter，从而向Dep中的依赖（即Watcher）发送通知。<br>Watcher接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。</p><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>虽然我们通过Object.defineProperty方法实现了对object数据的可观测，但是这个方法仅仅只能观测到object数据的取值及设置值，当我们向object数据里添加一对新的key/value或删除一对已有的key/value时，它是无法观测到的，导致当我们对object数据添加或删除值时，无法通知依赖，无法驱动视图进行响应式更新。</p><p>当然，Vue也注意到了这一点，为了解决这一问题，Vue增加了两个全局API:Vue.set和Vue.delete，这两个API的实现原理将会在后面学习全局API的时候说到。</p><h1 id="Array双向绑定原理"><a href="#Array双向绑定原理" class="headerlink" title="Array双向绑定原理"></a><strong>Array</strong>双向绑定原理</h1><p>为什么Object数据和Array型数据会有两种不同的变化侦测方式？</p><p>这是因为对于Object数据我们使用的是JS提供的对象原型上的方法Object.defineProperty，而这个方法是对象原型上的，所以Array无法使用这个方法，所以我们需要对Array型数据设计一套另外的变化侦测机制。</p><p>万变不离其宗，虽然对Array型数据设计了新的变化侦测机制，但是其根本思路还是不变的。那就是：还是在获取数据时收集依赖，数据变化时通知依赖更新。</p><h2 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li><p>收集依赖</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">data()&#123;  return &#123;    arr:[1,2,3]  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>arr这个数据始终都存在于一个object数据对象中，而且我们也说了，谁用到了数据谁就是依赖，那么要用到arr这个数据，是不是得先从object数据对象中获取一下arr数据，而从object数据对象中获取arr数据自然就会触发arr的getter，所以我们就可以在getter中收集依赖。<br>总结一句话就是：<strong>Array型数据还是在getter中收集依赖。</strong></p></li><li><p>使Array型数据可观测</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let arr &#x3D; [1,2,3]arr.push(4)Array.prototype.newPush &#x3D; function(val)&#123;  console.log(&#39;arr被修改了&#39;)  this.push(val)&#125;arr.newPush(4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面这个例子中，我们针对数组的原生push方法定义个一个新的newPush方法，这个newPush方法内部调用了原生push方法，这样就保证了新的newPush方法跟原生push方法具有相同的功能，而且我们还可以在新的newPush方法内部干一些别的事情，比如通知变化</p><h3 id="数组方法拦截器"><a href="#数组方法拦截器" class="headerlink" title="数组方法拦截器"></a>数组方法拦截器</h3><p>在Vue中创建了一个数组方法拦截器，它拦截在数组实例与Array.prototype之间，在拦截器内重写了操作数组的一些方法，当数组实例使用操作数组方法时，其实使用的是拦截器中重写的方法，而不再使用Array.prototype上的原生方法<br><img src="/imgs/vue1.png" alt="Image text"></p></li></ol><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const arrayProto &#x3D; Array.prototype&#x2F;&#x2F; 创建一个对象作为拦截器export const arrayMethods &#x3D; Object.create(arrayProto)&#x2F;&#x2F; 改变数组自身内容的7个方法const methodsToPatch &#x3D; [  &#39;push&#39;,  &#39;pop&#39;,  &#39;shift&#39;,  &#39;unshift&#39;,  &#39;splice&#39;,  &#39;sort&#39;,  &#39;reverse&#39;]&#x2F;** * Intercept mutating methods and emit events *&#x2F;methodsToPatch.forEach(function (method) &#123;  const original &#x3D; arrayProto[method]      &#x2F;&#x2F; 缓存原生方法  Object.defineProperty(arrayMethods, method, &#123;    enumerable: false,    configurable: true,    writable: true,    value:function mutator(...args)&#123;      const result &#x3D; original.apply(this, args)      return result    &#125;  &#125;)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的代码中，首先创建了继承自Array原型的空对象arrayMethods，接着在arrayMethods上使用object.defineProperty方法将那些可以改变数组自身的7个方法遍历逐个进行封装。最后，当我们使用push方法的时候，其实用的是arrayMethods.push，而arrayMethods.push就是封装的新函数mutator，也就后说，实标上执行的是函数mutator，而mutator函数内部执行了original函数，这个original函数就是Array.prototype上对应的原生方法。 那么，接下来我们就可以在mutator函数中做一些其他的事，比如说发送变化通知。</p><h3 id="使用拦截器"><a href="#使用拦截器" class="headerlink" title="使用拦截器"></a>使用拦截器</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 源码位置：&#x2F;src&#x2F;core&#x2F;observer&#x2F;index.jsexport class Observer &#123;  constructor (value) &#123;    this.value &#x3D; value    if (Array.isArray(value)) &#123;      const augment &#x3D; hasProto        ? protoAugment        : copyAugment      augment(value, arrayMethods, arrayKeys)    &#125; else &#123;      this.walk(value)    &#125;  &#125;&#125;&#x2F;&#x2F; 能力检测：判断__proto__是否可用，因为有的浏览器不支持该属性export const hasProto &#x3D; &#39;__proto__&#39; in &#123;&#125;const arrayKeys &#x3D; Object.getOwnPropertyNames(arrayMethods)&#x2F;** * Augment an target Object or Array by intercepting * the prototype chain using __proto__ *&#x2F;function protoAugment (target, src: Object, keys: any) &#123;  target.__proto__ &#x3D; src&#125;&#x2F;** * Augment an target Object or Array by defining * hidden properties. *&#x2F;&#x2F;* istanbul ignore next *&#x2F;function copyAugment (target: Object, src: Object, keys: Array&lt;string&gt;) &#123;  for (let i &#x3D; 0, l &#x3D; keys.length; i &lt; l; i++) &#123;    const key &#x3D; keys[i]    def(target, key, src[key])  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 源码位置：&#x2F;src&#x2F;core&#x2F;observer&#x2F;index.jsexport class Observer &#123;  constructor (value) &#123;    this.value &#x3D; value    this.dep &#x3D; new Dep()    &#x2F;&#x2F; 实例化一个依赖管理器，用来收集数组依赖    if (Array.isArray(value)) &#123;      const augment &#x3D; hasProto        ? protoAugment        : copyAugment      augment(value, arrayMethods, arrayKeys)    &#125; else &#123;      this.walk(value)    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function defineReactive (obj,key,val) &#123;  let childOb &#x3D; observe(val)  Object.defineProperty(obj, key, &#123;    enumerable: true,    configurable: true,    get()&#123;      if (childOb) &#123;        childOb.dep.depend()      &#125;      return val;    &#125;,    set(newVal)&#123;      if(val &#x3D;&#x3D;&#x3D; newVal)&#123;        return      &#125;      val &#x3D; newVal;      dep.notify()   &#x2F;&#x2F; 在setter中通知依赖更新    &#125;  &#125;)&#125;&#x2F;** * Attempt to create an observer instance for a value, * returns the new observer if successfully observed, * or the existing observer if the value already has one. * 尝试为value创建一个0bserver实例，如果创建成功，直接返回新创建的Observer实例。 * 如果 Value 已经存在一个Observer实例，则直接返回它 *&#x2F;export function observe (value, asRootData)&#123;  if (!isObject(value) || value instanceof VNode) &#123;    return  &#125;  let ob  if (hasOwn(value, &#39;__ob__&#39;) &amp;&amp; value.__ob__ instanceof Observer) &#123;    ob &#x3D; value.__ob__  &#125; else &#123;    ob &#x3D; new Observer(value)  &#125;  return ob&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="通知依赖"><a href="#通知依赖" class="headerlink" title="通知依赖"></a>通知依赖</h3><p>我们只要能访问到被转化成响应式的数据value即可，因为vaule上的__ob__就是其对应的Observer类实例，有了Observer类实例我们就能访问到它上面的依赖管理器，然后只需调用依赖管理器的dep.notify()方法，让它去通知依赖更新即可</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;** * Intercept mutating methods and emit events *&#x2F;methodsToPatch.forEach(function (method) &#123;  const original &#x3D; arrayProto[method]  def(arrayMethods, method, function mutator (...args) &#123;    const result &#x3D; original.apply(this, args)    const ob &#x3D; this.__ob__    &#x2F;&#x2F; notify change    ob.dep.notify()    return result  &#125;)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="不足-1"><a href="#不足-1" class="headerlink" title="不足"></a>不足</h2><p>前文中我们说过，对于数组变化侦测是通过拦截器实现的，也就是说只要是通过数组原型上的方法对数组进行操作就都可以侦测到，但是别忘了，我们在日常开发中，还可以通过数组的下标来操作数据，如下</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let arr &#x3D; [1,2,3]arr[0] &#x3D; 5;       &#x2F;&#x2F; 通过数组下标修改数组中的数据arr.length &#x3D; 0    &#x2F;&#x2F; 通过修改数组长度清空数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>而使用上述例子中的操作方式来修改数组是无法侦测到的。 同样，Vue也注意到了这个问题， 为了解决这一问题，Vue增加了两个全局API:Vue.set和Vue.delete，这两个API的实现原理将会在后面学习全局API的时候说到</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>首先我们分析了对于Array型数据也在getter中进行依赖收集；其次我们发现，当数组数据被访问时我们轻而易举可以知道，但是被修改时我们却很难知道，为了解决这一问题，我们创建了数组方法拦截器，从而成功的将数组数据变的可观测。接着我们对数组的依赖收集及数据变化如何通知依赖进行了深入分析；最后我们发现Vue不但对数组自身进行了变化侦测，还对数组中的每一个元素以及新增的元素都进行了变化侦测</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>async、await</title>
      <link href="/2021/07/21/async%E3%80%81await/"/>
      <url>/2021/07/21/async%E3%80%81await/</url>
      
        <content type="html"><![CDATA[<h2 id="async-和-await-在干什么"><a href="#async-和-await-在干什么" class="headerlink" title="async 和 await 在干什么"></a>async 和 await 在干什么</h2><p>任意一个名称都是有意义的，先从字面意思来理解。async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。</p><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>这个问题的关键在于，async 函数是怎么处理它的返回值的！<br>我们当然希望它能直接通过 return 语句返回我们想要的值，但是如果真是这样，似乎就没 await 什么事了。所以，写段代码来试试，看它到底会返回什么：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">async function testAsync() &#123;    return &quot;hello async&quot;;&#125;const result &#x3D; testAsync();console.log(result);  &#x2F;&#x2F; Promise &#123; &#39;hello async&#39; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>——输出的是一个 Promise 对象。</p><p>所以，async 函数返回的是一个 Promise 对象。从文档中也可以得到这个信息。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。</p><p>Promise.resolve(x) 可以看作是 new Promise(resolve =&gt; resolve(x)) 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。</p><p>async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，我们当然应该用原来的方式：then() 链来处理这个 Promise 对象，就像这样</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">testAsync().then(v &#x3D;&gt; &#123;    console.log(v);    &#x2F;&#x2F; 输出 hello async&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p>一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。</p><p>因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function getSomething() &#123;    return &quot;something&quot;;&#125;async function testAsync() &#123;    return Promise.resolve(&quot;hello async&quot;);&#125;async function test() &#123;    const v1 &#x3D; await getSomething();    const v2 &#x3D; await testAsync();    console.log(v1, v2);&#125;test();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="await-等到了要等的，然后呢"><a href="#await-等到了要等的，然后呢" class="headerlink" title="await 等到了要等的，然后呢"></a>await 等到了要等的，然后呢</h3><p>await 等到了它要等的东西，一个 Promise 对象，或者其它值，然后呢？我不得不先说，await 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西。</p><p>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</p><p>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</p><blockquote><p>async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。</p></blockquote><h2 id="async-await-gt-promise"><a href="#async-await-gt-promise" class="headerlink" title="async/await -&gt; promise"></a>async/await -&gt; promise</h2><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function step1(n) &#123;    console.log(&#96;step1 with $&#123;n&#125;&#96;);    return takeLongTime(n);&#125;function step2(m, n) &#123;    console.log(&#96;step2 with $&#123;m&#125; and $&#123;n&#125;&#96;);    return takeLongTime(m + n);&#125;function step3(k, m, n) &#123;    console.log(&#96;step3 with $&#123;k&#125;, $&#123;m&#125; and $&#123;n&#125;&#96;);    return takeLongTime(k + m + n);&#125;&#x2F;&#x2F; asyne&#x2F;awaitasync function doIt() &#123;    console.time(&quot;doIt&quot;);    const time1 &#x3D; 300;    const time2 &#x3D; await step1(time1);    const time3 &#x3D; await step2(time1, time2);    const result &#x3D; await step3(time1, time2, time3);    console.log(&#96;result is $&#123;result&#125;&#96;);    console.timeEnd(&quot;doIt&quot;);&#125;doIt();&#x2F;&#x2F; promisefunction doIt() &#123;    console.time(&quot;doIt&quot;);    const time1 &#x3D; 300;    step1(time1)        .then(time2 &#x3D;&gt; &#123;            return step2(time1, time2)                .then(time3 &#x3D;&gt; [time1, time2, time3]);        &#125;)        .then(times &#x3D;&gt; &#123;            const [time1, time2, time3] &#x3D; times;            return step3(time1, time2, time3);        &#125;)        .then(result &#x3D;&gt; &#123;            console.log(&#96;result is $&#123;result&#125;&#96;);            console.timeEnd(&quot;doIt&quot;);        &#125;);&#125;doIt();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>看起来更像是同步操作</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器渲染</title>
      <link href="/2021/07/21/http-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/"/>
      <url>/2021/07/21/http-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<h1 id="整体我觉得分为两个部分"><a href="#整体我觉得分为两个部分" class="headerlink" title="整体我觉得分为两个部分"></a>整体我觉得分为两个部分</h1><p>获取html文件的过程<br>渲染过程</p><h2 id="获取html文件的过程"><a href="#获取html文件的过程" class="headerlink" title="获取html文件的过程"></a>获取html文件的过程</h2><p>浏览器的地址栏输入URL并按下回车。<br>浏览器查找当前URL是否存在缓存，并比较缓存是否过期。<br>DNS解析URL对应的IP。<br>根据IP建立TCP连接（三次握手）。<br>HTTP发起请求。<br>服务器处理请求，浏览器接收HTTP响应。<br>渲染页面，构建DOM树。<br>关闭TCP连接（四次挥手）。</p><h2 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h2><p>1、当用户输入一个URL时，浏览器就会向服务器发出一个请求，请求URL对应的资源<br>2、接受到服务器的响应内容后，浏览器的HTML解析器，会将HTML文件解析成一棵DOM树，DOM树的构建是一个深度遍历的过程，当前节点的所有子节点都构建完成以后，才会去构建当前节点的下一个兄弟节点。<br>3、将CSS解析成CSSOM树（CSS Rule Tree）<br>4、根据DOM树和CSSOM树，来构建Render Tree（渲染树）,注意渲染树，并不等于DOM树，因为一些像head或display:none的东西，就没有必要放在渲染树中了。<br>5、有了Render Tree，浏览器已经能知道网页中有哪些节点，各个节点的CSS定义，以及它们的从属关系，下一步操作就是Layout,顾名思义，就是计算出每个节点在屏幕中的位置。<br>6、Layout后，浏览器已经知道哪些节点要显示，每个节点的CSS属性是什么，每个节点在屏幕中的位置是哪里，就进入了最后一步painting,按照算出来的规则，通过显卡，把内容画到屏幕上。</p><blockquote><p>这里还要说两个概念，一个是Reflow，另一个是Repaint。这两个不是一回事。<br>Repaint（重绘） ——改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。<br>Reflow（重排） ——元件的几何尺寸变了，我们需要重新验证并计算Render Tree。是Render Tree的一部分或全部发生了变化。</p></blockquote><p><img src="/imgs/http.png" alt="Image text"></p>]]></content>
      
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由模式</title>
      <link href="/2021/07/20/%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/07/20/%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>路由模式</p></blockquote><h3 id="hash模式"><a href="#hash模式" class="headerlink" title="hash模式"></a>hash模式</h3><p>这里的 hash 就是指 url 尾巴后的 # 号以及后面的字符。这里的 # 和 css 里的 # 是一个意思。hash 也 称作 锚点，本身是用来做页面定位的，她可以使对应 id 的元素显示在可视区域内。</p><p>由于 hash 值变化不会导致浏览器向服务器发出请求，而且 hash 改变会触发 hashchange 事件，浏览器的进后退也能对其进行控制，所以人们在 html5 的 history 出现前，基本都是使用 hash 来实现前端路由的。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">window.location.hash &#x3D; &#39;qq&#39; &#x2F;&#x2F; 设置 url 的 hash，会在当前url后加上 &#39;#qq&#39;var hash &#x3D; window.location.hash &#x2F;&#x2F; &#39;#qq&#39;  window.addEventListener(&#39;hashchange&#39;, function()&#123;     &#x2F;&#x2F; 监听hash变化，点击浏览器的前进后退会触发&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="history模式"><a href="#history模式" class="headerlink" title="history模式"></a>history模式</h3><p>已经有 hash 模式了，而且 hash 能兼容到IE8， history 只能兼容到 IE10，为什么还要搞个 history 呢？<br>首先，hash 本来是拿来做页面定位的，如果拿来做路由的话，原来的锚点功能就不能用了。其次，hash 的传参是基于 url 的，如果要传递复杂的数据，会有体积的限制，而 history 模式不仅可以在url里放参数，还可以将数据存放在一个特定的对象中。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">window.history.pushState(state, title, url) &#x2F;&#x2F; state：需要保存的数据，这个数据在触发popstate事件时，可以在event.state里获取&#x2F;&#x2F; title：标题，基本没用，一般传 null&#x2F;&#x2F; url：设定新的历史记录的 url。新的 url 与当前 url 的 origin 必须是一樣的，否则会抛出错误。url可以是绝对路径，也可以是相对路径。&#x2F;&#x2F;如 当前url是 https:&#x2F;&#x2F;www.baidu.com&#x2F;a&#x2F;,执行history.pushState(null, null, &#39;.&#x2F;qq&#x2F;&#39;)，则变成 https:&#x2F;&#x2F;www.baidu.com&#x2F;a&#x2F;qq&#x2F;，&#x2F;&#x2F;执行history.pushState(null, null, &#39;&#x2F;qq&#x2F;&#39;)，则变成 https:&#x2F;&#x2F;www.baidu.com&#x2F;qq&#x2F;window.history.replaceState(state, title, url)&#x2F;&#x2F; 与 pushState 基本相同，但她是修改当前历史记录，而 pushState 是创建新的历史记录window.addEventListener(&quot;popstate&quot;, function() &#123;&#x2F;&#x2F; 监听浏览器前进后退事件，pushState 与 replaceState 方法不会触发&#125;);window.history.back() &#x2F;&#x2F; 后退window.history.forward() &#x2F;&#x2F; 前进window.history.go(1) &#x2F;&#x2F; 前进一步，-2为后退两步，window.history.lengthk可以查看当前历史堆栈中页面的数量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise</title>
      <link href="/2021/07/20/promise/"/>
      <url>/2021/07/20/promise/</url>
      
        <content type="html"><![CDATA[<h2 id="promise是什么？"><a href="#promise是什么？" class="headerlink" title="promise是什么？"></a>promise是什么？</h2><p>1、主要用于异步计算<br>2、可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果<br>3、可以在对象之间传递和操作promise，帮助我们处理队列</p><h2 id="异步回调的问题"><a href="#异步回调的问题" class="headerlink" title="异步回调的问题"></a>异步回调的问题</h2><ul><li>之前处理异步是通过纯粹的回调函数的形式进行处理</li><li>很容易进入到回调地狱中，剥夺了函数return的能力</li><li>问题可以解决，但是难以读懂，维护困难</li><li>稍有不慎就会踏入回调地狱 - 嵌套层次深，不好维护</li></ul><h2 id="new-Promise"><a href="#new-Promise" class="headerlink" title="new Promise"></a>new Promise</h2><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">new Promise(  function (resolve, reject) &#123;    &#x2F;&#x2F; 一段耗时的异步操作    resolve(&#39;成功&#39;) &#x2F;&#x2F; 数据处理完成    &#x2F;&#x2F; reject(&#39;失败&#39;) &#x2F;&#x2F; 数据处理出错  &#125;).then(  (res) &#x3D;&gt; &#123;console.log(res)&#125;,  &#x2F;&#x2F; 成功  (err) &#x3D;&gt; &#123;console.log(err)&#125; &#x2F;&#x2F; 失败)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Promise-all-批量执行"><a href="#Promise-all-批量执行" class="headerlink" title="Promise.all() 批量执行"></a>Promise.all() 批量执行</h2><p>Promise.all([p1, p2, p3])用于将多个promise实例，包装成一个新的Promise实例，返回的实例就是普通的promise<br>它接收一个数组作为参数<br>数组里可以是Promise对象，也可以是别的值，只有Promise会等待状态改变<br>当所有的子Promise都完成，该Promise完成，返回值是全部值得数组<br>有任何一个失败，该Promise失败，返回值是第一个失败的子Promise结果</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F;切菜function cutUp()&#123;    console.log(&#39;开始切菜。&#39;);    var p &#x3D; new Promise(function(resolve, reject)&#123;        &#x2F;&#x2F;做一些异步操作        setTimeout(function()&#123;            console.log(&#39;切菜完毕！&#39;);            resolve(&#39;切好的菜&#39;);        &#125;, 1000);    &#125;);    return p;&#125;&#x2F;&#x2F;烧水function boil()&#123;    console.log(&#39;开始烧水。&#39;);    var p &#x3D; new Promise(function(resolve, reject)&#123;        &#x2F;&#x2F;做一些异步操作        setTimeout(function()&#123;            console.log(&#39;烧水完毕！&#39;);            resolve(&#39;烧好的水&#39;);        &#125;, 1000);    &#125;);    return p;&#125;Promise.all([cutUp(), boil()])    .then((result) &#x3D;&gt; &#123;        console.log(&#39;准备工作完毕&#39;);        console.log(result);    &#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Promise-race-它有任意一个完成就算完成"><a href="#Promise-race-它有任意一个完成就算完成" class="headerlink" title="Promise.race() 它有任意一个完成就算完成"></a>Promise.race() 它有任意一个完成就算完成</h2><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let p1 &#x3D; new Promise(resolve &#x3D;&gt; &#123;    setTimeout(() &#x3D;&gt; &#123;        resolve(&#39;I\&#96;m p1 &#39;)    &#125;, 1000)&#125;);let p2 &#x3D; new Promise(resolve &#x3D;&gt; &#123;    setTimeout(() &#x3D;&gt; &#123;        resolve(&#39;I\&#96;m p2 &#39;)    &#125;, 2000)&#125;);Promise.race([p1, p2])    .then(value &#x3D;&gt; &#123;        console.log(value)    &#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="回调地狱和promise对比"><a href="#回调地狱和promise对比" class="headerlink" title="回调地狱和promise对比"></a>回调地狱和promise对比</h2><ul><li>回调地狱<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;***   第一步：找到北京的id   第二步：根据北京的id -&gt; 找到北京公司的id   第三步：根据北京公司的id -&gt; 找到北京公司的详情   目的：模拟链式调用、回调地狱 ***&#x2F;  &#x2F;&#x2F; 回调地狱 &#x2F;&#x2F; 请求第一个API: 地址在北京的公司的id $.ajax(&#123;   url: &#39;https:&#x2F;&#x2F;www.easy-mock.com&#x2F;mock&#x2F;5a52256ad408383e0e3868d7&#x2F;lagou&#x2F;city&#39;,   success (resCity) &#123;     let findCityId &#x3D; resCity.filter(item &#x3D;&gt; &#123;       if (item.id &#x3D;&#x3D; &#39;c1&#39;) &#123;         return item       &#125;     &#125;)[0].id     $.ajax(&#123;       &#x2F;&#x2F;  请求第二个API: 根据上一个返回的在北京公司的id “findCityId”，找到北京公司的第一家公司的id       url: &#39;https:&#x2F;&#x2F;www.easy-mock.com&#x2F;mock&#x2F;5a52256ad408383e0e3868d7&#x2F;lagou&#x2F;position-list&#39;,       success (resPosition) &#123;         let findPostionId &#x3D; resPosition.filter(item &#x3D;&gt; &#123;           if(item.cityId &#x3D;&#x3D; findCityId) &#123;             return item           &#125;         &#125;)[0].id         &#x2F;&#x2F; 请求第三个API: 根据上一个API的id(findPostionId)找到具体公司，然后返回公司详情         $.ajax(&#123;           url: &#39;https:&#x2F;&#x2F;www.easy-mock.com&#x2F;mock&#x2F;5a52256ad408383e0e3868d7&#x2F;lagou&#x2F;company&#39;,           success (resCom) &#123;             let comInfo &#x3D; resCom.filter(item &#x3D;&gt; &#123;               if (findPostionId &#x3D;&#x3D; item.id) &#123;                 return item               &#125;             &#125;)[0]             console.log(comInfo)           &#125;         &#125;)       &#125;     &#125;)   &#125; &#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; Promise 写法&#x2F;&#x2F; 第一步：获取城市列表const cityList &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;  $.ajax(&#123;    url: &#39;https:&#x2F;&#x2F;www.easy-mock.com&#x2F;mock&#x2F;5a52256ad408383e0e3868d7&#x2F;lagou&#x2F;city&#39;,    success (res) &#123;      resolve(res)    &#125;  &#125;)&#125;)&#x2F;&#x2F; 第二步：找到城市是北京的idcityList.then(res &#x3D;&gt; &#123;  let findCityId &#x3D; res.filter(item &#x3D;&gt; &#123;    if (item.id &#x3D;&#x3D; &#39;c1&#39;) &#123;      return item    &#125;  &#125;)[0].id  findCompanyId().then(res &#x3D;&gt; &#123;    &#x2F;&#x2F; 第三步（2）：根据北京的id -&gt; 找到北京公司的id    let findPostionId &#x3D; res.filter(item &#x3D;&gt; &#123;        if(item.cityId &#x3D;&#x3D; findCityId) &#123;          return item        &#125;    &#125;)[0].id    &#x2F;&#x2F; 第四步（2）：传入公司的id    companyInfo(findPostionId)  &#125;)&#125;)&#x2F;&#x2F; 第三步（1）：根据北京的id -&gt; 找到北京公司的idfunction findCompanyId () &#123;  let aaa &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;    $.ajax(&#123;      url: &#39;https:&#x2F;&#x2F;www.easy-mock.com&#x2F;mock&#x2F;5a52256ad408383e0e3868d7&#x2F;lagou&#x2F;position-list&#39;,      success (res) &#123;        resolve(res)      &#125;    &#125;)  &#125;)  return aaa&#125;&#x2F;&#x2F; 第四步：根据上一个API的id(findPostionId)找到具体公司，然后返回公司详情function companyInfo (id) &#123;  let companyList &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;    $.ajax(&#123;      url: &#39;https:&#x2F;&#x2F;www.easy-mock.com&#x2F;mock&#x2F;5a52256ad408383e0e3868d7&#x2F;lagou&#x2F;company&#39;,      success (res) &#123;        let comInfo &#x3D; res.filter(item &#x3D;&gt; &#123;            if (id &#x3D;&#x3D; item.id) &#123;               return item            &#125;        &#125;)[0]        console.log(comInfo)      &#125;    &#125;)  &#125;)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>this词法</title>
      <link href="/2021/07/19/js-this%E8%AF%8D%E6%B3%95/"/>
      <url>/2021/07/19/js-this%E8%AF%8D%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>ES6添加了一个特殊的词法形式的函数声明，叫做箭头函数，箭头函数在涉及this绑定的行为和普通函数的行为完全不一样，他放弃了所有的普通函数this绑定的规则，取而代之的是用当前的词法作用域覆盖了this原本的值。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var obj &#x3D; &#123;    count: 0,    cool: function coolFn() &#123;        if(this.count &lt; 1) &#123;            setTimeout(() &#x3D;&gt; &#123;                this.count++;                console.log(&#39;awesome?&#39;);            &#125;,1000);        &#125;    &#125;&#125;obj.cool();&#x2F;&#x2F;awesome?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个箭头函数中的this直接是cool()的this绑定（因此调用它并不会出错）</p><p>它将程序员们经常犯的一个错误给标准化了，也就是混淆了this绑定规则和词法作用域规则。</p><p>另一个导致箭头函数不够理想的原因是他不是具名的，而是一个匿名函数。</p><h3 id="误解："><a href="#误解：" class="headerlink" title="误解："></a>误解：</h3><ol><li>人们很容易把this理解成指向函数自身。那么为什么函数要从内部引用函数自身呢？常见的原因是递归（从函数内部调用这个函数）或者可以写在第一次被调用后自己解除绑定事件处理器。</li><li>新手通常会认为，既然把函数看做一个对象，那就可以在调用函数时储存状态。</li></ol><p>call</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function foo(num) &#123;    console.log(&quot;foo&quot; + num);    this.count ++;&#125;foo.count &#x3D; 0;var i;for(i &#x3D; 0; i &lt; 10; i++)&#123;    if(i &gt; 5) &#123;        &#x2F;&#x2F; 使用call(...) 可以确保this指向函数本身        foo.call(foo, i)    &#125;&#125;&#x2F;&#x2F; foo: 6&#x2F;&#x2F; foo: 7&#x2F;&#x2F; foo: 8&#x2F;&#x2F; foo: 9cnosole.log(foo.count); &#x2F;&#x2F; 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="它的作用域"><a href="#它的作用域" class="headerlink" title="它的作用域"></a>它的作用域</h3><p>还有一种常见的错误是，this指向函数的作用域。这个问题在某中情况下是正确的，但是有时候又是错误的。需要明确的是this在任何情况下都不指向函数的词法作域。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function foo()&#123;    var a &#x3D; 2;    this.bar(); &#x2F;&#x2F;  能调用到bar也是意外，正常应该通过词法作用域，直接执行&#125;function bar()&#123;    console.log(this.a)&#125;foo();  &#x2F;&#x2F; a not defined<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>==当你想把this和词法作用域的查找混合使用的时候，一定要提醒自己这是无法实现的==</p><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>this不是在写代码时候绑定的而是代码在执行的时候绑定的，它的上下文取决于函数调用时的各种条件。</p><p>this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</p><p>==当一个函数被执行时，会创建一个活动记录（有时候也被称之为执行上下文）。这个记录会包含函数在哪里被调用、函数的调用方式、传入参数等信息。this就是这个记录的一个属性，会在函数执行的过程中调用到。==</p><p>this实际上是在函数被调用的时候发生绑定，他指向什么完全取决于函数在哪里被调用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2021/07/19/js-%E9%97%AD%E5%8C%85/"/>
      <url>/2021/07/19/js-%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<blockquote><p>闭包是基于词法作用域书写代码时所产生的自然结果</p></blockquote><p>闭包的产生：<br>函数在被定义的地方之外被执行就会产生闭包！！！</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function foo() &#123;    var a &#x3D; 2;    function bar()&#123;        console.log(a);    &#125;    return bar;&#125;var bza &#x3D; foo();baz(); &#x2F;&#x2F; 2  这就是闭包！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通常情况下foo执行之后整个内部作用域都会被销毁，因为引擎会销毁不再使用的空间来释放内存空间。</p><p>然而闭包会阻止这一情况的发生，会让作用域依然存在，因为bar函数还在使用foo这个作用域，需要给bar在任何时候执行提供支持。所以foo的作用域不会被销毁，bar依然持有对该作用域的引用，这个引用就是闭包！</p><p>==无论通过何种手段将内部函数传递到所在的词法作用域以外，他都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。==</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function wait(message)&#123;    setTimeout( function timer() &#123;        console.log(message);    &#125;,1000)&#125;wait(&#39;hello&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>wait执行1000毫秒以后，他的内部作用域并不会消失，还能保持message的引用。</p><p>==只要是使用了回调函数，实际上就是在使用闭包。==</p><h3 id="闭包和循环"><a href="#闭包和循环" class="headerlink" title="闭包和循环"></a>闭包和循环</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">for(var i &#x3D; 1;i &lt;&#x3D; 5; i++;)&#123;    setTimeout(function timer() &#123;        console.log(i);    &#125;,1*1000)&#125;&#x2F;&#x2F; 每秒一次输出五个6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个循环终止的条件是6.条件首次成立的时候i === 6<br>，因此输出的显示是循环结束时i的值。<br>因为这里所用的i，是同一个作用域下的i，所有的函数共享一个i。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">for(var i &#x3D; 1;i &lt;&#x3D; 5; i++;)&#123;    (function() &#123;        setTimeout(function timer() &#123;            console.log(i);        &#125;,1*1000)    &#125;();&#125;&#x2F;&#x2F;这样也不行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为我们的IIFE的作用域是空的，我们使用的依然是外层的i，他要包含一点实质的内容才能够我们使用。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">for(var i &#x3D; 1;i &lt;&#x3D; 5; i++;)&#123;    (function(j) &#123;        setTimeout(function timer() &#123;            console.log(j);        &#125;,j*1000)    &#125;(i);&#125;&#x2F;&#x2F; 这样就达到我们预期的目的，每秒一个，一次输出1-5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="重返块作用域"><a href="#重返块作用域" class="headerlink" title="重返块作用域"></a>重返块作用域</h3><p>前面说let可以劫持块级作用域，，并且在这个块级作用域中声明一个变量。看下面代码</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">for(var i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;    let j &#x3D; i;    setTimeout(function timer() &#123;        console.log(j);    &#125;,j*1000)&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还可以更完善</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">for(let i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;    setTimeout(function timer() &#123;        console.log(i);    &#125;,i*1000)&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function foo()&#123;    var a &#x3D; &#39;cool&#39;;    var b &#x3D; [1,2,3];    function bar() &#123;        console.log(a);    &#125;    function baz() &#123;        console.log(b);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里并没有明显的闭包，只有两个私有数据变量a和b，以及bar和baz两个内部函数，他们的词法作用域就是闭包，<br>也就是foo（）的内部作用域。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function CoolModule() &#123;    var something &#x3D; &#39;cool&#39;;    var another &#x3D; [1,2,3];    function doSomething() &#123;        console.log(something));    &#125;    function doAnother() &#123;        console.log(another.join(&quot;!&quot;));    &#125;    return &#123;        doSomething: doSomething,        doAnother: doAnother,    &#125;;&#125;var foo &#x3D; CoolModule;foo.doSomething(); &#x2F;&#x2F; coolfoo.doAnother(); &#x2F;&#x2F; 1!2!3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，CoolModule() 只是一个函数，必须通过调用它来创建一个模块实例，如果不执行外部函数，内部作用域和闭包都无法被创建。</p><p>其次，CoolModule() 返回一个用对象字面量语法来表示的对象，这个返回的对象中含有内部函数，而不是内部数据变量的引用。我们保持内部数据变量是隐藏且私有状态。</p><p>这个对象类型的返回值最终被赋值给外部变量foo，然后我们就可以通过它来访问API中的属性方法。 </p><blockquote><p>模块模式必须具有两个条件</p></blockquote><ol><li>必须有外部的封闭函数，该函数必须至少被调用一次。（每次调用都会创建一个新的模块实例）</li><li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li></ol><p>一个具有函数属性的对象本身并不是真正的模块。从方便观察角度来看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。</p><p>改进上面的代码</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var foo &#x3D; (function CoolModule() &#123;    var something &#x3D; &#39;cool&#39;;    var another &#x3D; [1,2,3];    function doSomething() &#123;        console.log(something));    &#125;    function doAnother() &#123;        console.log(another.join(&quot;!&quot;));    &#125;    return &#123;        doSomething: doSomething,        doAnother: doAnother,    &#125;;&#125;)();foo.doSomething(); &#x2F;&#x2F; coolfoo.doAnother(); &#x2F;&#x2F; 1!2!3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>模块是普通函数，因此也可以传参。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function CoolModule(id) &#123;    function doSomething() &#123;        console.log(id);    &#125;    return &#123;        doSomething: doSomething,    &#125;;&#125;var foo &#x3D; CoolModule(&#39;foo&#39;);foo.doSomething(); &#x2F;&#x2F; foo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>模块另一个简单但又强大的用法是命名将要作为公共API返回的对象。</p></blockquote><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var foo &#x3D; (function Cool(id)&#123;    function change() &#123;        publicAPI.identify &#x3D; identify2;    &#125;;    function identify1() &#123;        console.log(id);    &#125;;    function identify2() &#123;        console.log(id.toUppeCase());    &#125;;    var publicAPI &#x3D; &#123;        change: change,        identify: identify1    &#125;    return publicAPI;&#125;)(&#39;foo module&#39;);foo.identify(); &#x2F;&#x2F; foo modulefoo.change();foo.identify(); &#x2F;&#x2F; FOO MODULE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过模块在实例的内部保留的公共API对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法，以及修改他们的值。</p><h2 id="现代的模块机制"><a href="#现代的模块机制" class="headerlink" title="现代的模块机制"></a>现代的模块机制</h2><p>创建一个模块</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var MyModules &#x3D; (function Manager()&#123;    &#x2F;&#x2F; 存储方法    var modules &#x3D; &#123;&#125;;        &#x2F;&#x2F; 添加方法    function define(name,deps,impl)&#123;        for(var i &#x3D; 0;i &lt; deps.length; i++) &#123;            deps[i] &#x3D; modules[deps[i]];        &#125;        modules[name] &#x3D; impl.apply(impl,deps);    &#125;        &#x2F;&#x2F; 根据名字获取方法    function get(name) &#123;        return modules[name];    &#125;        &#x2F;&#x2F; 返回内部函数（方法）    return &#123;        define: define,        get: get    &#125;&#125;)()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Function.apply(obj,args)方法能接收两个参数</p><p>obj：这个对象将代替Function类里this对象</p><p>args：这个是数组，它将作为参数传给Function(args–&gt;arguments)</p><p>使用它来定义模块：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">MyModules.define(&quot;bar&quot;,[], function() &#123;    function hello(who) &#123;        return &quot;let me introduce:&quot; + who;    &#125;    retrun &#123;        hello : hello    &#125;;&#125;);MyModules.define(&quot;foo&quot;,[&#39;bar&#39;], function(bar) &#123;    var hungry &#x3D; &#39;hippo&#39;;    function awesome(who) &#123;        console.log(bar.hello(hungry).toUpperCase());    &#125;    retrun &#123;        awesome : awesome    &#125;;&#125;);var bar &#x3D; MyModules.get(&#39;bar&#39;);var foo &#x3D; MyModules.get(&#39;foo&#39;);console.log(bar.hello(&#39;hippo&#39;));&#x2F;&#x2F; let me introduce: hippofoo.awesome(); &#x2F;&#x2F; 大写的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>foo 和 bar 都是通过一个返回的公共的API的函数来定义的。foo 甚至接受 bar 的实例作为依赖参数，并且相应地使用它。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数中的作用域</title>
      <link href="/2021/07/18/js-%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%BF%AB/"/>
      <url>/2021/07/18/js-%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%BF%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="函数中的作用域"><a href="#函数中的作用域" class="headerlink" title="函数中的作用域"></a>函数中的作用域</h2><p>js有基于函数的作用域，每声明一个函数都会为其自身创建一个气泡，可以在附属气泡里获取外层的变量，但是不能从外层气泡中获取附属气泡种的变量</p><h2 id="隐藏内部实现"><a href="#隐藏内部实现" class="headerlink" title="隐藏内部实现"></a>隐藏内部实现</h2><blockquote><p>暴露在外面的写法，很不安全</p></blockquote><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function foo(a) &#123;    b &#x3D; a + fff(a * 2);    console.log(b * 3);&#125;function fff(a) &#123;    return a - 1;&#125;var b;foo(2) &#x2F;&#x2F; 15<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>隐藏的写法</p></blockquote><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function foo(a) &#123;    function fff(a) &#123;        return a - 1;    &#125;    var b;    b &#x3D; a + fff(a * 2);    console.log(b * 3);&#125;foo(2) &#x2F;&#x2F; 15<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>规避冲突，<br>可以避免同名标识符之间的冲突，避免被覆盖</p></blockquote><p>方法：</p><ol><li>全局命名空间，在全局声明一个独特的变量，通常是一个对象，所有需要暴露给外界的功能都会成为这个对象的属性，而不是将自己的标识符暴露在顶级的词法作用域种。</li><li>模块管理，从众多模块中挑选一个来使用，任何库都无需将标识符加入到全局作用域中。</li></ol><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>在任意代码片段外部添加包装函数都可以将内部的变量和函数定义‘隐藏’起来，外部作用域无法访问包装函数内部的任何内容</p><p>通过定义一个函数来达到是变量在函数作用域之内，虽然可以解决问题，但是并不理想，因为这个函数名称本身污染了所在的作用域，其次是必须通过显式的调用这个函数才能运行其中的代码。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var a &#x3D; 2;(function foo()&#123;    var a &#x3D; 3;    console.log( a ); &#x2F;&#x2F; 3&#125;)();console.log( a ); &#x2F;&#x2F; 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样函数会被当作函数表达式而不是一个标准的函数声明来处理。– 如果function是声明中的第一个第一个词，那么就是函数声明，否则就是函数表达式。</p><p>函数表达式和函数声明最大的区别是它们的名称标识符将会绑定在何处。  foo只能在所代表的位置中被访问，外部不行。</p><h2 id="匿名和具名"><a href="#匿名和具名" class="headerlink" title="匿名和具名"></a>匿名和具名</h2><blockquote><p>匿名函数表达式</p></blockquote><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">setTimeout( function()&#123;    console.log(&#39;aaa&#39;);&#125;,1000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>fun没有标识符，函数声明则是不可以省略函数名称</p><ol><li>匿名函数在栈追踪中不会显示出有意义的函数名称，使得调用很困难。</li><li>如果没有函数名，需要引用的时候就只能使用已经过期的arguments.callee引用，比如在递归中</li><li>匿名函数省略了对于代码的可读性/可理解性很重要的函数名</li></ol><p>行内函数表达式</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">setTimeout( function timeoutHandler()&#123;    console.log(&#39;aaa&#39;);&#125;,1000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="立即执行函数表达式"><a href="#立即执行函数表达式" class="headerlink" title="立即执行函数表达式"></a>立即执行函数表达式</h2><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var a &#x3D; 2;(function foo()&#123;    var a &#x3D; 3;    console.log( a ); &#x2F;&#x2F; 3&#125;)();console.log( a ); &#x2F;&#x2F; 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个（）将函数变成了表达式，第二个（）执行了这个函数</p><blockquote><p>IIFE代表立即执行函数表达式</p></blockquote><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var a &#x3D; 2;(function IIFE()&#123; &#x2F;&#x2F;传统的形式    var a &#x3D; 3;    console.log( a ); &#x2F;&#x2F; 3&#125;)();console.log( a ); &#x2F;&#x2F; 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>==以上两种写法功能上是一样的==</p><p>用途：</p><p>可以传参数进去</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var a &#x3D; 2;(function IIFE(global)&#123; &#x2F;&#x2F;传统的形式    var a &#x3D; 3;    console.log( a ); &#x2F;&#x2F; 3    console.log( global.a ); &#x2F;&#x2F; 3&#125;)(window);console.log( a ); &#x2F;&#x2F; 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h2><p>除了函数能产生一个作用域气泡，for循环，if，with,try/catch等都会产生一个作用域气泡。</p><p>块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块，通常指{..}的内部</p><blockquote><p>var</p></blockquote><p>其实val一个变量无论在什么地方，都会提升到全局变量，把它写在作用域内部，只是为了风格更易读而伪装出的形式上的块作用域，如果使用这种，要确保在其他地方没有重复的使用同名的变量。</p><blockquote><p>let</p></blockquote><p>ES6引入了关键字let，可以将变量绑定到所在的任意作用域中，为其声明的变量隐式的劫持了所在的块作用域。</p><p>let进行声明的不会在代码在块作用域中进行提升，声明的代码在运行前，声明并不‘存在’。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#123;    console.log(a); &#x2F;&#x2F; ReferenceError(没有找到)    let a &#x3D; 2;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>let 声明附属于一个新的作用域而不是当前函数作用域（也不属于全局作用域）</p><blockquote><p>const</p></blockquote><p>同样可以用来创建块作用域变量，但其值是固定的，之后的任何试图修改值的操作都会引起错误。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var foo &#x3D; true;if(foo)&#123;    var a &#x3D; 2;    const b &#x3D; 3;    a &#x3D; 4; &#x2F;&#x2F; 正确    b &#x3D; 6; &#x2F;&#x2F; 错误&#125;console.log(a) &#x2F;&#x2F; 4console.log(b) &#x2F;&#x2F; ReferenceError<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>任何声明在某个作用域内部的变量，都将附属于这个作用域</p><h2 id="小思考"><a href="#小思考" class="headerlink" title="小思考"></a>小思考</h2><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">a &#x3D; 2;val a;console.log(a);&#x2F;&#x2F;2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出2的原因是：声明会提升，也就是先声明再赋值，在执行查询</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">console.log(a); &#x2F;&#x2F; undefindvar a &#x3D; 2;&#x2F;&#x2F; 执行顺序val a;console.log(a); &#x2F;&#x2F; undefinda &#x3D; 2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原因：函数声明会提升，然后执行查询，此时是没有赋值的，所以是undefind</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">foo(); &#x2F;&#x2F; 不是ReferenceError，而是TypeEerrorvar foo &#x3D; funcyion bar() &#123;    &#x2F;&#x2F;...&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原因：函数表达式不会被提升</p><blockquote><p>函数优先</p></blockquote><p>函数声明和变量声明都会被提升，但是一个值得注意的细节是函数会被首先提升，然后才是变量。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">foo(); &#x2F;&#x2F;1var foo;function foo() &#123;    console.log(1);&#125;foo &#x3D; function() &#123;    console.log(2);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出的是1而不是2是因为函数声明先被提升到上面，然后在执行。var foo 尽管出现在function foo… 之前，但是他是重复声明会被忽略。</p><blockquote><p>后面的声明会覆盖掉前面的声明</p></blockquote><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">foo(); &#x2F;&#x2F;3function foo() &#123;    console.log(1);&#125;var foo &#x3D; function() &#123;    console.log(2);&#125;function foo() &#123;    console.log(3);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅拷贝与深拷贝</title>
      <link href="/2021/07/17/js-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2021/07/17/js-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h2 id="浅拷贝与深拷贝-深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的"><a href="#浅拷贝与深拷贝-深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的" class="headerlink" title="浅拷贝与深拷贝 (深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的)"></a>浅拷贝与深拷贝 (深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的)</h2><p><strong>浅拷贝只复制指向某个对象的指针而不复制对象本身，新旧对象还是共享同一块内存。</strong><br><strong>但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</strong></p><h2 id="赋值和浅拷贝的区别"><a href="#赋值和浅拷贝的区别" class="headerlink" title="赋值和浅拷贝的区别"></a>赋值和浅拷贝的区别</h2><ul><li>当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。</li><li>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即：默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。</li></ul><h2 id="浅拷贝的实现方式"><a href="#浅拷贝的实现方式" class="headerlink" title="浅拷贝的实现方式"></a>浅拷贝的实现方式</h2><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript"> var obj1 &#x3D; &#123;    &#39;name&#39; : &#39;zhangsan&#39;,    &#39;age&#39; :  &#39;18&#39;,    &#39;language&#39; : [1,[2,3],[4,5]],  &#x2F;&#x2F;Array&#125;; var obj3 &#x3D; shallowCopy(obj1); obj3.name &#x3D; &quot;lisi&quot;; obj3.language[1] &#x3D; [&quot;二&quot;,&quot;三&quot;]; function shallowCopy(src) &#123;    var dst &#x3D; &#123;&#125;;    for (var prop in src) &#123;        if (src.hasOwnProperty(prop)) &#123;            dst[prop] &#x3D; src[prop];        &#125;    &#125;    return dst;&#125;console.log(&#39;obj1&#39;,obj1)console.log(&#39;obj3&#39;,obj3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>.Object.assign()</strong><br>Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var obj &#x3D; &#123; a: &#123;a: &quot;kobe&quot;, b: 39&#125; &#125;;var initalObj &#x3D; Object.assign(&#123;&#125;, obj);initalObj.a.a &#x3D; &quot;wade&quot;;console.log(obj.a.a); &#x2F;&#x2F;wade<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  <em>注意：当object只有一层的时候，是深拷贝</em></p><p><strong>Array.prototype.concat()</strong></p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let arr &#x3D; [1, 3, &#123;    username: &#39;kobe&#39;    &#125;];let arr2&#x3D;arr.concat();arr2[2].username &#x3D; &#39;wade&#39;;console.log(arr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="深拷贝的实现方式"><a href="#深拷贝的实现方式" class="headerlink" title="深拷贝的实现方式"></a>深拷贝的实现方式</h2><p><strong>1.JSON.parse(JSON.stringify())</strong></p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let arr &#x3D; [1, 3, &#123;  username: &#39; kobe&#39;&#125;];let arr4 &#x3D; JSON.parse(JSON.stringify(arr));arr4[2].username &#x3D; &#39;duncan&#39;;console.log(arr, arr4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>原理： 用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。</em><br><strong>这种方法虽然可以实现数组或对象深拷贝,但不能处理函数</strong></p><p><strong>2.手写递归方法</strong></p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">    &#x2F;&#x2F;定义检测数据类型的功能函数function checkedType(target) &#123;  return Object.prototype.toString.call(target).slice(8, -1)&#125;&#x2F;&#x2F;实现深度克隆---对象&#x2F;数组function clone(target) &#123;  &#x2F;&#x2F;判断拷贝的数据类型  &#x2F;&#x2F;初始化变量result 成为最终克隆的数据  let result, targetType &#x3D; checkedType(target)  if (targetType &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;    result &#x3D; &#123;&#125;  &#125; else if (targetType &#x3D;&#x3D;&#x3D; &#39;Array&#39;) &#123;    result &#x3D; []  &#125; else &#123;    return target  &#125;  &#x2F;&#x2F;遍历目标数据  for (let i in target) &#123;    &#x2F;&#x2F;获取遍历数据结构的每一项值。    let value &#x3D; target[i]    &#x2F;&#x2F;判断目标结构里的每一值是否存在对象&#x2F;数组    if (checkedType(value) &#x3D;&#x3D;&#x3D; &#39;Object&#39; ||      checkedType(value) &#x3D;&#x3D;&#x3D; &#39;Array&#39;) &#123; &#x2F;&#x2F;对象&#x2F;数组里嵌套了对象&#x2F;数组      &#x2F;&#x2F;继续遍历获取到value值      result[i] &#x3D; clone(value)    &#125; else &#123; &#x2F;&#x2F;获取到value值是基本的数据类型或者是函数。      result[i] &#x3D; value;    &#125;  &#125;  return result&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.函数库lodash</strong><br>该函数库也有提供_.cloneDeep用来做 Deep Copy</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var _ &#x3D; require(&#39;lodash&#39;);var obj1 &#x3D; &#123;    a: 1,    b: &#123; f: &#123; g: 1 &#125; &#125;,    c: [1, 2, 3]&#125;;var obj2 &#x3D; _.cloneDeep(obj1);console.log(obj1.b.f &#x3D;&#x3D;&#x3D; obj2.b.f);&#x2F;&#x2F; false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js数据类型</title>
      <link href="/2021/07/17/js-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2021/07/17/js-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>基本数据类型、引用数据类型</p></blockquote><p>ECMAScript包括两个不同类型的值：基本数据类型和引用数据类型。<br>基本数据类型指的是简单的数据段，引用数据类型指的是有多个值构成的对象。<br>当我们把变量赋值给一个变量时，解析器首先要确认的就是这个值是基本类型值还是引用类型值。</p><h2 id="常见的基本数据类型"><a href="#常见的基本数据类型" class="headerlink" title="常见的基本数据类型"></a>常见的基本数据类型</h2><p>Number、String 、Boolean、Null和Undefined。基本数据类型是按值访问的，因为可以直接操作保存在变量中的实际值。示例：<br>　　var a = 10;<br>　　var b = a;<br>　　b = 20;<br>　　console.log(a); // 10值<br>　　上面，b获取的是a值得一份拷贝，虽然，两个变量的值相等，但是两个变量保存了两个不同的基本数据类型值。<br>　　b只是保存了a复制的一个副本。所以，b的改变，对a没有影响。</p><h2 id="引用类型数据"><a href="#引用类型数据" class="headerlink" title="引用类型数据"></a>引用类型数据</h2><p>  也就是对象类型Object type，比如：Object 、Array 、Function 、Data等。<br>　　javascript的引用数据类型是保存在堆内存中的对象。<br>　　与其他语言的不同是，你不可以直接访问堆内存空间中的位置和操作堆内存空间。只能操作对象在栈内存中的引用地址。<br>　　所以，引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存中堆内存中的对象。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var obj1 &#x3D; new Object();var obj2 &#x3D; obj1;obj2.name &#x3D; &quot;我有名字了&quot;;console.log(obj1.name); &#x2F;&#x2F; 我有名字了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>　　说明这两个引用数据类型指向了同一个堆内存对象。obj1赋值给onj2，实际上这个堆内存对象在栈内存的引用地址复制了一份给了obj2，<br>　　但是实际上他们共同指向了同一个堆内存对象。实际上改变的是堆内存对象。</p><h2 id="查看一个值的是数据类型"><a href="#查看一个值的是数据类型" class="headerlink" title="查看一个值的是数据类型"></a>查看一个值的是数据类型</h2><blockquote><p>js中变量是没有数据类型的，只有值才有。变量可以持有任何数据类型的值。</p></blockquote><p>typeof 用来查看变量的类型会返回一字符串：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">typeof 1; &#x2F;&#x2F; &quot;number&quot;typeof &#39;1&#39;; &#x2F;&#x2F; &quot;string&quot;typeof undefined; &#x2F;&#x2F; &quot;undefined&quot;typeof true; &#x2F;&#x2F; &quot;boolean&quot;typeof &#123;a:1&#125;; &#x2F;&#x2F; &quot;object&quot;typeod Symbol(); &#x2F;&#x2F;&#39;symbo&#39;typeof null; &#x2F;&#x2F; &#39;object&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>null 使用typeof 返回的类型是object，所以查看是不是null是需要用复合条件来检测</p></blockquote><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var a &#x3D; null(!a &amp;&amp; typeof a &#x3D;&#x3D;&#x3D;&quot;object&quot;); &#x2F;&#x2F;trueJSON.stringify(a) &#x3D;&#x3D;&#x3D; &#39;null&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结区别"><a href="#总结区别" class="headerlink" title="总结区别"></a>总结区别</h2><h3 id="声明变量时不同的内存分配："><a href="#声明变量时不同的内存分配：" class="headerlink" title="声明变量时不同的内存分配："></a>声明变量时不同的内存分配：</h3><p>　　1）原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。<br>　　　　这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – 栈中。这样存储便于迅速查寻变量的值。<br>　　2）引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。<br>　　　  这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。<br>　　　  地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。</p><h3 id="不同的内存分配机制也带来了不同的访问机制"><a href="#不同的内存分配机制也带来了不同的访问机制" class="headerlink" title="不同的内存分配机制也带来了不同的访问机制"></a>不同的内存分配机制也带来了不同的访问机制</h3><p>　　　<br>　　1）在javascript中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，<br>　　　　首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的按引用访问。<br>　　2）而原始类型的值则是可以直接访问到的。<br>　　<br>　　c 复制变量时的不同<br>　　<br>　　1）原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的value而已。<br>　　2）引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，<br>　　　　也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。<br>　　　　（这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了）。多了一个指针　</p><h3 id="参数传递的不同（把实参复制给形参的过程）"><a href="#参数传递的不同（把实参复制给形参的过程）" class="headerlink" title="参数传递的不同（把实参复制给形参的过程）"></a>参数传递的不同（把实参复制给形参的过程）</h3><p>　　首先我们应该明确一点：ECMAScript中所有函数的参数都是按值来传递的。<br>　　但是为什么涉及到原始类型与引用类型的值时仍然有区别呢？还不就是因为内存分配时的差别。 　<br>　　1）原始值：只是把变量里的值传递给参数，之后参数和这个变量互不影响。<br>　　2）引用值：对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！<br>　　　　因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown 写法备注</title>
      <link href="/2021/07/17/remarks/"/>
      <url>/2021/07/17/remarks/</url>
      
        <content type="html"><![CDATA[<blockquote><p>标题</p></blockquote><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><blockquote><p>无序列表</p></blockquote><ul><li>1</li></ul><ul><li>2</li></ul><ul><li>3</li></ul><blockquote><p>有序列表</p></blockquote><ol><li>列表  </li><li>列表</li><li>列表</li></ol><blockquote><p>分割线</p></blockquote><hr><hr><blockquote><p>代码块 ```</p></blockquote><blockquote><p>文本样式</p></blockquote><p>  <em>字体倾斜</em>                &gt;        <em>字体倾斜</em><br>  <em>字体倾斜</em><br>  <strong>字体加粗</strong>              &gt;        <strong>字体加粗</strong><br>  <strong>字体加粗</strong><br>  <del>字体删除</del>              &gt;        <del>字体删除</del><br> ! 符号与字体之间不要有空格</p>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作用域是什么-词法作用域</title>
      <link href="/2021/07/08/js-%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88-%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2021/07/08/js-%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88-%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="作用域是什么"><a href="#作用域是什么" class="headerlink" title="作用域是什么"></a>作用域是什么</h2><ul><li>存储变量的规则<br>存储在哪里？怎么获取？</li></ul><p>var a = 2</p><p>为一个变量分配内存，名字为a，将值为2保存进这个变量（不完全正确）</p><ol><li>var a 编译器会询问作用域是否已经存在这样一个变量存在于同一个作用域内，如果有编译器会忽略该声明，继续编译，如果没有，他会要求作用域在当前作用域内声明一个新的变量，并命名为a。</li><li>接下载编译器会为引擎生成运行时所需要的代码，这些代码被用来处理a = 2 的操作，引擎运行时会询问作用域当前作用域集合中是否存在叫做a的变量，如果有，就是用该变量，如果没有会再向再外层的作用域询问，最终会到全局作用域。找到后会将2赋值给它，找不到就会抛出异常</li></ol><blockquote><p>总结：变量的赋值操作会执行两个动作，编译器在作用域中声明，运行时引擎会查找该变量并进行赋值。</p></blockquote><blockquote><p>编译器：LHS查询   查找类型RHS（LHS，RHS），当变量出现在赋值操作的左侧时进行进行LHS查询，出现在右侧时进行RHS查询。</p></blockquote><p>console.log（a） 执行的是RHS，要去找a的值；</p><p>a = 2 执行的是LHS 要为=2找到赋值的目标。</p><p>LHS：赋值操作的目标是谁；目的是对变量进行赋值</p><p>RHS：谁是赋值操作的源头；目的是获取变量的值</p><p>ReferenceError 这个错误是找不到定义的变量</p><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>作用域有两种主要的工作模型：词法作用域，动态作用域。</p><p>词法作用域：定义在词法阶段的作用域，就是由你写代码时将变量和块作用域写在哪里决定的，因此词法解析器处理代码时会保持作用域不变（大部分情况下是这样）</p><p>词法欺骗：</p><blockquote><p>eval( )</p></blockquote><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function foo(str, a) &#123;    eval(str); &#x2F;&#x2F; 欺骗    console.log(a, b);&#125;var b &#x3D; 2;foo(&#39;val b &#x3D; 3;&#39;, 1); &#x2F;&#x2F; 1, 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>with(){}</p></blockquote><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function foo(obj) &#123;    with(obj)&#123;        a &#x3D; 2;    &#125;&#125;var o1 &#x3D; &#123;    a: 3&#125;var o2 &#x3D; &#123;    a: 3&#125;foo(o1);console.log(o1.a) &#x2F;&#x2F; 2foo(o2);console.log(o2.a) &#x2F;&#x2F; undefinedconsole.log(a) &#x2F;&#x2F; 2  &#x3D;&#x3D;a被泄漏到全局上面去了&#x3D;&#x3D;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结<br>eval（）函数如果接受了一个或多个声明的代码，就会修改其所处的词法作用域；<br>with声明实际上是根据传递给他的对象凭空创建了一个全新的词法作用域</p></blockquote><p>eval，with会降低性能，所以不建议使用</p>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
