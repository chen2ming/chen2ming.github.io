{"meta":{"title":"chenMing","subtitle":"(ง •̀_•́)ง","description":"技术博客","author":"chenMing","url":"http://example.com","root":"/"},"pages":[{"title":"关于我","date":"2021-07-19T08:47:46.000Z","updated":"2021-07-20T01:16:24.063Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"2019年6月份毕业来到杭州参加了第一份工作，从事前端开发。 学习永无止境、宜早不宜迟！ 生活就是要快乐，快乐就是要钓鱼！"},{"title":"友情链接","date":"2021-07-19T08:16:44.000Z","updated":"2021-07-20T01:07:45.456Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-07-19T08:28:19.000Z","updated":"2021-07-20T01:07:45.426Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-07-19T08:44:20.000Z","updated":"2021-07-20T01:07:45.456Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"async、await","slug":"async、await","date":"2021-07-20T07:16:41.199Z","updated":"2021-07-20T07:31:03.325Z","comments":true,"path":"2021/07/20/async、await/","link":"","permalink":"http://example.com/2021/07/20/async%E3%80%81await/","excerpt":"","text":"async 和 await 在干什么任意一个名称都是有意义的，先从字面意思来理解。async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。 async这个问题的关键在于，async 函数是怎么处理它的返回值的！我们当然希望它能直接通过 return 语句返回我们想要的值，但是如果真是这样，似乎就没 await 什么事了。所以，写段代码来试试，看它到底会返回什么： async function testAsync() &#123; return &quot;hello async&quot;; &#125; const result &#x3D; testAsync(); console.log(result); &#x2F;&#x2F; Promise &#123; &#39;hello async&#39; &#125; ——输出的是一个 Promise 对象。 所以，async 函数返回的是一个 Promise 对象。从文档中也可以得到这个信息。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。 Promise.resolve(x) 可以看作是 new Promise(resolve =&gt; resolve(x)) 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。 async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，我们当然应该用原来的方式：then() 链来处理这个 Promise 对象，就像这样 testAsync().then(v &#x3D;&gt; &#123; console.log(v); &#x2F;&#x2F; 输出 hello async &#125;); await一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。 因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行 function getSomething() &#123; return &quot;something&quot;; &#125; async function testAsync() &#123; return Promise.resolve(&quot;hello async&quot;); &#125; async function test() &#123; const v1 &#x3D; await getSomething(); const v2 &#x3D; await testAsync(); console.log(v1, v2); &#125; test(); await 等到了要等的，然后呢await 等到了它要等的东西，一个 Promise 对象，或者其它值，然后呢？我不得不先说，await 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西。 如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。 如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。 async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。 async/await -&gt; promisefunction step1(n) &#123; console.log(&#96;step1 with $&#123;n&#125;&#96;); return takeLongTime(n); &#125; function step2(m, n) &#123; console.log(&#96;step2 with $&#123;m&#125; and $&#123;n&#125;&#96;); return takeLongTime(m + n); &#125; function step3(k, m, n) &#123; console.log(&#96;step3 with $&#123;k&#125;, $&#123;m&#125; and $&#123;n&#125;&#96;); return takeLongTime(k + m + n); &#125; &#x2F;&#x2F; asyne&#x2F;await async function doIt() &#123; console.time(&quot;doIt&quot;); const time1 &#x3D; 300; const time2 &#x3D; await step1(time1); const time3 &#x3D; await step2(time1, time2); const result &#x3D; await step3(time1, time2, time3); console.log(&#96;result is $&#123;result&#125;&#96;); console.timeEnd(&quot;doIt&quot;); &#125; doIt(); &#x2F;&#x2F; promise function doIt() &#123; console.time(&quot;doIt&quot;); const time1 &#x3D; 300; step1(time1) .then(time2 &#x3D;&gt; &#123; return step2(time1, time2) .then(time3 &#x3D;&gt; [time1, time2, time3]); &#125;) .then(times &#x3D;&gt; &#123; const [time1, time2, time3] &#x3D; times; return step3(time1, time2, time3); &#125;) .then(result &#x3D;&gt; &#123; console.log(&#96;result is $&#123;result&#125;&#96;); console.timeEnd(&quot;doIt&quot;); &#125;); &#125; doIt(); 看起来更像是同步操作","categories":[],"tags":[{"name":"async、await","slug":"async、await","permalink":"http://example.com/tags/async%E3%80%81await/"}]},{"title":"Promise","slug":"promise","date":"2021-07-20T06:58:07.008Z","updated":"2021-07-20T07:14:32.763Z","comments":true,"path":"2021/07/20/promise/","link":"","permalink":"http://example.com/2021/07/20/promise/","excerpt":"","text":"promise是什么？1、主要用于异步计算2、可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果3、可以在对象之间传递和操作promise，帮助我们处理队列 异步回调的问题 之前处理异步是通过纯粹的回调函数的形式进行处理 很容易进入到回调地狱中，剥夺了函数return的能力 问题可以解决，但是难以读懂，维护困难 稍有不慎就会踏入回调地狱 - 嵌套层次深，不好维护 new Promisenew Promise( function (resolve, reject) &#123; &#x2F;&#x2F; 一段耗时的异步操作 resolve(&#39;成功&#39;) &#x2F;&#x2F; 数据处理完成 &#x2F;&#x2F; reject(&#39;失败&#39;) &#x2F;&#x2F; 数据处理出错 &#125; ).then( (res) &#x3D;&gt; &#123;console.log(res)&#125;, &#x2F;&#x2F; 成功 (err) &#x3D;&gt; &#123;console.log(err)&#125; &#x2F;&#x2F; 失败 ) Promise.all() 批量执行Promise.all([p1, p2, p3])用于将多个promise实例，包装成一个新的Promise实例，返回的实例就是普通的promise它接收一个数组作为参数数组里可以是Promise对象，也可以是别的值，只有Promise会等待状态改变当所有的子Promise都完成，该Promise完成，返回值是全部值得数组有任何一个失败，该Promise失败，返回值是第一个失败的子Promise结果 &#x2F;&#x2F;切菜 function cutUp()&#123; console.log(&#39;开始切菜。&#39;); var p &#x3D; new Promise(function(resolve, reject)&#123; &#x2F;&#x2F;做一些异步操作 setTimeout(function()&#123; console.log(&#39;切菜完毕！&#39;); resolve(&#39;切好的菜&#39;); &#125;, 1000); &#125;); return p; &#125; &#x2F;&#x2F;烧水 function boil()&#123; console.log(&#39;开始烧水。&#39;); var p &#x3D; new Promise(function(resolve, reject)&#123; &#x2F;&#x2F;做一些异步操作 setTimeout(function()&#123; console.log(&#39;烧水完毕！&#39;); resolve(&#39;烧好的水&#39;); &#125;, 1000); &#125;); return p; &#125; Promise.all([cutUp(), boil()]) .then((result) &#x3D;&gt; &#123; console.log(&#39;准备工作完毕&#39;); console.log(result); &#125;) Promise.race() 它有任意一个完成就算完成let p1 &#x3D; new Promise(resolve &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; resolve(&#39;I\\&#96;m p1 &#39;) &#125;, 1000) &#125;); let p2 &#x3D; new Promise(resolve &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; resolve(&#39;I\\&#96;m p2 &#39;) &#125;, 2000) &#125;); Promise.race([p1, p2]) .then(value &#x3D;&gt; &#123; console.log(value) &#125;) 回调地狱和promise对比 回调地狱&#x2F;*** 第一步：找到北京的id 第二步：根据北京的id -&gt; 找到北京公司的id 第三步：根据北京公司的id -&gt; 找到北京公司的详情 目的：模拟链式调用、回调地狱 ***&#x2F; &#x2F;&#x2F; 回调地狱 &#x2F;&#x2F; 请求第一个API: 地址在北京的公司的id $.ajax(&#123; url: &#39;https:&#x2F;&#x2F;www.easy-mock.com&#x2F;mock&#x2F;5a52256ad408383e0e3868d7&#x2F;lagou&#x2F;city&#39;, success (resCity) &#123; let findCityId &#x3D; resCity.filter(item &#x3D;&gt; &#123; if (item.id &#x3D;&#x3D; &#39;c1&#39;) &#123; return item &#125; &#125;)[0].id $.ajax(&#123; &#x2F;&#x2F; 请求第二个API: 根据上一个返回的在北京公司的id “findCityId”，找到北京公司的第一家公司的id url: &#39;https:&#x2F;&#x2F;www.easy-mock.com&#x2F;mock&#x2F;5a52256ad408383e0e3868d7&#x2F;lagou&#x2F;position-list&#39;, success (resPosition) &#123; let findPostionId &#x3D; resPosition.filter(item &#x3D;&gt; &#123; if(item.cityId &#x3D;&#x3D; findCityId) &#123; return item &#125; &#125;)[0].id &#x2F;&#x2F; 请求第三个API: 根据上一个API的id(findPostionId)找到具体公司，然后返回公司详情 $.ajax(&#123; url: &#39;https:&#x2F;&#x2F;www.easy-mock.com&#x2F;mock&#x2F;5a52256ad408383e0e3868d7&#x2F;lagou&#x2F;company&#39;, success (resCom) &#123; let comInfo &#x3D; resCom.filter(item &#x3D;&gt; &#123; if (findPostionId &#x3D;&#x3D; item.id) &#123; return item &#125; &#125;)[0] console.log(comInfo) &#125; &#125;) &#125; &#125;) &#125; &#125;) &#x2F;&#x2F; Promise 写法 &#x2F;&#x2F; 第一步：获取城市列表 const cityList &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123; $.ajax(&#123; url: &#39;https:&#x2F;&#x2F;www.easy-mock.com&#x2F;mock&#x2F;5a52256ad408383e0e3868d7&#x2F;lagou&#x2F;city&#39;, success (res) &#123; resolve(res) &#125; &#125;) &#125;) &#x2F;&#x2F; 第二步：找到城市是北京的id cityList.then(res &#x3D;&gt; &#123; let findCityId &#x3D; res.filter(item &#x3D;&gt; &#123; if (item.id &#x3D;&#x3D; &#39;c1&#39;) &#123; return item &#125; &#125;)[0].id findCompanyId().then(res &#x3D;&gt; &#123; &#x2F;&#x2F; 第三步（2）：根据北京的id -&gt; 找到北京公司的id let findPostionId &#x3D; res.filter(item &#x3D;&gt; &#123; if(item.cityId &#x3D;&#x3D; findCityId) &#123; return item &#125; &#125;)[0].id &#x2F;&#x2F; 第四步（2）：传入公司的id companyInfo(findPostionId) &#125;) &#125;) &#x2F;&#x2F; 第三步（1）：根据北京的id -&gt; 找到北京公司的id function findCompanyId () &#123; let aaa &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123; $.ajax(&#123; url: &#39;https:&#x2F;&#x2F;www.easy-mock.com&#x2F;mock&#x2F;5a52256ad408383e0e3868d7&#x2F;lagou&#x2F;position-list&#39;, success (res) &#123; resolve(res) &#125; &#125;) &#125;) return aaa &#125; &#x2F;&#x2F; 第四步：根据上一个API的id(findPostionId)找到具体公司，然后返回公司详情 function companyInfo (id) &#123; let companyList &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123; $.ajax(&#123; url: &#39;https:&#x2F;&#x2F;www.easy-mock.com&#x2F;mock&#x2F;5a52256ad408383e0e3868d7&#x2F;lagou&#x2F;company&#39;, success (res) &#123; let comInfo &#x3D; res.filter(item &#x3D;&gt; &#123; if (id &#x3D;&#x3D; item.id) &#123; return item &#125; &#125;)[0] console.log(comInfo) &#125; &#125;) &#125;) &#125;","categories":[],"tags":[]},{"title":"路由模式","slug":"路由模式","date":"2021-07-20T06:49:57.663Z","updated":"2021-07-20T06:55:45.043Z","comments":true,"path":"2021/07/20/路由模式/","link":"","permalink":"http://example.com/2021/07/20/%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"路由模式 hash模式这里的 hash 就是指 url 尾巴后的 # 号以及后面的字符。这里的 # 和 css 里的 # 是一个意思。hash 也 称作 锚点，本身是用来做页面定位的，她可以使对应 id 的元素显示在可视区域内。 由于 hash 值变化不会导致浏览器向服务器发出请求，而且 hash 改变会触发 hashchange 事件，浏览器的进后退也能对其进行控制，所以人们在 html5 的 history 出现前，基本都是使用 hash 来实现前端路由的。 window.location.hash &#x3D; &#39;qq&#39; &#x2F;&#x2F; 设置 url 的 hash，会在当前url后加上 &#39;#qq&#39; var hash &#x3D; window.location.hash &#x2F;&#x2F; &#39;#qq&#39; window.addEventListener(&#39;hashchange&#39;, function()&#123; &#x2F;&#x2F; 监听hash变化，点击浏览器的前进后退会触发 &#125;) history模式已经有 hash 模式了，而且 hash 能兼容到IE8， history 只能兼容到 IE10，为什么还要搞个 history 呢？首先，hash 本来是拿来做页面定位的，如果拿来做路由的话，原来的锚点功能就不能用了。其次，hash 的传参是基于 url 的，如果要传递复杂的数据，会有体积的限制，而 history 模式不仅可以在url里放参数，还可以将数据存放在一个特定的对象中。 window.history.pushState(state, title, url) &#x2F;&#x2F; state：需要保存的数据，这个数据在触发popstate事件时，可以在event.state里获取 &#x2F;&#x2F; title：标题，基本没用，一般传 null &#x2F;&#x2F; url：设定新的历史记录的 url。新的 url 与当前 url 的 origin 必须是一樣的，否则会抛出错误。url可以是绝对路径，也可以是相对路径。 &#x2F;&#x2F;如 当前url是 https:&#x2F;&#x2F;www.baidu.com&#x2F;a&#x2F;,执行history.pushState(null, null, &#39;.&#x2F;qq&#x2F;&#39;)，则变成 https:&#x2F;&#x2F;www.baidu.com&#x2F;a&#x2F;qq&#x2F;， &#x2F;&#x2F;执行history.pushState(null, null, &#39;&#x2F;qq&#x2F;&#39;)，则变成 https:&#x2F;&#x2F;www.baidu.com&#x2F;qq&#x2F; window.history.replaceState(state, title, url) &#x2F;&#x2F; 与 pushState 基本相同，但她是修改当前历史记录，而 pushState 是创建新的历史记录 window.addEventListener(&quot;popstate&quot;, function() &#123; &#x2F;&#x2F; 监听浏览器前进后退事件，pushState 与 replaceState 方法不会触发 &#125;); window.history.back() &#x2F;&#x2F; 后退 window.history.forward() &#x2F;&#x2F; 前进 window.history.go(1) &#x2F;&#x2F; 前进一步，-2为后退两步，window.history.lengthk可以查看当前历史堆栈中页面的数量","categories":[],"tags":[{"name":"router","slug":"router","permalink":"http://example.com/tags/router/"}]},{"title":"浅拷贝与深拷贝","slug":"js-深拷贝与浅拷贝","date":"2021-07-20T01:07:45.425Z","updated":"2021-07-20T07:32:49.527Z","comments":true,"path":"2021/07/20/js-深拷贝与浅拷贝/","link":"","permalink":"http://example.com/2021/07/20/js-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"浅拷贝与深拷贝 (深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的)浅拷贝只复制指向某个对象的指针而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。 赋值和浅拷贝的区别 当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即：默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。 浅拷贝的实现方式 var obj1 &#x3D; &#123; &#39;name&#39; : &#39;zhangsan&#39;, &#39;age&#39; : &#39;18&#39;, &#39;language&#39; : [1,[2,3],[4,5]], &#x2F;&#x2F;Array &#125;; var obj3 &#x3D; shallowCopy(obj1); obj3.name &#x3D; &quot;lisi&quot;; obj3.language[1] &#x3D; [&quot;二&quot;,&quot;三&quot;]; function shallowCopy(src) &#123; var dst &#x3D; &#123;&#125;; for (var prop in src) &#123; if (src.hasOwnProperty(prop)) &#123; dst[prop] &#x3D; src[prop]; &#125; &#125; return dst; &#125; console.log(&#39;obj1&#39;,obj1) console.log(&#39;obj3&#39;,obj3) .Object.assign()Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。 var obj &#x3D; &#123; a: &#123;a: &quot;kobe&quot;, b: 39&#125; &#125;; var initalObj &#x3D; Object.assign(&#123;&#125;, obj); initalObj.a.a &#x3D; &quot;wade&quot;; console.log(obj.a.a); &#x2F;&#x2F;wade 注意：当object只有一层的时候，是深拷贝 Array.prototype.concat() let arr &#x3D; [1, 3, &#123; username: &#39;kobe&#39; &#125;]; let arr2&#x3D;arr.concat(); arr2[2].username &#x3D; &#39;wade&#39;; console.log(arr); 深拷贝的实现方式1.JSON.parse(JSON.stringify()) let arr &#x3D; [1, 3, &#123; username: &#39; kobe&#39; &#125;]; let arr4 &#x3D; JSON.parse(JSON.stringify(arr)); arr4[2].username &#x3D; &#39;duncan&#39;; console.log(arr, arr4) 原理： 用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。这种方法虽然可以实现数组或对象深拷贝,但不能处理函数 2.手写递归方法 &#x2F;&#x2F;定义检测数据类型的功能函数 function checkedType(target) &#123; return Object.prototype.toString.call(target).slice(8, -1) &#125; &#x2F;&#x2F;实现深度克隆---对象&#x2F;数组 function clone(target) &#123; &#x2F;&#x2F;判断拷贝的数据类型 &#x2F;&#x2F;初始化变量result 成为最终克隆的数据 let result, targetType &#x3D; checkedType(target) if (targetType &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123; result &#x3D; &#123;&#125; &#125; else if (targetType &#x3D;&#x3D;&#x3D; &#39;Array&#39;) &#123; result &#x3D; [] &#125; else &#123; return target &#125; &#x2F;&#x2F;遍历目标数据 for (let i in target) &#123; &#x2F;&#x2F;获取遍历数据结构的每一项值。 let value &#x3D; target[i] &#x2F;&#x2F;判断目标结构里的每一值是否存在对象&#x2F;数组 if (checkedType(value) &#x3D;&#x3D;&#x3D; &#39;Object&#39; || checkedType(value) &#x3D;&#x3D;&#x3D; &#39;Array&#39;) &#123; &#x2F;&#x2F;对象&#x2F;数组里嵌套了对象&#x2F;数组 &#x2F;&#x2F;继续遍历获取到value值 result[i] &#x3D; clone(value) &#125; else &#123; &#x2F;&#x2F;获取到value值是基本的数据类型或者是函数。 result[i] &#x3D; value; &#125; &#125; return result &#125; 3.函数库lodash该函数库也有提供_.cloneDeep用来做 Deep Copy var _ &#x3D; require(&#39;lodash&#39;); var obj1 &#x3D; &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [1, 2, 3] &#125;; var obj2 &#x3D; _.cloneDeep(obj1); console.log(obj1.b.f &#x3D;&#x3D;&#x3D; obj2.b.f); &#x2F;&#x2F; false","categories":[],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://example.com/tags/javaScript/"}]},{"title":"闭包","slug":"js-闭包","date":"2021-07-20T01:07:45.425Z","updated":"2021-07-20T07:33:08.750Z","comments":true,"path":"2021/07/20/js-闭包/","link":"","permalink":"http://example.com/2021/07/20/js-%E9%97%AD%E5%8C%85/","excerpt":"","text":"闭包是基于词法作用域书写代码时所产生的自然结果 闭包的产生：函数在被定义的地方之外被执行就会产生闭包！！！ function foo() &#123; var a &#x3D; 2; function bar()&#123; console.log(a); &#125; return bar; &#125; var bza &#x3D; foo(); baz(); &#x2F;&#x2F; 2 这就是闭包！ 通常情况下foo执行之后整个内部作用域都会被销毁，因为引擎会销毁不再使用的空间来释放内存空间。 然而闭包会阻止这一情况的发生，会让作用域依然存在，因为bar函数还在使用foo这个作用域，需要给bar在任何时候执行提供支持。所以foo的作用域不会被销毁，bar依然持有对该作用域的引用，这个引用就是闭包！ ==无论通过何种手段将内部函数传递到所在的词法作用域以外，他都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。== function wait(message)&#123; setTimeout( function timer() &#123; console.log(message); &#125;,1000) &#125; wait(&#39;hello&#39;) wait执行1000毫秒以后，他的内部作用域并不会消失，还能保持message的引用。 ==只要是使用了回调函数，实际上就是在使用闭包。== 闭包和循环for(var i &#x3D; 1;i &lt;&#x3D; 5; i++;)&#123; setTimeout(function timer() &#123; console.log(i); &#125;,1*1000) &#125; &#x2F;&#x2F; 每秒一次输出五个6 这个循环终止的条件是6.条件首次成立的时候i === 6，因此输出的显示是循环结束时i的值。因为这里所用的i，是同一个作用域下的i，所有的函数共享一个i。 for(var i &#x3D; 1;i &lt;&#x3D; 5; i++;)&#123; (function() &#123; setTimeout(function timer() &#123; console.log(i); &#125;,1*1000) &#125;(); &#125; &#x2F;&#x2F;这样也不行 因为我们的IIFE的作用域是空的，我们使用的依然是外层的i，他要包含一点实质的内容才能够我们使用。 for(var i &#x3D; 1;i &lt;&#x3D; 5; i++;)&#123; (function(j) &#123; setTimeout(function timer() &#123; console.log(j); &#125;,j*1000) &#125;(i); &#125; &#x2F;&#x2F; 这样就达到我们预期的目的，每秒一个，一次输出1-5 重返块作用域前面说let可以劫持块级作用域，，并且在这个块级作用域中声明一个变量。看下面代码 for(var i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123; let j &#x3D; i; setTimeout(function timer() &#123; console.log(j); &#125;,j*1000) &#125;; 还可以更完善 for(let i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;,i*1000) &#125;; 模块function foo()&#123; var a &#x3D; &#39;cool&#39;; var b &#x3D; [1,2,3]; function bar() &#123; console.log(a); &#125; function baz() &#123; console.log(b); &#125; &#125; 这里并没有明显的闭包，只有两个私有数据变量a和b，以及bar和baz两个内部函数，他们的词法作用域就是闭包，也就是foo（）的内部作用域。 function CoolModule() &#123; var something &#x3D; &#39;cool&#39;; var another &#x3D; [1,2,3]; function doSomething() &#123; console.log(something)); &#125; function doAnother() &#123; console.log(another.join(&quot;!&quot;)); &#125; return &#123; doSomething: doSomething, doAnother: doAnother, &#125;; &#125; var foo &#x3D; CoolModule; foo.doSomething(); &#x2F;&#x2F; cool foo.doAnother(); &#x2F;&#x2F; 1!2!3 首先，CoolModule() 只是一个函数，必须通过调用它来创建一个模块实例，如果不执行外部函数，内部作用域和闭包都无法被创建。 其次，CoolModule() 返回一个用对象字面量语法来表示的对象，这个返回的对象中含有内部函数，而不是内部数据变量的引用。我们保持内部数据变量是隐藏且私有状态。 这个对象类型的返回值最终被赋值给外部变量foo，然后我们就可以通过它来访问API中的属性方法。 模块模式必须具有两个条件 必须有外部的封闭函数，该函数必须至少被调用一次。（每次调用都会创建一个新的模块实例） 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。 一个具有函数属性的对象本身并不是真正的模块。从方便观察角度来看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。 改进上面的代码 var foo &#x3D; (function CoolModule() &#123; var something &#x3D; &#39;cool&#39;; var another &#x3D; [1,2,3]; function doSomething() &#123; console.log(something)); &#125; function doAnother() &#123; console.log(another.join(&quot;!&quot;)); &#125; return &#123; doSomething: doSomething, doAnother: doAnother, &#125;; &#125;)(); foo.doSomething(); &#x2F;&#x2F; cool foo.doAnother(); &#x2F;&#x2F; 1!2!3 模块是普通函数，因此也可以传参。 function CoolModule(id) &#123; function doSomething() &#123; console.log(id); &#125; return &#123; doSomething: doSomething, &#125;; &#125; var foo &#x3D; CoolModule(&#39;foo&#39;); foo.doSomething(); &#x2F;&#x2F; foo 模块另一个简单但又强大的用法是命名将要作为公共API返回的对象。 var foo &#x3D; (function Cool(id)&#123; function change() &#123; publicAPI.identify &#x3D; identify2; &#125;; function identify1() &#123; console.log(id); &#125;; function identify2() &#123; console.log(id.toUppeCase()); &#125;; var publicAPI &#x3D; &#123; change: change, identify: identify1 &#125; return publicAPI; &#125;)(&#39;foo module&#39;); foo.identify(); &#x2F;&#x2F; foo module foo.change(); foo.identify(); &#x2F;&#x2F; FOO MODULE 通过模块在实例的内部保留的公共API对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法，以及修改他们的值。 现代的模块机制创建一个模块 var MyModules &#x3D; (function Manager()&#123; &#x2F;&#x2F; 存储方法 var modules &#x3D; &#123;&#125;; &#x2F;&#x2F; 添加方法 function define(name,deps,impl)&#123; for(var i &#x3D; 0;i &lt; deps.length; i++) &#123; deps[i] &#x3D; modules[deps[i]]; &#125; modules[name] &#x3D; impl.apply(impl,deps); &#125; &#x2F;&#x2F; 根据名字获取方法 function get(name) &#123; return modules[name]; &#125; &#x2F;&#x2F; 返回内部函数（方法） return &#123; define: define, get: get &#125; &#125;)() Function.apply(obj,args)方法能接收两个参数 obj：这个对象将代替Function类里this对象 args：这个是数组，它将作为参数传给Function(args–&gt;arguments) 使用它来定义模块： MyModules.define(&quot;bar&quot;,[], function() &#123; function hello(who) &#123; return &quot;let me introduce:&quot; + who; &#125; retrun &#123; hello : hello &#125;; &#125;); MyModules.define(&quot;foo&quot;,[&#39;bar&#39;], function(bar) &#123; var hungry &#x3D; &#39;hippo&#39;; function awesome(who) &#123; console.log(bar.hello(hungry).toUpperCase()); &#125; retrun &#123; awesome : awesome &#125;; &#125;); var bar &#x3D; MyModules.get(&#39;bar&#39;); var foo &#x3D; MyModules.get(&#39;foo&#39;); console.log(bar.hello(&#39;hippo&#39;));&#x2F;&#x2F; let me introduce: hippo foo.awesome(); &#x2F;&#x2F; 大写的 foo 和 bar 都是通过一个返回的公共的API的函数来定义的。foo 甚至接受 bar 的实例作为依赖参数，并且相应地使用它。","categories":[],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://example.com/tags/javaScript/"}]},{"title":"this词法","slug":"js-this词法","date":"2021-07-20T01:07:45.424Z","updated":"2021-07-20T07:32:18.971Z","comments":true,"path":"2021/07/20/js-this词法/","link":"","permalink":"http://example.com/2021/07/20/js-this%E8%AF%8D%E6%B3%95/","excerpt":"","text":"ES6添加了一个特殊的词法形式的函数声明，叫做箭头函数，箭头函数在涉及this绑定的行为和普通函数的行为完全不一样，他放弃了所有的普通函数this绑定的规则，取而代之的是用当前的词法作用域覆盖了this原本的值。 var obj &#x3D; &#123; count: 0, cool: function coolFn() &#123; if(this.count &lt; 1) &#123; setTimeout(() &#x3D;&gt; &#123; this.count++; console.log(&#39;awesome?&#39;); &#125;,1000); &#125; &#125; &#125; obj.cool();&#x2F;&#x2F;awesome? 这个箭头函数中的this直接是cool()的this绑定（因此调用它并不会出错） 它将程序员们经常犯的一个错误给标准化了，也就是混淆了this绑定规则和词法作用域规则。 另一个导致箭头函数不够理想的原因是他不是具名的，而是一个匿名函数。 误解： 人们很容易把this理解成指向函数自身。那么为什么函数要从内部引用函数自身呢？常见的原因是递归（从函数内部调用这个函数）或者可以写在第一次被调用后自己解除绑定事件处理器。 新手通常会认为，既然把函数看做一个对象，那就可以在调用函数时储存状态。 call function foo(num) &#123; console.log(&quot;foo&quot; + num); this.count ++; &#125; foo.count &#x3D; 0; var i; for(i &#x3D; 0; i &lt; 10; i++)&#123; if(i &gt; 5) &#123; &#x2F;&#x2F; 使用call(...) 可以确保this指向函数本身 foo.call(foo, i) &#125; &#125; &#x2F;&#x2F; foo: 6 &#x2F;&#x2F; foo: 7 &#x2F;&#x2F; foo: 8 &#x2F;&#x2F; foo: 9 cnosole.log(foo.count); &#x2F;&#x2F; 4 它的作用域还有一种常见的错误是，this指向函数的作用域。这个问题在某中情况下是正确的，但是有时候又是错误的。需要明确的是this在任何情况下都不指向函数的词法作域。 function foo()&#123; var a &#x3D; 2; this.bar(); &#x2F;&#x2F; 能调用到bar也是意外，正常应该通过词法作用域，直接执行 &#125; function bar()&#123; console.log(this.a) &#125; foo(); &#x2F;&#x2F; a not defined ==当你想把this和词法作用域的查找混合使用的时候，一定要提醒自己这是无法实现的== 是什么this不是在写代码时候绑定的而是代码在执行的时候绑定的，它的上下文取决于函数调用时的各种条件。 this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。 ==当一个函数被执行时，会创建一个活动记录（有时候也被称之为执行上下文）。这个记录会包含函数在哪里被调用、函数的调用方式、传入参数等信息。this就是这个记录的一个属性，会在函数执行的过程中调用到。== this实际上是在函数被调用的时候发生绑定，他指向什么完全取决于函数在哪里被调用。","categories":[],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://example.com/tags/javaScript/"}]},{"title":"作用域是什么-词法作用域","slug":"js-作用域是什么-词法作用域","date":"2021-07-20T01:07:45.424Z","updated":"2021-07-20T07:32:40.894Z","comments":true,"path":"2021/07/20/js-作用域是什么-词法作用域/","link":"","permalink":"http://example.com/2021/07/20/js-%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88-%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/","excerpt":"","text":"作用域是什么 存储变量的规则存储在哪里？怎么获取？ var a = 2 为一个变量分配内存，名字为a，将值为2保存进这个变量（不完全正确） var a 编译器会询问作用域是否已经存在这样一个变量存在于同一个作用域内，如果有编译器会忽略该声明，继续编译，如果没有，他会要求作用域在当前作用域内声明一个新的变量，并命名为a。 接下载编译器会为引擎生成运行时所需要的代码，这些代码被用来处理a = 2 的操作，引擎运行时会询问作用域当前作用域集合中是否存在叫做a的变量，如果有，就是用该变量，如果没有会再向再外层的作用域询问，最终会到全局作用域。找到后会将2赋值给它，找不到就会抛出异常 总结：变量的赋值操作会执行两个动作，编译器在作用域中声明，运行时引擎会查找该变量并进行赋值。 编译器：LHS查询 查找类型RHS（LHS，RHS），当变量出现在赋值操作的左侧时进行进行LHS查询，出现在右侧时进行RHS查询。 console.log（a） 执行的是RHS，要去找a的值； a = 2 执行的是LHS 要为=2找到赋值的目标。 LHS：赋值操作的目标是谁；目的是对变量进行赋值 RHS：谁是赋值操作的源头；目的是获取变量的值 ReferenceError 这个错误是找不到定义的变量 词法作用域作用域有两种主要的工作模型：词法作用域，动态作用域。 词法作用域：定义在词法阶段的作用域，就是由你写代码时将变量和块作用域写在哪里决定的，因此词法解析器处理代码时会保持作用域不变（大部分情况下是这样） 词法欺骗： eval( ) function foo(str, a) &#123; eval(str); &#x2F;&#x2F; 欺骗 console.log(a, b); &#125; var b &#x3D; 2; foo(&#39;val b &#x3D; 3;&#39;, 1); &#x2F;&#x2F; 1, 3 with(){} function foo(obj) &#123; with(obj)&#123; a &#x3D; 2; &#125; &#125; var o1 &#x3D; &#123; a: 3 &#125; var o2 &#x3D; &#123; a: 3 &#125; foo(o1); console.log(o1.a) &#x2F;&#x2F; 2 foo(o2); console.log(o2.a) &#x2F;&#x2F; undefined console.log(a) &#x2F;&#x2F; 2 &#x3D;&#x3D;a被泄漏到全局上面去了&#x3D;&#x3D; 总结eval（）函数如果接受了一个或多个声明的代码，就会修改其所处的词法作用域；with声明实际上是根据传递给他的对象凭空创建了一个全新的词法作用域 eval，with会降低性能，所以不建议使用","categories":[],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://example.com/tags/javaScript/"}]},{"title":"函数中的作用域","slug":"js-函数作用域、作用域快","date":"2021-07-20T01:07:45.424Z","updated":"2021-07-20T07:33:03.328Z","comments":true,"path":"2021/07/20/js-函数作用域、作用域快/","link":"","permalink":"http://example.com/2021/07/20/js-%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%BF%AB/","excerpt":"","text":"函数中的作用域js有基于函数的作用域，每声明一个函数都会为其自身创建一个气泡，可以在附属气泡里获取外层的变量，但是不能从外层气泡中获取附属气泡种的变量 隐藏内部实现 暴露在外面的写法，很不安全 function foo(a) &#123; b &#x3D; a + fff(a * 2); console.log(b * 3); &#125; function fff(a) &#123; return a - 1; &#125; var b; foo(2) &#x2F;&#x2F; 15 隐藏的写法 function foo(a) &#123; function fff(a) &#123; return a - 1; &#125; var b; b &#x3D; a + fff(a * 2); console.log(b * 3); &#125; foo(2) &#x2F;&#x2F; 15 规避冲突，可以避免同名标识符之间的冲突，避免被覆盖 方法： 全局命名空间，在全局声明一个独特的变量，通常是一个对象，所有需要暴露给外界的功能都会成为这个对象的属性，而不是将自己的标识符暴露在顶级的词法作用域种。 模块管理，从众多模块中挑选一个来使用，任何库都无需将标识符加入到全局作用域中。 函数作用域在任意代码片段外部添加包装函数都可以将内部的变量和函数定义‘隐藏’起来，外部作用域无法访问包装函数内部的任何内容 通过定义一个函数来达到是变量在函数作用域之内，虽然可以解决问题，但是并不理想，因为这个函数名称本身污染了所在的作用域，其次是必须通过显式的调用这个函数才能运行其中的代码。 var a &#x3D; 2; (function foo()&#123; var a &#x3D; 3; console.log( a ); &#x2F;&#x2F; 3 &#125;)(); console.log( a ); &#x2F;&#x2F; 2 这样函数会被当作函数表达式而不是一个标准的函数声明来处理。– 如果function是声明中的第一个第一个词，那么就是函数声明，否则就是函数表达式。 函数表达式和函数声明最大的区别是它们的名称标识符将会绑定在何处。 foo只能在所代表的位置中被访问，外部不行。 匿名和具名 匿名函数表达式 setTimeout( function()&#123; console.log(&#39;aaa&#39;); &#125;,1000); fun没有标识符，函数声明则是不可以省略函数名称 匿名函数在栈追踪中不会显示出有意义的函数名称，使得调用很困难。 如果没有函数名，需要引用的时候就只能使用已经过期的arguments.callee引用，比如在递归中 匿名函数省略了对于代码的可读性/可理解性很重要的函数名 行内函数表达式 setTimeout( function timeoutHandler()&#123; console.log(&#39;aaa&#39;); &#125;,1000); 立即执行函数表达式var a &#x3D; 2; (function foo()&#123; var a &#x3D; 3; console.log( a ); &#x2F;&#x2F; 3 &#125;)(); console.log( a ); &#x2F;&#x2F; 2 第一个（）将函数变成了表达式，第二个（）执行了这个函数 IIFE代表立即执行函数表达式 var a &#x3D; 2; (function IIFE()&#123; &#x2F;&#x2F;传统的形式 var a &#x3D; 3; console.log( a ); &#x2F;&#x2F; 3 &#125;)(); console.log( a ); &#x2F;&#x2F; 2 ==以上两种写法功能上是一样的== 用途： 可以传参数进去 var a &#x3D; 2; (function IIFE(global)&#123; &#x2F;&#x2F;传统的形式 var a &#x3D; 3; console.log( a ); &#x2F;&#x2F; 3 console.log( global.a ); &#x2F;&#x2F; 3 &#125;)(window); console.log( a ); &#x2F;&#x2F; 2 块作用域除了函数能产生一个作用域气泡，for循环，if，with,try/catch等都会产生一个作用域气泡。 块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块，通常指{..}的内部 var 其实val一个变量无论在什么地方，都会提升到全局变量，把它写在作用域内部，只是为了风格更易读而伪装出的形式上的块作用域，如果使用这种，要确保在其他地方没有重复的使用同名的变量。 let ES6引入了关键字let，可以将变量绑定到所在的任意作用域中，为其声明的变量隐式的劫持了所在的块作用域。 let进行声明的不会在代码在块作用域中进行提升，声明的代码在运行前，声明并不‘存在’。 &#123; console.log(a); &#x2F;&#x2F; ReferenceError(没有找到) let a &#x3D; 2; &#125; let 声明附属于一个新的作用域而不是当前函数作用域（也不属于全局作用域） const 同样可以用来创建块作用域变量，但其值是固定的，之后的任何试图修改值的操作都会引起错误。 var foo &#x3D; true; if(foo)&#123; var a &#x3D; 2; const b &#x3D; 3; a &#x3D; 4; &#x2F;&#x2F; 正确 b &#x3D; 6; &#x2F;&#x2F; 错误 &#125; console.log(a) &#x2F;&#x2F; 4 console.log(b) &#x2F;&#x2F; ReferenceError 任何声明在某个作用域内部的变量，都将附属于这个作用域 小思考a &#x3D; 2; val a; console.log(a);&#x2F;&#x2F;2 输出2的原因是：声明会提升，也就是先声明再赋值，在执行查询 console.log(a); &#x2F;&#x2F; undefind var a &#x3D; 2; &#x2F;&#x2F; 执行顺序 val a; console.log(a); &#x2F;&#x2F; undefind a &#x3D; 2; 原因：函数声明会提升，然后执行查询，此时是没有赋值的，所以是undefind foo(); &#x2F;&#x2F; 不是ReferenceError，而是TypeEerror var foo &#x3D; funcyion bar() &#123; &#x2F;&#x2F;... &#125;; 原因：函数表达式不会被提升 函数优先 函数声明和变量声明都会被提升，但是一个值得注意的细节是函数会被首先提升，然后才是变量。 foo(); &#x2F;&#x2F;1 var foo; function foo() &#123; console.log(1); &#125; foo &#x3D; function() &#123; console.log(2); &#125; 输出的是1而不是2是因为函数声明先被提升到上面，然后在执行。var foo 尽管出现在function foo… 之前，但是他是重复声明会被忽略。 后面的声明会覆盖掉前面的声明 foo(); &#x2F;&#x2F;3 function foo() &#123; console.log(1); &#125; var foo &#x3D; function() &#123; console.log(2); &#125; function foo() &#123; console.log(3); &#125;","categories":[],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://example.com/tags/javaScript/"}]},{"title":"js数据类型","slug":"js-数据类型","date":"2021-07-20T01:07:45.423Z","updated":"2021-07-20T07:52:01.661Z","comments":true,"path":"2021/07/20/js-数据类型/","link":"","permalink":"http://example.com/2021/07/20/js-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"基本数据类型、引用数据类型 ECMAScript包括两个不同类型的值：基本数据类型和引用数据类型。基本数据类型指的是简单的数据段，引用数据类型指的是有多个值构成的对象。当我们把变量赋值给一个变量时，解析器首先要确认的就是这个值是基本类型值还是引用类型值。 常见的基本数据类型Number、String 、Boolean、Null和Undefined。基本数据类型是按值访问的，因为可以直接操作保存在变量中的实际值。示例： var a = 10; var b = a; b = 20; console.log(a); // 10值 上面，b获取的是a值得一份拷贝，虽然，两个变量的值相等，但是两个变量保存了两个不同的基本数据类型值。 b只是保存了a复制的一个副本。所以，b的改变，对a没有影响。 引用类型数据 也就是对象类型Object type，比如：Object 、Array 、Function 、Data等。 javascript的引用数据类型是保存在堆内存中的对象。 与其他语言的不同是，你不可以直接访问堆内存空间中的位置和操作堆内存空间。只能操作对象在栈内存中的引用地址。 所以，引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存中堆内存中的对象。 var obj1 &#x3D; new Object(); var obj2 &#x3D; obj1; obj2.name &#x3D; &quot;我有名字了&quot;; console.log(obj1.name); &#x2F;&#x2F; 我有名字了 说明这两个引用数据类型指向了同一个堆内存对象。obj1赋值给onj2，实际上这个堆内存对象在栈内存的引用地址复制了一份给了obj2， 但是实际上他们共同指向了同一个堆内存对象。实际上改变的是堆内存对象。 查看一个值的是数据类型 js中变量是没有数据类型的，只有值才有。变量可以持有任何数据类型的值。 typeof 用来查看变量的类型会返回一字符串： typeof 1; &#x2F;&#x2F; &quot;number&quot; typeof &#39;1&#39;; &#x2F;&#x2F; &quot;string&quot; typeof undefined; &#x2F;&#x2F; &quot;undefined&quot; typeof true; &#x2F;&#x2F; &quot;boolean&quot; typeof &#123;a:1&#125;; &#x2F;&#x2F; &quot;object&quot; typeod Symbol(); &#x2F;&#x2F;&#39;symbo&#39; typeof null; &#x2F;&#x2F; &#39;object&#39; null 使用typeof 返回的类型是object，所以查看是不是null是需要用复合条件来检测 var a &#x3D; null (!a &amp;&amp; typeof a &#x3D;&#x3D;&#x3D;&quot;object&quot;); &#x2F;&#x2F;true JSON.stringify(a) &#x3D;&#x3D;&#x3D; &#39;null&#39; 总结区别声明变量时不同的内存分配： 1）原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。 这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – 栈中。这样存储便于迅速查寻变量的值。 2）引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。 这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。 地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。 不同的内存分配机制也带来了不同的访问机制 1）在javascript中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时， 首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的按引用访问。 2）而原始类型的值则是可以直接访问到的。 c 复制变量时的不同 1）原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的value而已。 2）引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量， 也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。 （这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了）。多了一个指针 参数传递的不同（把实参复制给形参的过程） 首先我们应该明确一点：ECMAScript中所有函数的参数都是按值来传递的。 但是为什么涉及到原始类型与引用类型的值时仍然有区别呢？还不就是因为内存分配时的差别。 1）原始值：只是把变量里的值传递给参数，之后参数和这个变量互不影响。 2）引用值：对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！ 因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象。","categories":[],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://example.com/tags/javaScript/"}]},{"title":"markdown 写法备注","slug":"remarks","date":"2021-07-20T01:07:45.423Z","updated":"2021-07-20T01:52:20.101Z","comments":true,"path":"2021/07/20/remarks/","link":"","permalink":"http://example.com/2021/07/20/remarks/","excerpt":"","text":"标题 一级标题二级标题三级标题四级标题 无序列表 1 2 3 有序列表 列表 列表 列表 分割线 代码块 ``` 文本样式 字体倾斜 &gt; 字体倾斜 字体倾斜 字体加粗 &gt; 字体加粗 字体加粗 字体删除 &gt; 字体删除 ! 符号与字体之间不要有空格","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://example.com/tags/markdown/"}]}],"categories":[],"tags":[{"name":"async、await","slug":"async、await","permalink":"http://example.com/tags/async%E3%80%81await/"},{"name":"router","slug":"router","permalink":"http://example.com/tags/router/"},{"name":"javaScript","slug":"javaScript","permalink":"http://example.com/tags/javaScript/"},{"name":"markdown","slug":"markdown","permalink":"http://example.com/tags/markdown/"}]}