{"meta":{"title":"chenMing","subtitle":"(ง •̀_•́)ง","description":"技术博客","author":"chenMing","url":"http://example.com","root":"/"},"pages":[{"title":"关于我","date":"2021-07-19T08:47:46.000Z","updated":"2021-07-20T01:16:24.063Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"2019年6月份毕业来到杭州参加了第一份工作，从事前端开发。 学习永无止境、宜早不宜迟！ 生活就是要快乐，快乐就是要钓鱼！"},{"title":"分类","date":"2021-07-19T08:28:19.000Z","updated":"2021-07-20T01:07:45.426Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-07-19T08:16:44.000Z","updated":"2021-07-20T01:07:45.456Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-07-19T08:44:20.000Z","updated":"2021-07-20T01:07:45.456Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"vue生命周期挂载阶段","slug":"vue-生命周期-挂载阶段","date":"2021-07-29T16:00:00.000Z","updated":"2021-07-30T01:25:24.160Z","comments":true,"path":"2021/07/30/vue-生命周期-挂载阶段/","link":"","permalink":"http://example.com/2021/07/30/vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E6%8C%82%E8%BD%BD%E9%98%B6%E6%AE%B5/","excerpt":"","text":"模板编译阶段完成之后，接下来就进入了挂载阶段，从官方文档给出的生命周期流程图中可以看到，挂载阶段所做的主要工作是创建Vue实例并用其替换el选项对应的DOM元素，同时还要开启对模板中数据（状态）的监控，当数据（状态）发生变化时通知其依赖进行视图更新。 挂载阶段分析在完整版本的$mount方法中将模板编译完成之后，会回过头去调只包含运行时版本的$mount方法进入挂载阶段，所以要想分析挂载阶段我们必须从只包含运行时版本的$mount方法入手。 只包含运行时版本的$mount代码如下： Vue.prototype.$mount = function (el,hydrating) &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined; return mountComponent(this, el, hydrating) &#125;; 可以看到，在该函数内部首先获取到el选项对应的DOM元素，然后调用mountComponent函数并将el选项对应的DOM元素传入，进入挂载阶段。 export function mountComponent (vm,el,hydrating) &#123; vm.$el = el if (!vm.$options.render) &#123; vm.$options.render = createEmptyVNode &#125; callHook(vm, 'beforeMount') let updateComponent updateComponent = () => &#123; vm._update(vm._render(), hydrating) &#125; new Watcher(vm, updateComponent, noop, &#123; before () &#123; if (vm._isMounted) &#123; callHook(vm, 'beforeUpdate') &#125; &#125; &#125;, true /* isRenderWatcher */) hydrating = false if (vm.$vnode == null) &#123; vm._isMounted = true callHook(vm, 'mounted') &#125; return vm &#125; 可以看到，在该函数中，首先会判断实例上是否存在渲染函数，如果不存在，则设置一个默认的渲染函数createEmptyVNode，该渲染函数会创建一个注释类型的VNode节点。 然后调用callHook函数来触发beforeMount生命周期钩子函数 该钩子函数触发后标志着正式开始执行挂载操作 接下来定义了一个updateComponent函数 在该函数内部，首先执行渲染函数vm._render()得到一份最新的VNode节点树，然后执行vm._update()方法对最新的VNode节点树与上一次渲染的旧VNode节点树进行对比并更新DOM节点(即patch操作)，完成一次渲染。 也就是说，如果调用了updateComponent函数，就会将最新的模板内容渲染到视图页面中，这样就完成了挂载操作的一半工作.因为在挂载阶段不但要将模板渲染到视图中，同时还要开启对模板中数据（状态）的监控，当数据（状态）发生变化时通知其依赖进行视图更新。 接下来创建了一个Watcher实例，并将定义好的updateComponent函数传入。要想开启对模板中数据（状态）的监控，这一段代码是关键， 可以看到，在创建Watcher实例的时候，传入的第二个参数是updateComponent函数。回顾一下我们在数据侦测篇文章中介绍Watcher类的时候，Watcher类构造函数的第二个参数支持两种类型：函数和数据路径（如a.b.c）。如果是数据路径，会根据路径去读取这个数据；如果是函数，会执行这个函数。一旦读取了数据或者执行了函数，就会触发数据或者函数内数据的getter方法，而在getter方法中会将watcher实例添加到该数据的依赖列表中，当该数据发生变化时就会通知依赖列表中所有的依赖，依赖接收到通知后就会调用第四个参数回调函数去更新视图。 换句话说，上面代码中把updateComponent函数作为第二个参数传给Watcher类从而创建了watcher实例，那么updateComponent函数中读取的所有数据都将被watcher所监控，这些数据中只要有任何一个发生了变化，那么watcher都将会得到通知，从而会去调用第四个参数回调函数去更新视图，如此反复，直到实例被销毁。 这样就完成了挂载阶段的另一半工作。 如此之后，挂载阶段才算是全部完成了，接下来调用挂载完成的生命周期钩子函数mounted 总结在该阶段中所做的主要工作是创建Vue实例并用其替换el选项对应的DOM元素，同时还要开启对模板中数据（状态）的监控，当数据（状态）发生变化时通知其依赖进行视图更新。 我们将挂载阶段所做的工作分成两部分进行了分析，第一部分是将模板渲染到视图上，第二部分是开启对模板中数据（状态）的监控。两部分工作都完成以后挂载阶段才算真正的完成了。","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://example.com/tags/vue2-0/"}]},{"title":"vue生命周期-模板编译","slug":"vue-生命周期-模板编译","date":"2021-07-26T16:00:00.000Z","updated":"2021-07-30T01:15:08.009Z","comments":true,"path":"2021/07/27/vue-生命周期-模板编译/","link":"","permalink":"http://example.com/2021/07/27/vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/","excerpt":"","text":"前言在初始化阶段各项工作做完之后调用了vm.$mount方法，该方法的调用标志着初始化阶段的结束和进入下一个阶段，从官方文档给出的生命周期流程图中可以看到，下一个阶段就进入了模板编译阶段，该阶段所做的主要工作是获取到用户传入的模板内容并将其编译成渲染函数。 模板编译阶段并不是存在于Vue的所有构建版本中，它只存在于完整版（即vue.js）中。在只包含运行时版本（即vue.runtime.js）中并不存在该阶段，这是因为当使用vue-loader或vueify时，*.vue文件内部的模板会在构建时预编译成渲染函数，所以是不需要编译的，从而不存在模板编译阶段，由上一步的初始化阶段直接进入下一阶段的挂载阶段。 vue基于源码构建的有两个版本，一个是runtime only(一个只包含运行时的版本)，另一个是runtime + compiler(一个同时包含编译器和运行时的完整版本)。而两个版本的区别仅在于后者包含了一个编译器。 完整版本一个完整的Vue版本是包含编译器的，我们可以使用template选项进行模板编写。编译器会自动将template选项中的模板字符串编译成渲染函数的代码,源码中就是render函数。如果你需要在客户端编译模板 (比如传入一个字符串给 template 选项，或挂载到一个元素上并以其 DOM 内部的 HTML 作为模板)，就需要一个包含编译器的版本。 如下：// 需要编译器的版本 new Vue(&#123; template: '&lt;div>&#123;&#123; hi &#125;&#125;&lt;/div>' &#125;) 只包含运行时版本只包含运行时的版本拥有创建Vue实例、渲染并处理Virtual DOM等功能，基本上就是除去编译器外的完整代码。该版本的适用场景有两种： 我们在选项中通过手写render函数去定义渲染过程，这个时候并不需要包含编译器的版本便可完整执行。// 不需要编译器 new Vue(&#123; render (h) &#123; return h('div', this.hi) &#125; &#125;) 借助vue-loader这样的编译工具进行编译，当我们利用webpack进行Vue的工程化开发时，常常会利用vue-loader对*.vue文件进行编译，尽管我们也是利用template模板标签去书写代码，但是此时的Vue已经不需要利用编译器去负责模板的编译工作了，这个过程交给了插件去实现。 很明显，编译过程对性能会造成一定的损耗，并且由于加入了编译的流程代码，Vue代码的总体积也更加庞大(运行时版本相比完整版体积要小大约 30%)。因此在实际开发中，我们需要借助像webpack的vue-loader这类工具进行编译，将Vue对模板的编译阶段合并到webpack的构建流程中，这样不仅减少了生产环境代码的体积，也大大提高了运行时的性能，一举两得。 模板编译阶段分析完整版和只包含运行时版之间的差异主要在于是否有模板编译阶段，而是否有模板编译阶段主要表现在vm.$mount方法的实现上。 两种$mount方法对比只包含运行时版本的$mount代码如下： Vue.prototype.$mount = function (el,hydrating) &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined; return mountComponent(this, el, hydrating) &#125;; 在该版本中的$mount方法内部获取到el选项对应的DOM元素后直接调用mountComponent函数进行挂载操作. 而完整版本的$mount代码如下： var mount = Vue.prototype.$mount; Vue.prototype.$mount = function (el,hydrating) &#123; // 省略获取模板及编译代码 return mount.call(this, el, hydrating) &#125; 注意，在完整版本的$mount定义之前，先将Vue原型上的$mount方法先缓存起来，记作变量mount。此时你可能会问了，这$mount方法还没定义呢，怎么先缓存起来了。 其实在源码中，是先定义只包含运行时版本的$mount方法，再定义完整版本的$mount方法，所以此时缓存的mount变量就是只包含运行时版本的$mount方法。 为什么要这么做呢？上文我们说了，完整版本和只包含运行时版本之间的差异主要在于是否有模板编译阶段，只包含运行时版本没有模板编译阶段，初始化阶段完成后直接进入挂载阶段，而完整版本是初始化阶段完成后进入模板编译阶段，然后再进入挂载阶段。也就是说，这两个版本最终都会进入挂载阶段。所以在完整版本的$mount方法中将模板编译完成后需要回头去调只包含运行时版本的$mount方法以进入挂载阶段。 这也就是在完整版本的$mount方法中先把只包含运行时版本的$mount方法缓存下来，记作变量mount，然后等模板编译完成，再执行mount方法（即只包含运行时版本的$mount方法）。 所以分析模板编译阶段其实就是分析完整版的vm.$mount方法的实现。 完整版的vm.$mount方法分析完整版的vm.$mount方法定义位于源码的dist/vue.js中，如下： var mount = Vue.prototype.$mount; Vue.prototype.$mount = function (el,hydrating) &#123; el = el &amp;&amp; query(el); if (el === document.body || el === document.documentElement) &#123; warn( \"Do not mount Vue to &lt;html> or &lt;body> - mount to normal elements instead.\" ); return this &#125; var options = this.$options; // resolve template/el and convert to render function if (!options.render) &#123; var template = options.template; if (template) &#123; if (typeof template === 'string') &#123; if (template.charAt(0) === '#') &#123; template = idToTemplate(template); /* istanbul ignore if */ if (!template) &#123; warn( (\"Template element not found or is empty: \" + (options.template)), this ); &#125; &#125; &#125; else if (template.nodeType) &#123; template = template.innerHTML; &#125; else &#123; &#123; warn('invalid template option:' + template, this); &#125; return this &#125; &#125; else if (el) &#123; template = getOuterHTML(el); &#125; if (template) &#123; if (config.performance &amp;&amp; mark) &#123; mark('compile'); &#125; var ref = compileToFunctions(template, &#123; outputSourceRange: \"development\" !== 'production', shouldDecodeNewlines: shouldDecodeNewlines, shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments &#125;, this); var render = ref.render; var staticRenderFns = ref.staticRenderFns; options.render = render; options.staticRenderFns = staticRenderFns; if (config.performance &amp;&amp; mark) &#123; mark('compile end'); measure((\"vue \" + (this._name) + \" compile\"), 'compile', 'compile end'); &#125; &#125; &#125; return mount.call(this, el, hydrating) &#125;; 从代码中可以看到，该函数可大致分为三部分： 根据传入的el参数获取DOM元素； 在用户没有手写render函数的情况下获取传入的模板template； 将获取到的template编译成render函数； 首先，根据传入的el参数获取DOM元素。 由于el参数可以是元素，也可以是字符串类型的元素选择器，所以调用query函数来获取到el对应的DOM元素。query函数比较简单，就是根据传入的el参数是否为字符串从而以不同方式获取到对应的DOM元素. 另外，这里还多了一个判断，就是判断获取到el对应的DOM元素如果是body或html元素时，将会抛出警告。这是因为Vue会将模板中的内容替换el对应的DOM元素，如果是body或html元素时，替换之后将会破坏整个DOM文档，所以不允许el是body或html。 接着，在用户没有手写render函数的情况下获取传入的模板template 首先获取用户传入的template选项赋给变量template，如果变量template存在，则接着判断如果template是字符串并且以##开头，则认为template是id选择符，则调用idToTemplate函数获取到选择符对应的DOM元素的innerHTML作为模板if (template) &#123; if (typeof template === 'string') &#123; if (template.charAt(0) === '#') &#123; template = idToTemplate(template); &#125; &#125; &#125; var idToTemplate = cached(function (id) &#123; var el = query(id); return el &amp;&amp; el.innerHTML &#125;); 如果template不是字符串，那就判断它是不是一个DOM元素，如果是，则使用该DOM元素的innerHTML作为模板.if (template.nodeType) &#123; template = template.innerHTML; &#125; 如果既不是字符串，也不是DOM元素，此时会抛出警告：提示用户template选项无效。 如果变量template不存在，表明用户没有传入template选项，则根据传入的el参数调用getOuterHTML函数获取外部模板。不管是从内部的template选项中获取模板，还是从外部获取模板，总之就是要获取到用户传入的模板内容，有了模板内容接下来才能将模板编译成渲染函数。 接下来要做的事就是将其编译成渲染函数if (template) &#123; var ref = compileToFunctions(template, &#123; outputSourceRange: \"development\" !== 'production', shouldDecodeNewlines: shouldDecodeNewlines, shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments &#125;, this); var render = ref.render; var staticRenderFns = ref.staticRenderFns; options.render = render; options.staticRenderFns = staticRenderFns; &#125; 把模板编译成渲染函数是在compileToFunctions函数中进行的，该函数接收待编译的模板字符串和编译选项作为参数，返回一个对象，对象里面的render属性即是编译好的渲染函数，最后将渲染函数设置到$options上。 Vue源码构建的两种版本：完整版本和只包含运行时版本。并且我们知道了模板编译阶段只存在于完整版中，在只包含运行时版本中不存在该阶段，这是因为在只包含运行时版本中，当使用vue-loader或vueify时，.vue文件内部的模板会在构建时预编译成渲染函数，所以是不需要编译的，从而不存在模板编译阶段。然后对比了两种版本$mount方法的区别。它们的区别在于在$mount方法中是否进行了模板编译。在只包含运行时版本的$mount方法中获取到DOM元素后直接进入挂载阶段，而在完整版本的$mount方法中是先将模板进行编译，然后回过头调只包含运行时版本的$mount方法进入挂载阶段。最后，我们知道了分析模板编译阶段其实就是分析完整版的vm.$mount方法的实现，我们将完整版的vm.$mount方法源码进行了逐行分析。知道了在该阶段中所做的工作就是：从用户传入的el选项和template选项中获取到用户传入的内部或外部模板，然后将获取到的模板编译成渲染函数。","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://example.com/tags/vue2-0/"}]},{"title":"vue生命周期-初始化阶段","slug":"vue-生命周期-初始化阶段","date":"2021-07-25T16:00:00.000Z","updated":"2021-07-27T01:33:26.070Z","comments":true,"path":"2021/07/26/vue-生命周期-初始化阶段/","link":"","permalink":"http://example.com/2021/07/26/vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5/","excerpt":"","text":"new Vue()初始化阶段所做的第一件事就是new Vue()创建一个Vue实例，那么new Vue()的内部都干了什么呢？ 我们知道，new 关键字在 JS中表示从一个类中实例化出一个对象来，由此可见， Vue 实际上是一个类。所以new Vue()实际上是执行了Vue类的构造函数 做了什么function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options) &#125; 可以看到，Vue类的定义非常简单，其构造函数核心就一行代码：this._init(options) 调用原型上的_init(options)方法并把用户所写的选项options传入。那这个_init方法是从哪来的呢？ initMixin(Vue) 这一行代码执行了initMixin函数，那initMixin函数又是从哪儿来的呢？该函数定义位于源码的src/core/instance/init.js 中，如下： export function initMixin (Vue) &#123; Vue.prototype._init = function (options) &#123; const vm = this vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ) vm._self = vm initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, 'beforeCreate') initInjections(vm) // resolve injections before data/props initState(vm) initProvide(vm) // resolve provide after data/props callHook(vm, 'created') if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125; &#125; &#125; 可以看到，在initMixin函数内部就只干了一件事，那就是给Vue类的原型上绑定_init方法，同时_init方法的定义也在该函数内部。现在我们知道了，new Vue()会执行Vue类的构造函数，构造函数内部会执行_init方法，所以new Vue()所干的事情其实就是_init方法所干的事情，那么我们着重来分析下_init方法都干了哪些事情。 首先，把Vue实例赋值给变量vm，并且把用户传递的options选项与当前构造函数的options属性及其父级构造函数的options属性进行合并（关于属性如何合并的问题下面会介绍），得到一个新的options选项赋值给$options属性，并将$options属性挂载到Vue实例上，如下： vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ) 接着，通过调用一些初始化函数来为Vue实例初始化一些属性，事件，响应式数据等，如下： initLifecycle(vm) // 初始化生命周期 initEvents(vm) // 初始化事件 initRender(vm) // 初始化渲染 callHook(vm, 'beforeCreate') // 调用生命周期钩子函数 initInjections(vm) //初始化injections initState(vm) // 初始化props,methods,data,computed,watch initProvide(vm) // 初始化 provide callHook(vm, 'created') // 调用生命周期钩子函数 可以看到，除了调用初始化函数来进行相关数据的初始化之外，还在合适的时机调用了callHook函数来触发生命周期的钩子，关于callHook函数是如何触发生命周期的钩子会在下面介绍，我们先继续往下看： if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125; callHook函数如何触发钩子函数export function callHook (vm: Component, hook: string) &#123; const handlers = vm.$options[hook] // 要执行的钩子函数 if (handlers) &#123; for (let i = 0, j = handlers.length; i &lt; j; i++) &#123; try &#123; handlers[i].call(vm) // 执行钩子函数中的每一个方法 &#125; catch (e) &#123; handleError(e, vm, `$&#123;hook&#125; hook`) &#125; &#125; &#125; &#125; 首先从实例的$options中获取到需要触发的钩子名称所对应的钩子函数数组handlers，每个生命周期钩子名称都对应了一个钩子函数数组。然后遍历该数组，将数组中的每个钩子函数都执行一遍。 initLifecycle函数export function initLifecycle (vm: Component) &#123; const options = vm.$options let parent = options.parent if (parent &amp;&amp; !options.abstract) &#123; while (parent.$options.abstract &amp;&amp; parent.$parent) &#123; parent = parent.$parent &#125; parent.$children.push(vm) &#125; vm.$parent = parent vm.$root = parent ? parent.$root : vm vm.$children = [] vm.$refs = &#123;&#125; vm._watcher = null vm._inactive = null vm._directInactive = false vm._isMounted = false vm._isDestroyed = false vm._isBeingDestroyed = false &#125; 主要是给Vue实例上挂载了一些属性并设置了默认值，同时挂载$parent 属性和$root属性 首先是给实例上挂载$parent属性： let parent = options.parent if (parent &amp;&amp; !options.abstract) &#123; while (parent.$options.abstract &amp;&amp; parent.$parent) &#123; parent = parent.$parent &#125; parent.$children.push(vm) &#125; vm.$parent = parent 如果当前组件不是抽象组件并且存在父级，那么就通过while循环来向上循环，如果当前组件的父级是抽象组件并且也存在父级，那就继续向上查找当前组件父级的父级，直到找到第一个不是抽象类型的父级时，将其赋值vm.$parent，同时把该实例自身添加进找到的父级的$children属性中。这样就确保了在子组件的$parent属性上能访问到父组件实例，在父组件的$children属性上也能访问子组件的实例 接着是给实例上挂载$root属性 vm.$root = parent ? parent.$root : vm 实例的$root属性表示当前实例的根实例，挂载该属性时，首先会判断如果当前实例存在父级，那么当前实例的根实例$root属性就是其父级的根实例$root属性，如果不存在，那么根实例$root属性就是它自己。这很好理解，举个例子：假如有一个人，他如果有父亲，那么他父亲的祖先肯定也是他的祖先，同理，他的儿子的祖先也肯定是他的祖先，我们不需要真正的一层一层的向上递归查找到他祖先本人，只需要知道他父亲的祖先是谁然后告诉他即可。如果他没有父亲，那说明他自己就是祖先，那么他后面的儿子、孙子的$root属性就是他自己了 解析事件 initEvents在Vue中，当我们在父组件中使用子组件时可以给子组件上注册一些事件，这些事件即包括使用v-on或@注册的自定义事件，也包括注册的浏览器原生事件（需要加 .native 修饰符），如下： &lt;child @select=\"selectHandler\" @click.native=\"clickHandler\">&lt;/child> 模板编译解析中，当遇到开始标签的时候，除了会解析开始标签，还会调用processAttrs 方法解析标签中的属性，processAttrs 方法位于源码的 src/compiler/parser/index.js中， 如下： export const onRE = /^@|^v-on:/ export const dirRE = /^v-|^@|^:/ function processAttrs (el) &#123; const list = el.attrsList let i, l, name, value, modifiers for (i = 0, l = list.length; i &lt; l; i++) &#123; name = list[i].name value = list[i].value if (dirRE.test(name)) &#123; // 解析修饰符 modifiers = parseModifiers(name) if (modifiers) &#123; name = name.replace(modifierRE, '') &#125; if (onRE.test(name)) &#123; // v-on name = name.replace(onRE, '') addHandler(el, name, value, modifiers, false, warn) &#125; &#125; &#125; &#125; 在对标签属性进行解析时，判断如果属性是指令，首先通过 parseModifiers 解析出属性的修饰符，然后判断如果是事件的指令，则执行 addHandler(el, name, value, modifiers, false, warn) 方法， 该方法定义在 src/compiler/helpers.js 中，如下： export function addHandler (el,name,value,modifiers) &#123; modifiers = modifiers || emptyObject // check capture modifier 判断是否有capture修饰符 if (modifiers.capture) &#123; delete modifiers.capture name = '!' + name // 给事件名前加'!'用以标记capture修饰符 &#125; // 判断是否有once修饰符 if (modifiers.once) &#123; delete modifiers.once name = '~' + name // 给事件名前加'~'用以标记once修饰符 &#125; // 判断是否有passive修饰符 if (modifiers.passive) &#123; delete modifiers.passive name = '&amp;' + name // 给事件名前加'&amp;'用以标记passive修饰符 &#125; let events if (modifiers.native) &#123; delete modifiers.native events = el.nativeEvents || (el.nativeEvents = &#123;&#125;) &#125; else &#123; events = el.events || (el.events = &#123;&#125;) &#125; const newHandler: any = &#123; value: value.trim() &#125; if (modifiers !== emptyObject) &#123; newHandler.modifiers = modifiers &#125; const handlers = events[name] if (Array.isArray(handlers)) &#123; handlers.push(newHandler) &#125; else if (handlers) &#123; events[name] = [handlers, newHandler] &#125; else &#123; events[name] = newHandler &#125; el.plain = false &#125; 在addHandler 函数里做了 3 件事情，首先根据 modifier 修饰符对事件名 name 做处理，接着根据 modifier.native 判断事件是一个浏览器原生事件还是自定义事件，分别对应 el.nativeEvents 和 el.events，最后按照 name 对事件做归类，并把回调函数的字符串保留到对应的事件中。 initInjections从函数名字上来看，该函数是用来初始化实例中的inject选项的。说到inject选项，那必然离不开provide选项，这两个选项都是成对出现的，它们的作用是：允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。 export function initInjections (vm: Component) &#123; const result = resolveInject(vm.$options.inject, vm) if (result) &#123; toggleObserving(false) Object.keys(result).forEach(key => &#123; defineReactive(vm, key, result[key]) &#125; toggleObserving(true) &#125; &#125; export let shouldObserve: boolean = true export function toggleObserving (value: boolean) &#123; shouldObserve = value &#125; 首先调用resolveInject把inject选项中的数据转化成键值对的形式赋给result，如官方文档给出的例子，那么result应为如下样子： // 父级组件提供 'foo' var Parent = &#123; provide: &#123; foo: 'bar' &#125; &#125; // 子组件注入 'foo' var Child = &#123; inject: ['foo'], &#125; // result result = &#123; 'foo':'bar' &#125; 然后遍历result中的每一对键值，调用defineReactive函数将其添加当前实例上，如下： if (result) &#123; toggleObserving(false) Object.keys(result).forEach(key => &#123; defineReactive(vm, key, result[key]) &#125; toggleObserving(true) &#125; 此处有一个地方需要注意，在把result中的键值添加到当前实例上之前，会先调用toggleObserving(false)，而这个函数内部是把shouldObserve = false，这是为了告诉defineReactive函数仅仅是把键值添加到当前实例上而不需要将其转换成响应式，这个就呼应了官方文档在介绍provide 和 inject 选项用法的时候所提示的： provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。 resolveInject export function resolveInject (inject: any, vm: Component): ?Object &#123; if (inject) &#123; const result = Object.create(null) const keys = Object.keys(inject) for (let i = 0; i &lt; keys.length; i++) &#123; const key = keys[i] const provideKey = inject[key].from let source = vm while (source) &#123; if (source._provided &amp;&amp; hasOwn(source._provided, provideKey)) &#123; result[key] = source._provided[provideKey] break &#125; source = source.$parent &#125; if (!source) &#123; if ('default' in inject[key]) &#123; const provideDefault = inject[key].default result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault &#125; else if (process.env.NODE_ENV !== 'production') &#123; warn(`Injection \"$&#123;key&#125;\" not found`, vm) &#125; &#125; &#125; return result &#125; &#125; initState 初始化实例状态从函数名字上来看，这个函数是用来初始化实例状态的,在Vue组件中会写一些如props、data、methods、computed、watch选项，我们把这些选项称为实例的状态选项。也就是说，initState函数就是用来初始化这些状态的。 export function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options if (opts.props) initProps(vm, opts.props) if (opts.methods) initMethods(vm, opts.methods) if (opts.data) &#123; initData(vm) &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125; &#125; 首先，给实例上新增了一个属性_watchers，用来存储当前实例中所有的watcher实例，无论是使用vm.$watch注册的watcher实例还是使用watch选项注册的watcher实例，都会被保存到该属性中。 这里我们再额外多说一点，在变化侦测篇中我们介绍了Vue中对数据变化的侦测是使用属性拦截的方式实现的，但是Vue并不是对所有数据都使用属性拦截的方式侦测变化，这是因为数据越多，数据上所绑定的依赖就会多，从而造成依赖追踪的内存开销就会很大，所以从Vue 2.0版本起，Vue不再对所有数据都进行侦测，而是将侦测粒度提高到了组件层面，对每个组件进行侦测，所以在每个组件上新增了vm._watchers属性，用来存放这个组件内用到的所有状态的依赖，当其中一个状态发生变化时，就会通知到组件，然后由组件内部使用虚拟DOM进行数据比对，从而降低内存开销，提高性能。 先判断实例中是否有props选项，如果有，就调用props选项初始化函数initProps去初始化props选项； 再判断实例中是否有methods选项，如果有，就调用methods选项初始化函数initMethods去初始化methods选项； 接着再判断实例中是否有data选项，如果有，就调用data选项初始化函数initData去初始化data选项；如果没有，就把data当作空对象并将其转换成响应式； 接着再判断实例中是否有computed选项，如果有，就调用computed选项初始化函数initComputed去初始化computed选项； 最后判断实例中是否有watch选项，如果有，就调用watch选项初始化函数initWatch去初始化watch选项； 总之一句话就是：有什么选项就调用对应的选项初始化子函数去初始化什么选项。 初始化propsprops选项通常是由当前组件的父级组件传入的，当父组件在调用子组件的时候，通常会把props属性值作为标签属性添加在子组件的标签上，如下： &lt;Child prop1=\"xxx\" prop2=\"yyy\">&lt;/Child> 在模板编译的时候，当解析到组件标签时会将所有的标签属性都解析出来然后在子组件实例化的时候传给子组件，当然这里面就包括props数据。 子组件接受： // 写法一 props: ['name'] // 写法二 props: &#123; name: String, // [String, Number] &#125; // 写法三 props: &#123; name:&#123; type: String &#125; &#125; Vue给用户提供的props选项写法非常自由，写法虽多但是最终处理的时候肯定只处理一种写法，将所有写法都转化成一种写法。 function normalizeProps (options, vm) &#123; const props = options.props if (!props) return const res = &#123;&#125; let i, val, name if (Array.isArray(props)) &#123; i = props.length while (i--) &#123; val = props[i] if (typeof val === 'string') &#123; name = camelize(val) res[name] = &#123; type: null &#125; &#125; else if (process.env.NODE_ENV !== 'production') &#123; warn('props must be strings when using array syntax.') &#125; &#125; &#125; else if (isPlainObject(props)) &#123; for (const key in props) &#123; val = props[key] name = camelize(key) res[name] = isPlainObject(val) ? val : &#123; type: val &#125; &#125; &#125; else if (process.env.NODE_ENV !== 'production') &#123; warn( `Invalid value for option \"props\": expected an Array or an Object, ` + `but got $&#123;toRawType(props)&#125;.`, vm ) &#125; options.props = res &#125; 上面代码中，首先拿到实例中的props选项，如果不存在，则直接返回。 如果存在，则定义一个空对象res，用来存储最终的结果。接着判断如果props选项是一个数组（写法一），则遍历该数组中的每一项元素，如果该元素是字符串，那么先将该元素统一转化成驼峰式命名，然后将该元素作为key，将{type: null}作为value存入res中；如果该元素不是字符串，则抛出异常。 如果props选项不是数组那就继续判断是不是一个对象，如果是一个对象，那就遍历对象中的每一对键值，拿到每一对键值后，先将键名统一转化成驼峰式命名，然后判断值是否还是一个对象，如果值是对象（写法三），那么就将该键值对存入res中；如果值不是对象（写法二），那么就将键名作为key，将{type: null}作为value存入res中。 如果props选项既不是数组也不是对象，那么如果在非生产环境下就抛出异常，最后将res作为规范化后的结果重新赋值给实例的props选项。 无论是三种写法的哪一种，最终都会被转化成如下写法： props: &#123; name:&#123; type: xxx &#125; &#125; initProps函数分析将props选项规范化完成之后，接下来我们就可以来真正的初始化props选项了，initProps函数的定义位于源码的src/core/instance/state.js中，如下： function initProps (vm: Component, propsOptions: Object) &#123; const propsData = vm.$options.propsData || &#123;&#125; const props = vm._props = &#123;&#125; // cache prop keys so that future props updates can iterate using Array // instead of dynamic object key enumeration. const keys = vm.$options._propKeys = [] const isRoot = !vm.$parent // root instance props should be converted if (!isRoot) &#123; toggleObserving(false) &#125; for (const key in propsOptions) &#123; keys.push(key) const value = validateProp(key, propsOptions, propsData, vm) /* istanbul ignore else */ if (process.env.NODE_ENV !== 'production') &#123; const hyphenatedKey = hyphenate(key) if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) &#123; warn( `\"$&#123;hyphenatedKey&#125;\" is a reserved attribute and cannot be used as component prop.`, vm ) &#125; defineReactive(props, key, value, () => &#123; if (vm.$parent &amp;&amp; !isUpdatingChildComponent) &#123; warn( `Avoid mutating a prop directly since the value will be ` + `overwritten whenever the parent component re-renders. ` + `Instead, use a data or computed property based on the prop's ` + `value. Prop being mutated: \"$&#123;key&#125;\"`, vm ) &#125; &#125;) &#125; else &#123; defineReactive(props, key, value) &#125; // static props are already proxied on the component's prototype // during Vue.extend(). We only need to proxy props defined at // instantiation here. if (!(key in vm)) &#123; proxy(vm, `_props`, key) &#125; &#125; toggleObserving(true) &#125; 可以看到，该函数接收两个参数：当前Vue实例和当前实例规范化后的props选项。在函数内部首先定义了4个变量： propsData:父组件传入的真实props数据。 props:指向vm._props的指针，所有设置到props变量中的属性都会保存到vm._props中。 keys:指向vm.$options._propKeys的指针，缓存props对象中的key，将来更新props时只需遍历vm.$options._propKeys数组即可得到所有props的key。 isRoot:当前组件是否为根组件。 接着，判断当前组件是否为根组件，如果不是，那么不需要将props数组转换为响应式的，toggleObserving(false)用来控制是否将数据转换成响应式。 接着，遍历props选项拿到每一对键值，先将键名添加到keys中，然后调用validateProp函数（关于该函数下面会介绍）校验父组件传入的props数据类型是否匹配并获取到传入的值value，然后将键和值通过defineReactive函数添加到props（即vm._props）中。 添加完之后再判断这个key在当前实例vm中是否存在，如果不存在，则调用proxy函数在vm上设置一个以key为属性的代码，当使用vm[key]访问数据时，其实访问的是vm._props[key]。 validateProp函数分析export function validateProp (key,propOptions,propsData,vm) &#123; const prop = propOptions[key] const absent = !hasOwn(propsData, key) let value = propsData[key] // boolean casting const booleanIndex = getTypeIndex(Boolean, prop.type) if (booleanIndex > -1) &#123; if (absent &amp;&amp; !hasOwn(prop, 'default')) &#123; value = false &#125; else if (value === '' || value === hyphenate(key)) &#123; // only cast empty string / same name to boolean if // boolean has higher priority const stringIndex = getTypeIndex(String, prop.type) if (stringIndex &lt; 0 || booleanIndex &lt; stringIndex) &#123; value = true &#125; &#125; &#125; // check default value if (value === undefined) &#123; value = getPropDefaultValue(vm, prop, key) // since the default value is a fresh copy, // make sure to observe it. const prevShouldObserve = shouldObserve toggleObserving(true) observe(value) toggleObserving(prevShouldObserve) &#125; if (process.env.NODE_ENV !== 'production') &#123; assertProp(prop, key, value, vm, absent) &#125; return value &#125; 可以看到，该函数接收4个参数，分别是： key:遍历propOptions时拿到的每个属性名。 propOptions:当前实例规范化后的props选项。 propsData:父组件传入的真实props数据。 vm:当前实例。 在函数内部首先定义了3个变量，分别是： prop:当前key在propOptions中对应的值。 absent:当前key是否在propsData中存在，即父组件是否传入了该属性。 value:当前key在propsData中对应的值，即父组件对于该属性传入的真实值。 接着，判断prop的type属性是否是布尔类型（Boolean）,getTypeIndex函数用于判断prop的type属性中是否存在某种类型，如果存在，则返回该类型在type属性中的索引（因为type属性可以是数组），如果不存在则返回-1。 如果是布尔类型的话，那么有两种边界情况需要单独处理： 如果absent为true，即父组件没有传入该prop属性并且该属性也没有默认值的时候，将该属性值设置为false，如下： if (absent &amp;&amp; !hasOwn(prop, 'default')) &#123; value = false &#125; 如果父组件传入了该prop属性，那么需要满足以下几点： 该属性值为空字符串或者属性值与属性名相等； prop的type属性中不存在String类型； 如果prop的type属性中存在String类型，那么Boolean类型在type属性中的索引必须小于String类型的索引，即Boolean类型的优先级更高;则将该属性值设置为true，如下：if (value === '' || value === hyphenate(key)) &#123; const stringIndex = getTypeIndex(String, prop.type) if (stringIndex &lt; 0 || booleanIndex &lt; stringIndex) &#123; value = true &#125; &#125; 另外，在判断属性值与属性名相等的时候，是先将属性名由驼峰式转换成用-连接的字符串，下面的这几种写法，子组件的prop都将被设置为true： &lt;Child name>&lt;/Child> &lt;Child name=\"name\">&lt;/Child> &lt;Child userName=\"user-name\">&lt;/Child> 如果不是布尔类型，是其它类型的话，那就只需判断父组件是否传入该属性即可，如果没有传入，则该属性值为undefined，此时调用getPropDefaultValue函数（关于该函数下面会介绍）获取该属性的默认值，并将其转换成响应式，如下： if (value === undefined) &#123; value = getPropDefaultValue(vm, prop, key) // since the default value is a fresh copy, // make sure to observe it. const prevShouldObserve = shouldObserve toggleObserving(true) observe(value) toggleObserving(prevShouldObserve) &#125; 如果父组件传入了该属性并且也有对应的真实值，那么在非生产环境下会调用assertProp函数（关于该函数下面会介绍）校验该属性值是否与要求的类型相匹配。如下： if (process.env.NODE_ENV !== 'production' ) &#123; assertProp(prop, key, value, vm, absent) &#125; 最后将父组件传入的该属性的真实值返回。 初始化methods它的初始化函数定义位于源码的src/core/instance/state.js中，如下： function initMethods (vm, methods) &#123; const props = vm.$options.props for (const key in methods) &#123; if (process.env.NODE_ENV !== 'production') &#123; if (methods[key] == null) &#123; warn( `Method \"$&#123;key&#125;\" has an undefined value in the component definition. ` + `Did you reference the function correctly?`, vm ) &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; warn( `Method \"$&#123;key&#125;\" has already been defined as a prop.`, vm ) &#125; if ((key in vm) &amp;&amp; isReserved(key)) &#123; warn( `Method \"$&#123;key&#125;\" conflicts with an existing Vue instance method. ` + `Avoid defining component methods that start with _ or $.` ) &#125; &#125; vm[key] = methods[key] == null ? noop : bind(methods[key], vm) &#125; &#125; 初始化methods无非就干了三件事：判断method有没有？method的命名符不符合命名规范？如果method既有又符合规范那就把它挂载到vm实例上。下面我们就逐行分析源码，来过一遍这三件事。 首先，遍历methods选项中的每一个对象，在非生产环境下判断如果methods中某个方法只有key而没有value，即只有方法名没有方法体时，抛出异常：提示用户方法未定义。接着判断如果methods中某个方法名与props中某个属性名重复了，就抛出异常：提示用户方法名重复了。接着判断如果methods中某个方法名如果在实例vm中已经存在并且方法名是以_或$开头的，就抛出异常：提示用户方法名命名不规范。（其中，isReserved函数是用来判断字符串是否以_或$开头）最后，如果上述判断都没问题，那就method绑定到实例vm上，这样，我们就可以通过this.xxx来访问methods选项中的xxx方法了，如下： vm[key] = methods[key] == null ? noop : bind(methods[key], vm) 初始化data它的初始化函数定义位于源码的src/core/instance/state.js中，如下： function initData (vm) &#123; let data = vm.$options.data data = vm._data = typeof data === 'function' ? getData(data, vm) : data || &#123;&#125; if (!isPlainObject(data)) &#123; data = &#123;&#125; process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html##data-Must-Be-a-Function', vm ) &#125; // proxy data on instance const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) &#123; const key = keys[i] if (process.env.NODE_ENV !== 'production') &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( `Method \"$&#123;key&#125;\" has already been defined as a data property.`, vm ) &#125; &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `The data property \"$&#123;key&#125;\" is already declared as a prop. ` + `Use prop default value instead.`, vm ) &#125; else if (!isReserved(key)) &#123; proxy(vm, `_data`, key) &#125; &#125; // observe data observe(data, true /* asRootData */) &#125; 跟initMethods函数的逻辑有几分相似。就是通过一系列条件判断用户传入的data选项是否合法，最后将data转换成响应式并绑定到实例vm上。下面我们就来仔细看一下代码逻辑。 首先获取到用户传入的data选项，赋给变量data，同时将变量data作为指针指向vm._data，然后判断data是不是一个函数，如果是就调用getData函数获取其返回值，将其保存到vm._data中。如果不是，就将其本身保存到vm._data中。 let data = vm.$options.data data = vm._data = typeof data === 'function' ? getData(data, vm) : data || &#123;&#125; 我们知道，无论传入的data选项是不是一个函数，它最终的值都应该是一个对象，如果不是对象的话，就抛出警告：提示用户data应该是一个对象。 if (!isPlainObject(data)) &#123; data = &#123;&#125; process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html##data-Must-Be-a-Function', vm ) &#125; 接下来遍历data对象中的每一项，在非生产环境下判断data对象中是否存在某一项的key与methods中某个属性名重复，如果存在重复，就抛出警告：提示用户属性名重复。 if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( &#96;Method &quot;$&#123;key&#125;&quot; has already been defined as a data property.&#96;, vm ) &#125; &#125; 接着再判断是否存在某一项的key与prop中某个属性名重复，如果存在重复，就抛出警告：提示用户属性名重复。 if (props &amp;&amp; hasOwn(props, key)) &#123; process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; warn( &#96;The data property &quot;$&#123;key&#125;&quot; is already declared as a prop. &#96; + &#96;Use prop default value instead.&#96;, vm ) &#125; 如果都没有重复，则调用proxy函数将data对象中key不以_或$开头的属性代理到实例vm上，这样，我们就可以通过this.xxx来访问data选项中的xxx数据了。 最后，调用observe函数将data中的数据转化成响应式. observe(data, true /* asRootData */) 初始化computed计算属性computed相信大家一定不会陌生，在日常开发中肯定会经常用到，而且我们知道计算属性有一个很大的特点就是： 计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。首先，根据官方文档的使用示例，我们来回顾一下计算属性的用法: var vm = new Vue(&#123; data: &#123; a: 1 &#125;, computed: &#123; // 仅读取 aDouble: function () &#123; return this.a * 2 &#125;, // 读取和设置 aPlus: &#123; get: function () &#123; return this.a + 1 &#125;, set: function (v) &#123; this.a = v - 1 &#125; &#125; &#125; &#125;) vm.aPlus // => 2 vm.aPlus = 3 vm.a // => 2 vm.aDouble // => 4 computed选项中的属性值可以是一个函数，那么该函数默认为取值器getter，用于仅读取数据；还可以是一个对象，对象里面有取值器getter和存值器setter，用于读取和设置数据。 initComputed函数分析initComputed函数的定义位于源码的src/core/instance/state.js中，如下： function initComputed (vm: Component, computed: Object) &#123; const watchers = vm._computedWatchers = Object.create(null) const isSSR = isServerRendering() for (const key in computed) &#123; const userDef = computed[key] const getter = typeof userDef === 'function' ? userDef : userDef.get if (process.env.NODE_ENV !== 'production' &amp;&amp; getter == null) &#123; warn( `Getter is missing for computed property \"$&#123;key&#125;\".`, vm ) &#125; if (!isSSR) &#123; // create internal watcher for the computed property. watchers[key] = new Watcher( vm, getter || noop, noop, computedWatcherOptions ) &#125; if (!(key in vm)) &#123; defineComputed(vm, key, userDef) &#125; else if (process.env.NODE_ENV !== 'production') &#123; if (key in vm.$data) &#123; warn(`The computed property \"$&#123;key&#125;\" is already defined in data.`, vm) &#125; else if (vm.$options.props &amp;&amp; key in vm.$options.props) &#123; warn(`The computed property \"$&#123;key&#125;\" is already defined as a prop.`, vm) &#125; &#125; &#125; &#125; 可以看到，在函数内部，首先定义了一个变量watchers并将其赋值为空对象，同时将其作为指针指向vm._computedWatchers接着，遍历computed选项中的每一项属性，首先获取到每一项的属性值，记作userDef，然后判断userDef是不是一个函数，如果是函数，则该函数默认为取值器getter，将其赋值给变量getter；如果不是函数，则说明是一个对象，则取对象中的get属性作为取值器赋给变量getter。接着判断在非生产环境下如果上面两种情况取到的取值器不存在，则抛出警告：提示用户计算属性必须有取值器。接着判断如果不是在服务端渲染环境下，则创建一个watcher实例，并将当前循环到的的属性名作为键，创建的watcher实例作为值存入watchers对象中。最后，判断当前循环到的的属性名是否存在于当前实例vm上，如果存在，则在非生产环境下抛出警告；如果不存在，则调用defineComputed函数为实例vm上设置计算属性。 初始化watch根据官方文档的使用示例，我们来回顾一下watch选项的用法: var vm = new Vue(&#123; data: &#123; a: 1, b: 2, c: 3, d: 4, e: &#123; f: &#123; g: 5 &#125; &#125; &#125;, watch: &#123; a: function (val, oldVal) &#123; console.log('new: %s, old: %s', val, oldVal) &#125;, // methods选项中的方法名 b: 'someMethod', // 深度侦听，该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深 c: &#123; handler: function (val, oldVal) &#123; /* ... */ &#125;, deep: true &#125;, // 该回调将会在侦听开始之后被立即调用 d: &#123; handler: 'someMethod', immediate: true &#125;, // 调用多个回调 e: [ 'handle1', function handle2 (val, oldVal) &#123; /* ... */ &#125;, &#123; handler: function handle3 (val, oldVal) &#123; /* ... */ &#125;, &#125; ], // 侦听表达式 'e.f': function (val, oldVal) &#123; /* ... */ &#125; &#125; &#125;) vm.a = 2 // => new: 2, old: 1 watch选项的用法非常灵活。首先watch选项是一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。既然给用户提供的用法灵活，那么在代码中就需要按条件来判断，根据不同的用法做相应的处理。 initWatch函数分析function initWatch (vm, watch) &#123; for (const key in watch) &#123; const handler = watch[key] if (Array.isArray(handler)) &#123; for (let i = 0; i &lt; handler.length; i++) &#123; createWatcher(vm, key, handler[i]) &#125; &#125; else &#123; createWatcher(vm, key, handler) &#125; &#125; &#125; 可以看到，在函数内部会遍历watch选项，拿到每一项的key和对应的值handler。然后判断handler是否为数组，如果是数组则循环该数组并将数组中的每一项依次调用createWatcher函数来创建watcher；如果不是数组，则直接调用createWatcher函数来创建watcher。 createWatcher函数分析function createWatcher ( vm: Component, expOrFn: string | Function, handler: any, options?: Object ) &#123; if (isPlainObject(handler)) &#123; options = handler handler = handler.handler &#125; if (typeof handler === 'string') &#123; handler = vm[handler] &#125; return vm.$watch(expOrFn, handler, options) &#125; 可以看到，该函数接收4个参数，分别是： vm:当前实例； expOrFn:被侦听的属性表达式 handler:watch选项中每一项的值 options:用于传递给vm.$watch的选项对象 在该函数内部，首先会判断传入的handler是否为一个对象，如果是一个对象，那么就认为用户使用的是这种写法： watch: &#123; c: &#123; handler: function (val, oldVal) &#123; /* ... */ &#125;, deep: true &#125; &#125; 即带有侦听选项的写法，此时就将handler对象整体记作options，把handler对象中的handler属性作为真正的回调函数记作handler，如下： if (isPlainObject(handler)) &#123; options = handler handler = handler.handler &#125; 接着判断传入的handler是否为一个字符串，如果是一个字符串，那么就认为用户使用的是这种写法： watch: &#123; // methods选项中的方法名 b: 'someMethod', &#125; 即回调函数是methods选项中的一个方法名，我们知道，在初始化methods选项的时候会将选项中的每一个方法都绑定到当前实例上，所以此时我们只需从当前实例上取出该方法作为真正的回调函数记作handler，如下： if (typeof handler === 'string') &#123; handler = vm[handler] &#125; 如果既不是对象又不是字符串，那么我们就认为它是一个函数，就不做任何处理。","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://example.com/tags/vue2-0/"}]},{"title":"vue生命周期综述","slug":"vue-生命周期综述","date":"2021-07-24T16:00:00.000Z","updated":"2021-07-23T08:30:15.122Z","comments":true,"path":"2021/07/25/vue-生命周期综述/","link":"","permalink":"http://example.com/2021/07/25/vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%BC%E8%BF%B0/","excerpt":"","text":"在Vue中，把Vue实例从被创建出来到最终被销毁的这一过程称为Vue实例的生命周期，同时，在Vue实例生命周期的不同阶段Vue还提供了不同的钩子函数，以方便用户在不同的生命周期阶段做一些额外的事情 初始化阶段：为Vue实例上初始化一些属性，事件以及响应式数据； 模板编译阶段：将模板编译成渲染函数； 挂载阶段：将实例挂载到指定的DOM上，即将模板渲染到真实DOM中； 销毁阶段：将实例自身从父组件中删除，并取消依赖追踪及事件监听器；","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://example.com/tags/vue2-0/"}]},{"title":"vue模板编译-模板解析","slug":"vue-模板编译-模板解析","date":"2021-07-23T16:00:00.000Z","updated":"2021-07-23T09:48:56.630Z","comments":true,"path":"2021/07/24/vue-模板编译-模板解析/","link":"","permalink":"http://example.com/2021/07/24/vue-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91-%E6%A8%A1%E6%9D%BF%E8%A7%A3%E6%9E%90/","excerpt":"","text":"整体流程在模板解析阶段主要做的工作是把用户在标签内写的模板使用正则等方式解析成抽象语法树（AST）。而这一阶段在源码中对应解析器（parser）模块。 解析器，顾名思义，就是把用户所写的模板根据一定的解析规则解析出有效的信息，最后用这些信息形成AST。我们知道在模板内，除了有常规的HTML标签外，用户还会一些文本信息以及在文本信息中包含过滤器。而这些不同的内容在解析起来肯定需要不同的解析规则，所以解析器不可能只有一个，它应该除了有解析常规HTML的HTML解析器，还应该有解析文本的文本解析器以及解析文本中如果包含过滤器的过滤器解析器。 另外，文本信息和标签属性信息却又是存在于HTML标签之内的，所以在解析整个模板的时候它的流程应该是这样子的：HTML解析器是主线，先用HTML解析器进行解析整个模板，在解析过程中如果碰到文本内容，那就调用文本解析器来解析文本，如果碰到文本中包含过滤器那就调用过滤器解析器来解析。如下图所示： // 代码位置：/src/complier/parser/index.js /** * Convert HTML string to AST. */ export function parse(template, options) &#123; // ... parseHTML(template, &#123; warn, expectHTML: options.expectHTML, isUnaryTag: options.isUnaryTag, canBeLeftOpenTag: options.canBeLeftOpenTag, shouldDecodeNewlines: options.shouldDecodeNewlines, shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref, shouldKeepComment: options.comments, start (tag, attrs, unary) &#123; &#125;, end () &#123; &#125;, chars (text: string) &#123; &#125;, comment (text: string) &#123; &#125; &#125;) return root &#125; parse 函数就是解析器的主函数，在parse 函数内调用了parseHTML 函数对模板字符串进行解析，在parseHTML 函数解析模板字符串的过程中，如果遇到文本信息，就会调用文本解析器parseText函数进行文本解析；如果遇到文本中包含过滤器，就会调用过滤器解析器parseFilters函数进行解析 总结模板解析其实就是根据被解析内容的特点使用正则等方式将有效信息解析提取出来，根据解析内容的不同分为HTML解析器，文本解析器和过滤器解析器。而文本信息与过滤器信息又存在于HTML标签中，所以在解析器主线函数parse中先调用HTML解析器parseHTML 函数对模板字符串进行解析，如果在解析过程中遇到文本或过滤器信息则再调用相应的解析器进行解析，最终完成对整个模板字符串的解析 最终目的就是：把用户所写的模板转化成供Vue实例在挂载时可调用的render函数。或者你可以这样简单的理解为：模板编译就是一台机器，给它输入模板字符串，它就输出对应的render函数。","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://example.com/tags/vue2-0/"}]},{"title":"vue模板编译","slug":"vue-模板编译","date":"2021-07-22T16:00:00.000Z","updated":"2021-07-23T09:48:56.630Z","comments":true,"path":"2021/07/23/vue-模板编译/","link":"","permalink":"http://example.com/2021/07/23/vue-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/","excerpt":"","text":"模板编译把用户在标签中写的类似于原生HTML的内容进行编译，把原生HTML的内容找出来，再把非原生HTML找出来，经过一系列的逻辑处理生成渲染函数，也就是render函数的这一段过程称之为模板编译过程 整体渲染流程 模板编译内部流程抽象语法树AST抽象语法树，在计算机科学中，抽象语法树（AbstractSyntaxTree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现；而类似于if-condition-then这样的条件跳转语句，可以使用带有两个分支的节点来表示 具体流程 模板解析阶段：将一堆模板字符串用正则等方式解析成抽象语法树AST； 优化阶段：遍历AST，找出其中的静态节点，并打上标记； 代码生成阶段：将AST转换成渲染函数； export const createCompiler = createCompilerCreator(function baseCompile ( template: string, options: CompilerOptions ): CompiledResult &#123; // 模板解析阶段：用正则等方式解析 template 模板中的指令、class、style等数据，形成AST const ast = parse(template.trim(), options) if (options.optimize !== false) &#123; // 优化阶段：遍历AST，找出其中的静态节点，并打上标记； optimize(ast, options) &#125; // 代码生成阶段：将AST转换成渲染函数； const code = generate(ast, options) return &#123; ast, render: code.render, staticRenderFns: code.staticRenderFns &#125; &#125;) 总结大致分为三个阶段，分别是模板解析阶段、优化阶段和代码生成阶段","categories":[],"tags":[{"name":"vue.2.0","slug":"vue-2-0","permalink":"http://example.com/tags/vue-2-0/"}]},{"title":"diff算法","slug":"vue-diff算法","date":"2021-07-22T16:00:00.000Z","updated":"2021-07-23T09:48:56.630Z","comments":true,"path":"2021/07/23/vue-diff算法/","link":"","permalink":"http://example.com/2021/07/23/vue-diff%E7%AE%97%E6%B3%95/","excerpt":"","text":"创建节点 删除节点 更新节点 patch在Vue中，把 DOM-Diff过程叫做patch过程。patch,意为“补丁”，即指对旧的VNode修补，打补丁从而得到新的VNode，非常形象哈。那不管叫什么，其本质都是把对比新旧两份VNode的过程。我们在下面研究patch过程的时候，一定把握住这样一个思想：所谓旧的VNode(即oldVNode)就是数据变化之前视图所对应的虚拟DOM节点，而新的VNode是数据变化之后将要渲染的新的视图所对应的虚拟DOM节点，所以我们要以生成的新的VNode为基准，对比旧的oldVNode，如果新的VNode上有的节点而旧的oldVNode上没有，那么就在旧的oldVNode上加上去；如果新的VNode上没有的节点而旧的oldVNode上有，那么就在旧的oldVNode上去掉；如果某些节点在新的VNode和旧的oldVNode上都有，那么就以新的VNode为准，更新旧的oldVNode，从而让新旧VNode相同。总体来说就是以新的标准，多的加上去，少的删掉，将老的改成新的 创建节点 判断是否为元素节点只需判断该VNode节点是否有tag标签即可。如果有tag属性即认为是元素节点，则调用createElement方法创建元素节点，通常元素节点还会有子节点，那就递归遍历创建所有子节点，将所有子节点创建好之后insert插入到当前元素节点里面，最后把当前元素节点插入到DOM中。 判断是否为注释节点，只需判断VNode的isComment属性是否为true即可，若为true则为注释节点，则调用createComment方法创建注释节点，再插入到DOM中。 如果既不是元素节点，也不是注释节点，那就认为是文本节点，则调用createTextNode方法创建文本节点，再插入到DOM中。// 源码位置: /src/core/vdom/patch.js function createElm (vnode, parentElm, refElm) &#123; const data = vnode.data const children = vnode.children const tag = vnode.tag if (isDef(tag)) &#123; vnode.elm = nodeOps.createElement(tag, vnode) // 创建元素节点 createChildren(vnode, children, insertedVnodeQueue) // 创建元素节点的子节点 insert(parentElm, vnode.elm, refElm) // 插入到DOM中 &#125; else if (isTrue(vnode.isComment)) &#123; vnode.elm = nodeOps.createComment(vnode.text) // 创建注释节点 insert(parentElm, vnode.elm, refElm) // 插入到DOM中 &#125; else &#123; vnode.elm = nodeOps.createTextNode(vnode.text) // 创建文本节点 insert(parentElm, vnode.elm, refElm) // 插入到DOM中 &#125; &#125; 删除节点如果某些节点再新的VNode中没有而在旧的oldVNode中有，那么就需要把这些节点从旧的oldVNode中删除。删除节点非常简单，只需在要删除节点的父元素上调用removeChild方法即可。源码如下： function removeNode (el) &#123; const parent = nodeOps.parentNode(el) // 获取父节点 if (isDef(parent)) &#123; nodeOps.removeChild(parent, el) // 调用父节点的removeChild方法 &#125; &#125; 更新节点更新节点就是当某些节点在新的VNode和旧的oldVNode中都有时，我们就需要细致比较一下，找出不一样的地方进行更新。 如果VNode和oldVNode均为静态节点,我们说了，静态节点无论数据发生任何变化都与它无关，所以都为静态节点的话则直接跳过，无需处理。 &lt;p>我是不会变化的文字&lt;/p> 如果VNode是文本节点如果VNode是文本节点即表示这个节点内只包含纯文本，那么只需看oldVNode是否也是文本节点，如果是，那就比较两个文本是否不同，如果不同则把oldVNode里的文本改成跟VNode的文本一样。如果oldVNode不是文本节点，那么不论它是什么，直接调用setTextNode方法把它改成文本节点，并且文本内容跟VNode相同。 如果VNode是元素节点如果VNode是元素节点，则又细分以下两种情况 该节点包含子节点如果新的节点内包含了子节点，那么此时要看旧的节点是否包含子节点，如果旧的节点里也包含了子节点，那就需要递归对比更新子节点；如果旧的节点里不包含子节点，那么这个旧节点有可能是空节点或者是文本节点，如果旧的节点是空节点就把新的节点里的子节点创建一份然后插入到旧的节点里面，如果旧的节点是文本节点，则把文本清空，然后把新的节点里的子节点创建一份然后插入到旧的节点里面。 该节点不包含子节点如果该节点不包含子节点，同时它又不是文本节点，那就说明该节点是个空节点，那就好办了，不管旧节点之前里面都有啥，直接清空即可。// 更新节点 function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) &#123; // vnode与oldVnode是否完全一样？若是，退出程序 if (oldVnode === vnode) &#123; return &#125; const elm = vnode.elm = oldVnode.elm // vnode与oldVnode是否都是静态节点？若是，退出程序 if (isTrue(vnode.isStatic) &amp;&amp; isTrue(oldVnode.isStatic) &amp;&amp; vnode.key === oldVnode.key &amp;&amp; (isTrue(vnode.isCloned) || isTrue(vnode.isOnce)) ) &#123; return &#125; const oldCh = oldVnode.children const ch = vnode.children // vnode有text属性？若没有： if (isUndef(vnode.text)) &#123; // vnode的子节点与oldVnode的子节点是否都存在？ if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123; // 若都存在，判断子节点是否相同，不同则更新子节点 if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly) &#125; // 若只有vnode的子节点存在 else if (isDef(ch)) &#123; /** * 判断oldVnode是否有文本？ * 若没有，则把vnode的子节点添加到真实DOM中 * 若有，则清空Dom中的文本，再把vnode的子节点添加到真实DOM中 */ if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '') addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue) &#125; // 若只有oldnode的子节点存在 else if (isDef(oldCh)) &#123; // 清空DOM中的子节点 removeVnodes(elm, oldCh, 0, oldCh.length - 1) &#125; // 若vnode和oldnode都没有子节点，但是oldnode中有文本 else if (isDef(oldVnode.text)) &#123; // 清空oldnode文本 nodeOps.setTextContent(elm, '') &#125; // 上面两个判断一句话概括就是，如果vnode中既没有text，也没有子节点，那么对应的oldnode中有什么就清空什么 &#125; // 若有，vnode的text属性与oldVnode的text属性是否相同？ else if (oldVnode.text !== vnode.text) &#123; // 若不相同：则用vnode的text替换真实DOM的文本 nodeOps.setTextContent(elm, vnode.text) &#125; &#125; 总结Vue中的DOM-Diff算法：patch过程。patch过程干了三件事，分别是：创建节点，删除节点，更新节点。","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://example.com/tags/vue2-0/"}]},{"title":"vue虚拟dom","slug":"vue-虚拟dom","date":"2021-07-21T16:00:00.000Z","updated":"2021-07-23T09:48:56.630Z","comments":true,"path":"2021/07/22/vue-虚拟dom/","link":"","permalink":"http://example.com/2021/07/22/vue-%E8%99%9A%E6%8B%9Fdom/","excerpt":"","text":"虚拟DOM简介什么是虚拟dom所谓虚拟DOM，就是用一个JS对象来描述一个DOM节点，像如下示例: &lt;div class=\"a\" id=\"b\">我是内容&lt;/div> &#123; tag:'div', // 元素标签 attrs:&#123; // 属性 class:'a', id:'b' &#125;, text:'我是内容', // 文本内容 children:[] // 子元素 &#125; 为什么要有虚拟DOM？我们知道，Vue是数据驱动视图的，数据发生变化视图就要随之更新，在更新视图的时候难免要操作DOM,而操作真实DOM又是非常耗费性能的，这是因为浏览器的标准就把 DOM 设计的非常复杂，所以一个真正的 DOM 元素是非常庞大的，如下所示： let div = document.createElement('div') let str = '' for (const key in div) &#123; str += key + '' &#125; console.log(str) // 结果是非常长的 在页面直接操作一个dom是非常消耗新能的、所以我们再操作dom之前使用js模拟一个虚拟dom，在数据发生变化的时候通过新老虚拟dom进行比较（diff算法），从而直接更新需要改变的视图。 Vue中的虚拟DOMVNode类虚拟DOM就是用JS来描述一个真实的DOM节点。而在Vue中就存在了一个VNode类，通过这个类，我们就可以实例化出不同类型的虚拟DOM节点，源码如下 // 源码位置：src/core/vdom/vnode.js export default class VNode &#123; constructor ( tag?: string, data?: VNodeData, children?: ?Array&lt;VNode>, text?: string, elm?: Node, context?: Component, componentOptions?: VNodeComponentOptions, asyncFactory?: Function ) &#123; this.tag = tag /*当前节点的标签名*/ this.data = data /*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/ this.children = children /*当前节点的子节点，是一个数组*/ this.text = text /*当前节点的文本*/ this.elm = elm /*当前虚拟节点对应的真实dom节点*/ this.ns = undefined /*当前节点的名字空间*/ this.context = context /*当前组件节点对应的Vue实例*/ this.fnContext = undefined /*函数式组件对应的Vue实例*/ this.fnOptions = undefined this.fnScopeId = undefined this.key = data &amp;&amp; data.key /*节点的key属性，被当作节点的标志，用以优化*/ this.componentOptions = componentOptions /*组件的option选项*/ this.componentInstance = undefined /*当前节点对应的组件的实例*/ this.parent = undefined /*当前节点的父节点*/ this.raw = false /*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/ this.isStatic = false /*静态节点标志*/ this.isRootInsert = true /*是否作为跟节点插入*/ this.isComment = false /*是否为注释节点*/ this.isCloned = false /*是否为克隆节点*/ this.isOnce = false /*是否有v-once指令*/ this.asyncFactory = asyncFactory this.asyncMeta = undefined this.isAsyncPlaceholder = false &#125; get child (): Component | void &#123; return this.componentInstance &#125; &#125; 从上面的代码中可以看出：VNode类中包含了描述一个真实DOM节点所需要的一系列属性，如tag表示节点的标签名，text表示节点中包含的文本，children表示该节点包含的子节点等。通过属性之间不同的搭配，就可以描述出各种类型的真实DOM节点。 VNode的类型 注释节点 文本节点 元素节点 组件节点 函数式组件节点 克隆节点 VNode的作用我们在视图渲染之前，把写好的template模板先编译成VNode并缓存下来，等到数据发生变化页面需要重新渲染的时候，我们把数据发生变化后生成的VNode与前一次缓存下来的VNode进行对比，找出差异，然后有差异的VNode对应的真实DOM节点就是需要重新渲染的节点，最后根据有差异的VNode创建出真实的DOM节点再插入到视图中，最终完成一次视图更新 总结本章首先介绍了虚拟DOM的一些基本概念和为什么要有虚拟DOM，其实说白了就是以JS的计算性能来换取操作真实DOM所消耗的性能。接着从源码角度我们知道了在Vue中是通过VNode类来实例化出不同类型的虚拟DOM节点，并且学习了不同类型节点生成的属性的不同，所谓不同类型的节点其本质还是一样的，都是VNode类的实例，只是在实例化时传入的属性参数不同罢了。最后探究了VNode的作用，有了数据变化前后的VNode，我们才能进行后续的DOM-Diff找出差异，最终做到只更新有差异的视图，从而达到尽可能少的操作真实DOM的目的，以节省性能","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://example.com/tags/vue2-0/"}]},{"title":"async、await","slug":"async、await","date":"2021-07-20T16:00:00.000Z","updated":"2021-07-23T09:48:56.630Z","comments":true,"path":"2021/07/21/async、await/","link":"","permalink":"http://example.com/2021/07/21/async%E3%80%81await/","excerpt":"","text":"async 和 await 在干什么任意一个名称都是有意义的，先从字面意思来理解。async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。 async这个问题的关键在于，async 函数是怎么处理它的返回值的！我们当然希望它能直接通过 return 语句返回我们想要的值，但是如果真是这样，似乎就没 await 什么事了。所以，写段代码来试试，看它到底会返回什么： async function testAsync() &#123; return \"hello async\"; &#125; const result = testAsync(); console.log(result); // Promise &#123; 'hello async' &#125; ——输出的是一个 Promise 对象。 所以，async 函数返回的是一个 Promise 对象。从文档中也可以得到这个信息。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。 Promise.resolve(x) 可以看作是 new Promise(resolve =&gt; resolve(x)) 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。 async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，我们当然应该用原来的方式：then() 链来处理这个 Promise 对象，就像这样 testAsync().then(v => &#123; console.log(v); // 输出 hello async &#125;); await一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。 因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行 function getSomething() &#123; return \"something\"; &#125; async function testAsync() &#123; return Promise.resolve(\"hello async\"); &#125; async function test() &#123; const v1 = await getSomething(); const v2 = await testAsync(); console.log(v1, v2); &#125; test(); await 等到了要等的，然后呢await 等到了它要等的东西，一个 Promise 对象，或者其它值，然后呢？我不得不先说，await 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西。 如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。 如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。 async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。 async/await -&gt; promisefunction step1(n) &#123; console.log(`step1 with $&#123;n&#125;`); return takeLongTime(n); &#125; function step2(m, n) &#123; console.log(`step2 with $&#123;m&#125; and $&#123;n&#125;`); return takeLongTime(m + n); &#125; function step3(k, m, n) &#123; console.log(`step3 with $&#123;k&#125;, $&#123;m&#125; and $&#123;n&#125;`); return takeLongTime(k + m + n); &#125; // asyne/await async function doIt() &#123; console.time(\"doIt\"); const time1 = 300; const time2 = await step1(time1); const time3 = await step2(time1, time2); const result = await step3(time1, time2, time3); console.log(`result is $&#123;result&#125;`); console.timeEnd(\"doIt\"); &#125; doIt(); // promise function doIt() &#123; console.time(\"doIt\"); const time1 = 300; step1(time1) .then(time2 => &#123; return step2(time1, time2) .then(time3 => [time1, time2, time3]); &#125;) .then(times => &#123; const [time1, time2, time3] = times; return step3(time1, time2, time3); &#125;) .then(result => &#123; console.log(`result is $&#123;result&#125;`); console.timeEnd(\"doIt\"); &#125;); &#125; doIt(); 看起来更像是同步操作","categories":[],"tags":[{"name":"异步","slug":"异步","permalink":"http://example.com/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"vue双向绑定原理","slug":"vue-双向绑定原理","date":"2021-07-20T16:00:00.000Z","updated":"2021-07-23T09:48:56.630Z","comments":true,"path":"2021/07/21/vue-双向绑定原理/","link":"","permalink":"http://example.com/2021/07/21/vue-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/","excerpt":"","text":"Vue双向绑定分为两个部分：对象和数组 object双向绑定原理实现方式 通过Object.defineProperty()定义一个observer类，将正常的object转换成一个可观测的object，并且加上了_ob_属性，如果读取了会通过触发get，如果改变了会触发set // 源码位置：src/core/observer/index.js /** * Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象 */ export class Observer &#123; constructor (value) &#123; this.value = value // 给value新增一个__ob__属性，值为该value的Observer实例 // 相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作 def(value,'__ob__',this) if (Array.isArray(value)) &#123; // 当value为数组时的逻辑 // ... &#125; else &#123; this.walk(value) &#125; &#125; walk (obj: Object) &#123; const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]) &#125; &#125; &#125; /** * 使一个对象转化成可观测对象 * @param &#123; Object &#125; obj 对象 * @param &#123; String &#125; key 对象的key * @param &#123; Any &#125; val 对象的某个key的值 */ function defineReactive (obj,key,val) &#123; // 如果只传了obj和key，那么val = obj[key] if (arguments.length === 2) &#123; val = obj[key] &#125; if(typeof val === 'object')&#123; new Observer(val) &#125; Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get()&#123; console.log(`$&#123;key&#125;属性被读取了`); return val; &#125;, set(newVal)&#123; if(val === newVal)&#123; return &#125; console.log(`$&#123;key&#125;属性被修改了`); val = newVal; &#125; &#125;) &#125; 收集依赖，也就是收集那里用到了这个数据的。具体做法是定义一个dep类，其实就是一个数组，那里用到了就在数据里面push进去。dep里面有几个方法，在observer的get里面depend负责收集依赖（其实就是Watcher），在set里面notify通知所有依赖更新（通知的也是Watcher，最后由Watcher通知视图更新） // 源码位置：src/core/observer/dep.js export default class Dep &#123; constructor () &#123; this.subs = [] &#125; addSub (sub) &#123; this.subs.push(sub) &#125; // 删除一个依赖 removeSub (sub) &#123; remove(this.subs, sub) &#125; // 添加一个依赖 depend () &#123; if (window.target) &#123; this.addSub(window.target) &#125; &#125; // 通知所有依赖更新 notify () &#123; const subs = this.subs.slice() for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125; &#125; /** * Remove an item from an array */ export function remove (arr, item) &#123; if (arr.length) &#123; const index = arr.indexOf(item) if (index > -1) &#123; return arr.splice(index, 1) &#125; &#125; &#125; Watcher类，Watcher先把自己设置到全局唯一的指定位置（window.target），然后读取数据。因为读取了数据，所以会触发这个数据的getter。接着，在getter中就会从全局唯一的那个位置读取当前正在读取数据的Watcher，并把这个watcher收集到Dep中去。收集好之后，当数据发生变化时，会向Dep中的每个Watcher发送通知。通过这样的方式，Watcher可以主动去订阅任意一个数据的变化。 export default class Watcher &#123; constructor (vm,expOrFn,cb) &#123; this.vm = vm; this.cb = cb; this.getter = parsePath(expOrFn) this.value = this.get() &#125; get () &#123; window.target = this; const vm = this.vm let value = this.getter.call(vm, vm) window.target = undefined; return value &#125; update () &#123; const oldValue = this.value this.value = this.get() this.cb.call(this.vm, this.value, oldValue) &#125; &#125; /** * Parse simple path. * 把一个形如'data.a.b.c'的字符串路径所表示的值，从真实的data对象中取出来 * 例如： * data = &#123;a:&#123;b:&#123;c:2&#125;&#125;&#125; * parsePath('a.b.c')(data) // 2 */ const bailRE = /[^\\w.$]/ export function parsePath (path) &#123; if (bailRE.test(path)) &#123; return &#125; const segments = path.split('.') return function (obj) &#123; for (let i = 0; i &lt; segments.length; i++) &#123; if (!obj) return obj = obj[segments[i]] &#125; return obj &#125; &#125; 总结Data通过observer转换成了getter/setter的形式来追踪变化。当外界通过Watcher读取数据时，会触发getter从而将Watcher添加到依赖中。当数据发生了变化时，会触发setter，从而向Dep中的依赖（即Watcher）发送通知。Watcher接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。 不足虽然我们通过Object.defineProperty方法实现了对object数据的可观测，但是这个方法仅仅只能观测到object数据的取值及设置值，当我们向object数据里添加一对新的key/value或删除一对已有的key/value时，它是无法观测到的，导致当我们对object数据添加或删除值时，无法通知依赖，无法驱动视图进行响应式更新。 当然，Vue也注意到了这一点，为了解决这一问题，Vue增加了两个全局API:Vue.set和Vue.delete，这两个API的实现原理将会在后面学习全局API的时候说到。 Array双向绑定原理为什么Object数据和Array型数据会有两种不同的变化侦测方式？ 这是因为对于Object数据我们使用的是JS提供的对象原型上的方法Object.defineProperty，而这个方法是对象原型上的，所以Array无法使用这个方法，所以我们需要对Array型数据设计一套另外的变化侦测机制。 万变不离其宗，虽然对Array型数据设计了新的变化侦测机制，但是其根本思路还是不变的。那就是：还是在获取数据时收集依赖，数据变化时通知依赖更新。 实现方式 收集依赖 data()&#123; return &#123; arr:[1,2,3] &#125; &#125; arr这个数据始终都存在于一个object数据对象中，而且我们也说了，谁用到了数据谁就是依赖，那么要用到arr这个数据，是不是得先从object数据对象中获取一下arr数据，而从object数据对象中获取arr数据自然就会触发arr的getter，所以我们就可以在getter中收集依赖。总结一句话就是：Array型数据还是在getter中收集依赖。 使Array型数据可观测 let arr = [1,2,3] arr.push(4) Array.prototype.newPush = function(val)&#123; console.log('arr被修改了') this.push(val) &#125; arr.newPush(4) 在上面这个例子中，我们针对数组的原生push方法定义个一个新的newPush方法，这个newPush方法内部调用了原生push方法，这样就保证了新的newPush方法跟原生push方法具有相同的功能，而且我们还可以在新的newPush方法内部干一些别的事情，比如通知变化 数组方法拦截器在Vue中创建了一个数组方法拦截器，它拦截在数组实例与Array.prototype之间，在拦截器内重写了操作数组的一些方法，当数组实例使用操作数组方法时，其实使用的是拦截器中重写的方法，而不再使用Array.prototype上的原生方法 const arrayProto = Array.prototype // 创建一个对象作为拦截器 export const arrayMethods = Object.create(arrayProto) // 改变数组自身内容的7个方法 const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse' ] /** * Intercept mutating methods and emit events */ methodsToPatch.forEach(function (method) &#123; const original = arrayProto[method] // 缓存原生方法 Object.defineProperty(arrayMethods, method, &#123; enumerable: false, configurable: true, writable: true, value:function mutator(...args)&#123; const result = original.apply(this, args) return result &#125; &#125;) &#125;) 在上面的代码中，首先创建了继承自Array原型的空对象arrayMethods，接着在arrayMethods上使用object.defineProperty方法将那些可以改变数组自身的7个方法遍历逐个进行封装。最后，当我们使用push方法的时候，其实用的是arrayMethods.push，而arrayMethods.push就是封装的新函数mutator，也就后说，实标上执行的是函数mutator，而mutator函数内部执行了original函数，这个original函数就是Array.prototype上对应的原生方法。 那么，接下来我们就可以在mutator函数中做一些其他的事，比如说发送变化通知。 使用拦截器// 源码位置：/src/core/observer/index.js export class Observer &#123; constructor (value) &#123; this.value = value if (Array.isArray(value)) &#123; const augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) &#125; else &#123; this.walk(value) &#125; &#125; &#125; // 能力检测：判断__proto__是否可用，因为有的浏览器不支持该属性 export const hasProto = '__proto__' in &#123;&#125; const arrayKeys = Object.getOwnPropertyNames(arrayMethods) /** * Augment an target Object or Array by intercepting * the prototype chain using __proto__ */ function protoAugment (target, src: Object, keys: any) &#123; target.__proto__ = src &#125; /** * Augment an target Object or Array by defining * hidden properties. */ /* istanbul ignore next */ function copyAugment (target: Object, src: Object, keys: Array&lt;string>) &#123; for (let i = 0, l = keys.length; i &lt; l; i++) &#123; const key = keys[i] def(target, key, src[key]) &#125; &#125; 依赖收集// 源码位置：/src/core/observer/index.js export class Observer &#123; constructor (value) &#123; this.value = value this.dep = new Dep() // 实例化一个依赖管理器，用来收集数组依赖 if (Array.isArray(value)) &#123; const augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) &#125; else &#123; this.walk(value) &#125; &#125; &#125; function defineReactive (obj,key,val) &#123; let childOb = observe(val) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get()&#123; if (childOb) &#123; childOb.dep.depend() &#125; return val; &#125;, set(newVal)&#123; if(val === newVal)&#123; return &#125; val = newVal; dep.notify() // 在setter中通知依赖更新 &#125; &#125;) &#125; /** * Attempt to create an observer instance for a value, * returns the new observer if successfully observed, * or the existing observer if the value already has one. * 尝试为value创建一个0bserver实例，如果创建成功，直接返回新创建的Observer实例。 * 如果 Value 已经存在一个Observer实例，则直接返回它 */ export function observe (value, asRootData)&#123; if (!isObject(value) || value instanceof VNode) &#123; return &#125; let ob if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__ &#125; else &#123; ob = new Observer(value) &#125; return ob &#125; 通知依赖我们只要能访问到被转化成响应式的数据value即可，因为vaule上的__ob__就是其对应的Observer类实例，有了Observer类实例我们就能访问到它上面的依赖管理器，然后只需调用依赖管理器的dep.notify()方法，让它去通知依赖更新即可 /** * Intercept mutating methods and emit events */ methodsToPatch.forEach(function (method) &#123; const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) &#123; const result = original.apply(this, args) const ob = this.__ob__ // notify change ob.dep.notify() return result &#125;) &#125;) 不足前文中我们说过，对于数组变化侦测是通过拦截器实现的，也就是说只要是通过数组原型上的方法对数组进行操作就都可以侦测到，但是别忘了，我们在日常开发中，还可以通过数组的下标来操作数据，如下 let arr = [1,2,3] arr[0] = 5; // 通过数组下标修改数组中的数据 arr.length = 0 // 通过修改数组长度清空数组 而使用上述例子中的操作方式来修改数组是无法侦测到的。 同样，Vue也注意到了这个问题， 为了解决这一问题，Vue增加了两个全局API:Vue.set和Vue.delete，这两个API的实现原理将会在后面学习全局API的时候说到 总结首先我们分析了对于Array型数据也在getter中进行依赖收集；其次我们发现，当数组数据被访问时我们轻而易举可以知道，但是被修改时我们却很难知道，为了解决这一问题，我们创建了数组方法拦截器，从而成功的将数组数据变的可观测。接着我们对数组的依赖收集及数据变化如何通知依赖进行了深入分析；最后我们发现Vue不但对数组自身进行了变化侦测，还对数组中的每一个元素以及新增的元素都进行了变化侦测","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://example.com/tags/vue2-0/"}]},{"title":"浏览器渲染","slug":"http-浏览器渲染","date":"2021-07-20T16:00:00.000Z","updated":"2021-07-21T02:13:18.222Z","comments":true,"path":"2021/07/21/http-浏览器渲染/","link":"","permalink":"http://example.com/2021/07/21/http-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/","excerpt":"","text":"整体我觉得分为两个部分获取html文件的过程渲染过程 获取html文件的过程浏览器的地址栏输入URL并按下回车。浏览器查找当前URL是否存在缓存，并比较缓存是否过期。DNS解析URL对应的IP。根据IP建立TCP连接（三次握手）。HTTP发起请求。服务器处理请求，浏览器接收HTTP响应。渲染页面，构建DOM树。关闭TCP连接（四次挥手）。 渲染过程1、当用户输入一个URL时，浏览器就会向服务器发出一个请求，请求URL对应的资源2、接受到服务器的响应内容后，浏览器的HTML解析器，会将HTML文件解析成一棵DOM树，DOM树的构建是一个深度遍历的过程，当前节点的所有子节点都构建完成以后，才会去构建当前节点的下一个兄弟节点。3、将CSS解析成CSSOM树（CSS Rule Tree）4、根据DOM树和CSSOM树，来构建Render Tree（渲染树）,注意渲染树，并不等于DOM树，因为一些像head或display:none的东西，就没有必要放在渲染树中了。5、有了Render Tree，浏览器已经能知道网页中有哪些节点，各个节点的CSS定义，以及它们的从属关系，下一步操作就是Layout,顾名思义，就是计算出每个节点在屏幕中的位置。6、Layout后，浏览器已经知道哪些节点要显示，每个节点的CSS属性是什么，每个节点在屏幕中的位置是哪里，就进入了最后一步painting,按照算出来的规则，通过显卡，把内容画到屏幕上。 这里还要说两个概念，一个是Reflow，另一个是Repaint。这两个不是一回事。Repaint（重绘） ——改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。Reflow（重排） ——元件的几何尺寸变了，我们需要重新验证并计算Render Tree。是Render Tree的一部分或全部发生了变化。","categories":[],"tags":[{"name":"http","slug":"http","permalink":"http://example.com/tags/http/"}]},{"title":"路由模式","slug":"路由模式","date":"2021-07-20T06:49:57.663Z","updated":"2021-07-23T09:48:56.629Z","comments":true,"path":"2021/07/20/路由模式/","link":"","permalink":"http://example.com/2021/07/20/%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"路由模式 hash模式这里的 hash 就是指 url 尾巴后的 # 号以及后面的字符。这里的 # 和 css 里的 # 是一个意思。hash 也 称作 锚点，本身是用来做页面定位的，她可以使对应 id 的元素显示在可视区域内。 由于 hash 值变化不会导致浏览器向服务器发出请求，而且 hash 改变会触发 hashchange 事件，浏览器的进后退也能对其进行控制，所以人们在 html5 的 history 出现前，基本都是使用 hash 来实现前端路由的。 window.location.hash = 'qq' // 设置 url 的 hash，会在当前url后加上 '#qq' var hash = window.location.hash // '#qq' window.addEventListener('hashchange', function()&#123; // 监听hash变化，点击浏览器的前进后退会触发 &#125;) history模式已经有 hash 模式了，而且 hash 能兼容到IE8， history 只能兼容到 IE10，为什么还要搞个 history 呢？首先，hash 本来是拿来做页面定位的，如果拿来做路由的话，原来的锚点功能就不能用了。其次，hash 的传参是基于 url 的，如果要传递复杂的数据，会有体积的限制，而 history 模式不仅可以在url里放参数，还可以将数据存放在一个特定的对象中。 window.history.pushState(state, title, url) // state：需要保存的数据，这个数据在触发popstate事件时，可以在event.state里获取 // title：标题，基本没用，一般传 null // url：设定新的历史记录的 url。新的 url 与当前 url 的 origin 必须是一樣的，否则会抛出错误。url可以是绝对路径，也可以是相对路径。 //如 当前url是 https://www.baidu.com/a/,执行history.pushState(null, null, './qq/')，则变成 https://www.baidu.com/a/qq/， //执行history.pushState(null, null, '/qq/')，则变成 https://www.baidu.com/qq/ window.history.replaceState(state, title, url) // 与 pushState 基本相同，但她是修改当前历史记录，而 pushState 是创建新的历史记录 window.addEventListener(\"popstate\", function() &#123; // 监听浏览器前进后退事件，pushState 与 replaceState 方法不会触发 &#125;); window.history.back() // 后退 window.history.forward() // 前进 window.history.go(1) // 前进一步，-2为后退两步，window.history.lengthk可以查看当前历史堆栈中页面的数量","categories":[],"tags":[{"name":"router","slug":"router","permalink":"http://example.com/tags/router/"}]},{"title":"Promise","slug":"promise","date":"2021-07-19T16:00:00.000Z","updated":"2021-07-23T09:48:56.629Z","comments":true,"path":"2021/07/20/promise/","link":"","permalink":"http://example.com/2021/07/20/promise/","excerpt":"","text":"promise是什么？1、主要用于异步计算2、可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果3、可以在对象之间传递和操作promise，帮助我们处理队列 异步回调的问题 之前处理异步是通过纯粹的回调函数的形式进行处理 很容易进入到回调地狱中，剥夺了函数return的能力 问题可以解决，但是难以读懂，维护困难 稍有不慎就会踏入回调地狱 - 嵌套层次深，不好维护 new Promisenew Promise( function (resolve, reject) &#123; // 一段耗时的异步操作 resolve('成功') // 数据处理完成 // reject('失败') // 数据处理出错 &#125; ).then( (res) => &#123;console.log(res)&#125;, // 成功 (err) => &#123;console.log(err)&#125; // 失败 ) Promise.all() 批量执行Promise.all([p1, p2, p3])用于将多个promise实例，包装成一个新的Promise实例，返回的实例就是普通的promise它接收一个数组作为参数数组里可以是Promise对象，也可以是别的值，只有Promise会等待状态改变当所有的子Promise都完成，该Promise完成，返回值是全部值得数组有任何一个失败，该Promise失败，返回值是第一个失败的子Promise结果 //切菜 function cutUp()&#123; console.log('开始切菜。'); var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('切菜完毕！'); resolve('切好的菜'); &#125;, 1000); &#125;); return p; &#125; //烧水 function boil()&#123; console.log('开始烧水。'); var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('烧水完毕！'); resolve('烧好的水'); &#125;, 1000); &#125;); return p; &#125; Promise.all([cutUp(), boil()]) .then((result) => &#123; console.log('准备工作完毕'); console.log(result); &#125;) Promise.race() 它有任意一个完成就算完成let p1 = new Promise(resolve => &#123; setTimeout(() => &#123; resolve('I\\`m p1 ') &#125;, 1000) &#125;); let p2 = new Promise(resolve => &#123; setTimeout(() => &#123; resolve('I\\`m p2 ') &#125;, 2000) &#125;); Promise.race([p1, p2]) .then(value => &#123; console.log(value) &#125;) 回调地狱和promise对比 回调地狱/*** 第一步：找到北京的id 第二步：根据北京的id -> 找到北京公司的id 第三步：根据北京公司的id -> 找到北京公司的详情 目的：模拟链式调用、回调地狱 ***/ // 回调地狱 // 请求第一个API: 地址在北京的公司的id $.ajax(&#123; url: 'https://www.easy-mock.com/mock/5a52256ad408383e0e3868d7/lagou/city', success (resCity) &#123; let findCityId = resCity.filter(item => &#123; if (item.id == 'c1') &#123; return item &#125; &#125;)[0].id $.ajax(&#123; // 请求第二个API: 根据上一个返回的在北京公司的id “findCityId”，找到北京公司的第一家公司的id url: 'https://www.easy-mock.com/mock/5a52256ad408383e0e3868d7/lagou/position-list', success (resPosition) &#123; let findPostionId = resPosition.filter(item => &#123; if(item.cityId == findCityId) &#123; return item &#125; &#125;)[0].id // 请求第三个API: 根据上一个API的id(findPostionId)找到具体公司，然后返回公司详情 $.ajax(&#123; url: 'https://www.easy-mock.com/mock/5a52256ad408383e0e3868d7/lagou/company', success (resCom) &#123; let comInfo = resCom.filter(item => &#123; if (findPostionId == item.id) &#123; return item &#125; &#125;)[0] console.log(comInfo) &#125; &#125;) &#125; &#125;) &#125; &#125;) // Promise 写法 // 第一步：获取城市列表 const cityList = new Promise((resolve, reject) => &#123; $.ajax(&#123; url: 'https://www.easy-mock.com/mock/5a52256ad408383e0e3868d7/lagou/city', success (res) &#123; resolve(res) &#125; &#125;) &#125;) // 第二步：找到城市是北京的id cityList.then(res => &#123; let findCityId = res.filter(item => &#123; if (item.id == 'c1') &#123; return item &#125; &#125;)[0].id findCompanyId().then(res => &#123; // 第三步（2）：根据北京的id -> 找到北京公司的id let findPostionId = res.filter(item => &#123; if(item.cityId == findCityId) &#123; return item &#125; &#125;)[0].id // 第四步（2）：传入公司的id companyInfo(findPostionId) &#125;) &#125;) // 第三步（1）：根据北京的id -> 找到北京公司的id function findCompanyId () &#123; let aaa = new Promise((resolve, reject) => &#123; $.ajax(&#123; url: 'https://www.easy-mock.com/mock/5a52256ad408383e0e3868d7/lagou/position-list', success (res) &#123; resolve(res) &#125; &#125;) &#125;) return aaa &#125; // 第四步：根据上一个API的id(findPostionId)找到具体公司，然后返回公司详情 function companyInfo (id) &#123; let companyList = new Promise((resolve, reject) => &#123; $.ajax(&#123; url: 'https://www.easy-mock.com/mock/5a52256ad408383e0e3868d7/lagou/company', success (res) &#123; let comInfo = res.filter(item => &#123; if (id == item.id) &#123; return item &#125; &#125;)[0] console.log(comInfo) &#125; &#125;) &#125;) &#125;","categories":[],"tags":[]},{"title":"闭包","slug":"js-闭包","date":"2021-07-18T16:00:00.000Z","updated":"2021-07-23T09:48:56.630Z","comments":true,"path":"2021/07/19/js-闭包/","link":"","permalink":"http://example.com/2021/07/19/js-%E9%97%AD%E5%8C%85/","excerpt":"","text":"闭包是基于词法作用域书写代码时所产生的自然结果 闭包的产生：函数在被定义的地方之外被执行就会产生闭包！！！ function foo() &#123; var a = 2; function bar()&#123; console.log(a); &#125; return bar; &#125; var bza = foo(); baz(); // 2 这就是闭包！ 通常情况下foo执行之后整个内部作用域都会被销毁，因为引擎会销毁不再使用的空间来释放内存空间。 然而闭包会阻止这一情况的发生，会让作用域依然存在，因为bar函数还在使用foo这个作用域，需要给bar在任何时候执行提供支持。所以foo的作用域不会被销毁，bar依然持有对该作用域的引用，这个引用就是闭包！ ==无论通过何种手段将内部函数传递到所在的词法作用域以外，他都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。== function wait(message)&#123; setTimeout( function timer() &#123; console.log(message); &#125;,1000) &#125; wait('hello') wait执行1000毫秒以后，他的内部作用域并不会消失，还能保持message的引用。 ==只要是使用了回调函数，实际上就是在使用闭包。== 闭包和循环for(var i = 1;i &lt;= 5; i++;)&#123; setTimeout(function timer() &#123; console.log(i); &#125;,1*1000) &#125; // 每秒一次输出五个6 这个循环终止的条件是6.条件首次成立的时候i === 6，因此输出的显示是循环结束时i的值。因为这里所用的i，是同一个作用域下的i，所有的函数共享一个i。 for(var i = 1;i &lt;= 5; i++;)&#123; (function() &#123; setTimeout(function timer() &#123; console.log(i); &#125;,1*1000) &#125;(); &#125; //这样也不行 因为我们的IIFE的作用域是空的，我们使用的依然是外层的i，他要包含一点实质的内容才能够我们使用。 for(var i = 1;i &lt;= 5; i++;)&#123; (function(j) &#123; setTimeout(function timer() &#123; console.log(j); &#125;,j*1000) &#125;(i); &#125; // 这样就达到我们预期的目的，每秒一个，一次输出1-5 重返块作用域前面说let可以劫持块级作用域，，并且在这个块级作用域中声明一个变量。看下面代码 for(var i = 1; i &lt;= 5; i++) &#123; let j = i; setTimeout(function timer() &#123; console.log(j); &#125;,j*1000) &#125;; 还可以更完善 for(let i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;,i*1000) &#125;; 模块function foo()&#123; var a = 'cool'; var b = [1,2,3]; function bar() &#123; console.log(a); &#125; function baz() &#123; console.log(b); &#125; &#125; 这里并没有明显的闭包，只有两个私有数据变量a和b，以及bar和baz两个内部函数，他们的词法作用域就是闭包，也就是foo（）的内部作用域。 function CoolModule() &#123; var something = 'cool'; var another = [1,2,3]; function doSomething() &#123; console.log(something)); &#125; function doAnother() &#123; console.log(another.join(\"!\")); &#125; return &#123; doSomething: doSomething, doAnother: doAnother, &#125;; &#125; var foo = CoolModule; foo.doSomething(); // cool foo.doAnother(); // 1!2!3 首先，CoolModule() 只是一个函数，必须通过调用它来创建一个模块实例，如果不执行外部函数，内部作用域和闭包都无法被创建。 其次，CoolModule() 返回一个用对象字面量语法来表示的对象，这个返回的对象中含有内部函数，而不是内部数据变量的引用。我们保持内部数据变量是隐藏且私有状态。 这个对象类型的返回值最终被赋值给外部变量foo，然后我们就可以通过它来访问API中的属性方法。 模块模式必须具有两个条件 必须有外部的封闭函数，该函数必须至少被调用一次。（每次调用都会创建一个新的模块实例） 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。 一个具有函数属性的对象本身并不是真正的模块。从方便观察角度来看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。 改进上面的代码 var foo = (function CoolModule() &#123; var something = 'cool'; var another = [1,2,3]; function doSomething() &#123; console.log(something)); &#125; function doAnother() &#123; console.log(another.join(\"!\")); &#125; return &#123; doSomething: doSomething, doAnother: doAnother, &#125;; &#125;)(); foo.doSomething(); // cool foo.doAnother(); // 1!2!3 模块是普通函数，因此也可以传参。 function CoolModule(id) &#123; function doSomething() &#123; console.log(id); &#125; return &#123; doSomething: doSomething, &#125;; &#125; var foo = CoolModule('foo'); foo.doSomething(); // foo 模块另一个简单但又强大的用法是命名将要作为公共API返回的对象。 var foo = (function Cool(id)&#123; function change() &#123; publicAPI.identify = identify2; &#125;; function identify1() &#123; console.log(id); &#125;; function identify2() &#123; console.log(id.toUppeCase()); &#125;; var publicAPI = &#123; change: change, identify: identify1 &#125; return publicAPI; &#125;)('foo module'); foo.identify(); // foo module foo.change(); foo.identify(); // FOO MODULE 通过模块在实例的内部保留的公共API对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法，以及修改他们的值。 现代的模块机制创建一个模块 var MyModules = (function Manager()&#123; // 存储方法 var modules = &#123;&#125;; // 添加方法 function define(name,deps,impl)&#123; for(var i = 0;i &lt; deps.length; i++) &#123; deps[i] = modules[deps[i]]; &#125; modules[name] = impl.apply(impl,deps); &#125; // 根据名字获取方法 function get(name) &#123; return modules[name]; &#125; // 返回内部函数（方法） return &#123; define: define, get: get &#125; &#125;)() Function.apply(obj,args)方法能接收两个参数 obj：这个对象将代替Function类里this对象 args：这个是数组，它将作为参数传给Function(args–&gt;arguments) 使用它来定义模块： MyModules.define(\"bar\",[], function() &#123; function hello(who) &#123; return \"let me introduce:\" + who; &#125; retrun &#123; hello : hello &#125;; &#125;); MyModules.define(\"foo\",['bar'], function(bar) &#123; var hungry = 'hippo'; function awesome(who) &#123; console.log(bar.hello(hungry).toUpperCase()); &#125; retrun &#123; awesome : awesome &#125;; &#125;); var bar = MyModules.get('bar'); var foo = MyModules.get('foo'); console.log(bar.hello('hippo'));// let me introduce: hippo foo.awesome(); // 大写的 foo 和 bar 都是通过一个返回的公共的API的函数来定义的。foo 甚至接受 bar 的实例作为依赖参数，并且相应地使用它。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"this词法","slug":"js-this词法","date":"2021-07-18T16:00:00.000Z","updated":"2021-07-23T09:48:56.630Z","comments":true,"path":"2021/07/19/js-this词法/","link":"","permalink":"http://example.com/2021/07/19/js-this%E8%AF%8D%E6%B3%95/","excerpt":"","text":"ES6添加了一个特殊的词法形式的函数声明，叫做箭头函数，箭头函数在涉及this绑定的行为和普通函数的行为完全不一样，他放弃了所有的普通函数this绑定的规则，取而代之的是用当前的词法作用域覆盖了this原本的值。 var obj = &#123; count: 0, cool: function coolFn() &#123; if(this.count &lt; 1) &#123; setTimeout(() => &#123; this.count++; console.log('awesome?'); &#125;,1000); &#125; &#125; &#125; obj.cool();//awesome? 这个箭头函数中的this直接是cool()的this绑定（因此调用它并不会出错） 它将程序员们经常犯的一个错误给标准化了，也就是混淆了this绑定规则和词法作用域规则。 另一个导致箭头函数不够理想的原因是他不是具名的，而是一个匿名函数。 误解： 人们很容易把this理解成指向函数自身。那么为什么函数要从内部引用函数自身呢？常见的原因是递归（从函数内部调用这个函数）或者可以写在第一次被调用后自己解除绑定事件处理器。 新手通常会认为，既然把函数看做一个对象，那就可以在调用函数时储存状态。 call function foo(num) &#123; console.log(\"foo\" + num); this.count ++; &#125; foo.count = 0; var i; for(i = 0; i &lt; 10; i++)&#123; if(i > 5) &#123; // 使用call(...) 可以确保this指向函数本身 foo.call(foo, i) &#125; &#125; // foo: 6 // foo: 7 // foo: 8 // foo: 9 cnosole.log(foo.count); // 4 它的作用域还有一种常见的错误是，this指向函数的作用域。这个问题在某中情况下是正确的，但是有时候又是错误的。需要明确的是this在任何情况下都不指向函数的词法作域。 function foo()&#123; var a = 2; this.bar(); // 能调用到bar也是意外，正常应该通过词法作用域，直接执行 &#125; function bar()&#123; console.log(this.a) &#125; foo(); // a not defined ==当你想把this和词法作用域的查找混合使用的时候，一定要提醒自己这是无法实现的== 是什么this不是在写代码时候绑定的而是代码在执行的时候绑定的，它的上下文取决于函数调用时的各种条件。 this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。 ==当一个函数被执行时，会创建一个活动记录（有时候也被称之为执行上下文）。这个记录会包含函数在哪里被调用、函数的调用方式、传入参数等信息。this就是这个记录的一个属性，会在函数执行的过程中调用到。== this实际上是在函数被调用的时候发生绑定，他指向什么完全取决于函数在哪里被调用。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"函数中的作用域","slug":"js-函数作用域、作用域快","date":"2021-07-17T16:00:00.000Z","updated":"2021-07-23T09:48:56.630Z","comments":true,"path":"2021/07/18/js-函数作用域、作用域快/","link":"","permalink":"http://example.com/2021/07/18/js-%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%BF%AB/","excerpt":"","text":"函数中的作用域js有基于函数的作用域，每声明一个函数都会为其自身创建一个气泡，可以在附属气泡里获取外层的变量，但是不能从外层气泡中获取附属气泡种的变量 隐藏内部实现 暴露在外面的写法，很不安全 function foo(a) &#123; b = a + fff(a * 2); console.log(b * 3); &#125; function fff(a) &#123; return a - 1; &#125; var b; foo(2) // 15 隐藏的写法 function foo(a) &#123; function fff(a) &#123; return a - 1; &#125; var b; b = a + fff(a * 2); console.log(b * 3); &#125; foo(2) // 15 规避冲突，可以避免同名标识符之间的冲突，避免被覆盖 方法： 全局命名空间，在全局声明一个独特的变量，通常是一个对象，所有需要暴露给外界的功能都会成为这个对象的属性，而不是将自己的标识符暴露在顶级的词法作用域种。 模块管理，从众多模块中挑选一个来使用，任何库都无需将标识符加入到全局作用域中。 函数作用域在任意代码片段外部添加包装函数都可以将内部的变量和函数定义‘隐藏’起来，外部作用域无法访问包装函数内部的任何内容 通过定义一个函数来达到是变量在函数作用域之内，虽然可以解决问题，但是并不理想，因为这个函数名称本身污染了所在的作用域，其次是必须通过显式的调用这个函数才能运行其中的代码。 var a = 2; (function foo()&#123; var a = 3; console.log( a ); // 3 &#125;)(); console.log( a ); // 2 这样函数会被当作函数表达式而不是一个标准的函数声明来处理。– 如果function是声明中的第一个第一个词，那么就是函数声明，否则就是函数表达式。 函数表达式和函数声明最大的区别是它们的名称标识符将会绑定在何处。 foo只能在所代表的位置中被访问，外部不行。 匿名和具名 匿名函数表达式 setTimeout( function()&#123; console.log('aaa'); &#125;,1000); fun没有标识符，函数声明则是不可以省略函数名称 匿名函数在栈追踪中不会显示出有意义的函数名称，使得调用很困难。 如果没有函数名，需要引用的时候就只能使用已经过期的arguments.callee引用，比如在递归中 匿名函数省略了对于代码的可读性/可理解性很重要的函数名 行内函数表达式 setTimeout( function timeoutHandler()&#123; console.log('aaa'); &#125;,1000); 立即执行函数表达式var a = 2; (function foo()&#123; var a = 3; console.log( a ); // 3 &#125;)(); console.log( a ); // 2 第一个（）将函数变成了表达式，第二个（）执行了这个函数 IIFE代表立即执行函数表达式 var a = 2; (function IIFE()&#123; //传统的形式 var a = 3; console.log( a ); // 3 &#125;)(); console.log( a ); // 2 ==以上两种写法功能上是一样的== 用途： 可以传参数进去 var a = 2; (function IIFE(global)&#123; //传统的形式 var a = 3; console.log( a ); // 3 console.log( global.a ); // 3 &#125;)(window); console.log( a ); // 2 块作用域除了函数能产生一个作用域气泡，for循环，if，with,try/catch等都会产生一个作用域气泡。 块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块，通常指{..}的内部 var 其实val一个变量无论在什么地方，都会提升到全局变量，把它写在作用域内部，只是为了风格更易读而伪装出的形式上的块作用域，如果使用这种，要确保在其他地方没有重复的使用同名的变量。 let ES6引入了关键字let，可以将变量绑定到所在的任意作用域中，为其声明的变量隐式的劫持了所在的块作用域。 let进行声明的不会在代码在块作用域中进行提升，声明的代码在运行前，声明并不‘存在’。 &#123; console.log(a); // ReferenceError(没有找到) let a = 2; &#125; let 声明附属于一个新的作用域而不是当前函数作用域（也不属于全局作用域） const 同样可以用来创建块作用域变量，但其值是固定的，之后的任何试图修改值的操作都会引起错误。 var foo = true; if(foo)&#123; var a = 2; const b = 3; a = 4; // 正确 b = 6; // 错误 &#125; console.log(a) // 4 console.log(b) // ReferenceError 任何声明在某个作用域内部的变量，都将附属于这个作用域 小思考a = 2; val a; console.log(a);//2 输出2的原因是：声明会提升，也就是先声明再赋值，在执行查询 console.log(a); // undefind var a = 2; // 执行顺序 val a; console.log(a); // undefind a = 2; 原因：函数声明会提升，然后执行查询，此时是没有赋值的，所以是undefind foo(); // 不是ReferenceError，而是TypeEerror var foo = funcyion bar() &#123; //... &#125;; 原因：函数表达式不会被提升 函数优先 函数声明和变量声明都会被提升，但是一个值得注意的细节是函数会被首先提升，然后才是变量。 foo(); //1 var foo; function foo() &#123; console.log(1); &#125; foo = function() &#123; console.log(2); &#125; 输出的是1而不是2是因为函数声明先被提升到上面，然后在执行。var foo 尽管出现在function foo… 之前，但是他是重复声明会被忽略。 后面的声明会覆盖掉前面的声明 foo(); //3 function foo() &#123; console.log(1); &#125; var foo = function() &#123; console.log(2); &#125; function foo() &#123; console.log(3); &#125;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"markdown 写法备注","slug":"remarks","date":"2021-07-16T16:00:00.000Z","updated":"2021-07-21T01:15:15.628Z","comments":true,"path":"2021/07/17/remarks/","link":"","permalink":"http://example.com/2021/07/17/remarks/","excerpt":"","text":"标题 一级标题二级标题三级标题四级标题 无序列表 1 2 3 有序列表 列表 列表 列表 分割线 代码块 ``` 文本样式 字体倾斜 &gt; 字体倾斜 字体倾斜 字体加粗 &gt; 字体加粗 字体加粗 字体删除 &gt; 字体删除 ! 符号与字体之间不要有空格","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://example.com/tags/markdown/"}]},{"title":"js语法收集","slug":"js-语法收集","date":"2021-07-16T16:00:00.000Z","updated":"2021-07-27T06:12:29.321Z","comments":true,"path":"2021/07/17/js-语法收集/","link":"","permalink":"http://example.com/2021/07/17/js-%E8%AF%AD%E6%B3%95%E6%94%B6%E9%9B%86/","excerpt":"","text":"判断执行if(el)&#123; query(el) &#125; el &amp;&amp; query(el) if(el)&#123; el = query(el) &#125; el = el &amp;&amp; query(el); if(!el) return el = query(el)","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"浅拷贝与深拷贝","slug":"js-深拷贝与浅拷贝","date":"2021-07-16T16:00:00.000Z","updated":"2021-07-23T09:48:56.630Z","comments":true,"path":"2021/07/17/js-深拷贝与浅拷贝/","link":"","permalink":"http://example.com/2021/07/17/js-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"浅拷贝与深拷贝 (深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的)浅拷贝只复制指向某个对象的指针而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。 赋值和浅拷贝的区别 当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即：默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。 浅拷贝的实现方式 var obj1 = &#123; 'name' : 'zhangsan', 'age' : '18', 'language' : [1,[2,3],[4,5]], //Array &#125;; var obj3 = shallowCopy(obj1); obj3.name = \"lisi\"; obj3.language[1] = [\"二\",\"三\"]; function shallowCopy(src) &#123; var dst = &#123;&#125;; for (var prop in src) &#123; if (src.hasOwnProperty(prop)) &#123; dst[prop] = src[prop]; &#125; &#125; return dst; &#125; console.log('obj1',obj1) console.log('obj3',obj3) .Object.assign()Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。 var obj = &#123; a: &#123;a: \"kobe\", b: 39&#125; &#125;; var initalObj = Object.assign(&#123;&#125;, obj); initalObj.a.a = \"wade\"; console.log(obj.a.a); //wade 注意：当object只有一层的时候，是深拷贝 Array.prototype.concat() let arr = [1, 3, &#123; username: 'kobe' &#125;]; let arr2=arr.concat(); arr2[2].username = 'wade'; console.log(arr); 深拷贝的实现方式1.JSON.parse(JSON.stringify()) let arr = [1, 3, &#123; username: ' kobe' &#125;]; let arr4 = JSON.parse(JSON.stringify(arr)); arr4[2].username = 'duncan'; console.log(arr, arr4) 原理： 用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。这种方法虽然可以实现数组或对象深拷贝,但不能处理函数 2.手写递归方法 //定义检测数据类型的功能函数 function checkedType(target) &#123; return Object.prototype.toString.call(target).slice(8, -1) &#125; //实现深度克隆---对象/数组 function clone(target) &#123; //判断拷贝的数据类型 //初始化变量result 成为最终克隆的数据 let result, targetType = checkedType(target) if (targetType === 'object') &#123; result = &#123;&#125; &#125; else if (targetType === 'Array') &#123; result = [] &#125; else &#123; return target &#125; //遍历目标数据 for (let i in target) &#123; //获取遍历数据结构的每一项值。 let value = target[i] //判断目标结构里的每一值是否存在对象/数组 if (checkedType(value) === 'Object' || checkedType(value) === 'Array') &#123; //对象/数组里嵌套了对象/数组 //继续遍历获取到value值 result[i] = clone(value) &#125; else &#123; //获取到value值是基本的数据类型或者是函数。 result[i] = value; &#125; &#125; return result &#125; 3.函数库lodash该函数库也有提供_.cloneDeep用来做 Deep Copy var _ = require('lodash'); var obj1 = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [1, 2, 3] &#125;; var obj2 = _.cloneDeep(obj1); console.log(obj1.b.f === obj2.b.f); // false","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"js数据类型","slug":"js-数据类型","date":"2021-07-16T16:00:00.000Z","updated":"2021-07-23T09:48:56.630Z","comments":true,"path":"2021/07/17/js-数据类型/","link":"","permalink":"http://example.com/2021/07/17/js-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"基本数据类型、引用数据类型 ECMAScript包括两个不同类型的值：基本数据类型和引用数据类型。基本数据类型指的是简单的数据段，引用数据类型指的是有多个值构成的对象。当我们把变量赋值给一个变量时，解析器首先要确认的就是这个值是基本类型值还是引用类型值。 常见的基本数据类型Number、String 、Boolean、Null和Undefined。基本数据类型是按值访问的，因为可以直接操作保存在变量中的实际值。示例： var a = 10; var b = a; b = 20; console.log(a); // 10值 上面，b获取的是a值得一份拷贝，虽然，两个变量的值相等，但是两个变量保存了两个不同的基本数据类型值。 b只是保存了a复制的一个副本。所以，b的改变，对a没有影响。 引用类型数据 也就是对象类型Object type，比如：Object 、Array 、Function 、Data等。 js的引用数据类型是保存在堆内存中的对象。 与其他语言的不同是，你不可以直接访问堆内存空间中的位置和操作堆内存空间。只能操作对象在栈内存中的引用地址。 所以，引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存中堆内存中的对象。 var obj1 = new Object(); var obj2 = obj1; obj2.name = \"我有名字了\"; console.log(obj1.name); // 我有名字了 说明这两个引用数据类型指向了同一个堆内存对象。obj1赋值给onj2，实际上这个堆内存对象在栈内存的引用地址复制了一份给了obj2， 但是实际上他们共同指向了同一个堆内存对象。实际上改变的是堆内存对象。 查看一个值的是数据类型 js中变量是没有数据类型的，只有值才有。变量可以持有任何数据类型的值。 typeof 用来查看变量的类型会返回一字符串： typeof 1; // \"number\" typeof '1'; // \"string\" typeof undefined; // \"undefined\" typeof true; // \"boolean\" typeof &#123;a:1&#125;; // \"object\" typeod Symbol(); //'symbo' typeof null; // 'object' null 使用typeof 返回的类型是object，所以查看是不是null是需要用复合条件来检测 var a = null (!a &amp;&amp; typeof a ===\"object\"); //true JSON.stringify(a) === 'null' 总结区别声明变量时不同的内存分配： 1）原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。 这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – 栈中。这样存储便于迅速查寻变量的值。 2）引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。 这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。 地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。 不同的内存分配机制也带来了不同的访问机制 1）在js中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时， 首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的按引用访问。 2）而原始类型的值则是可以直接访问到的。 c 复制变量时的不同 1）原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的value而已。 2）引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量， 也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。 （这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了）。多了一个指针 参数传递的不同（把实参复制给形参的过程） 首先我们应该明确一点：ECMAScript中所有函数的参数都是按值来传递的。 但是为什么涉及到原始类型与引用类型的值时仍然有区别呢？还不就是因为内存分配时的差别。 1）原始值：只是把变量里的值传递给参数，之后参数和这个变量互不影响。 2）引用值：对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！ 因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"作用域是什么-词法作用域","slug":"js-作用域是什么-词法作用域","date":"2021-07-07T16:00:00.000Z","updated":"2021-07-23T09:48:56.629Z","comments":true,"path":"2021/07/08/js-作用域是什么-词法作用域/","link":"","permalink":"http://example.com/2021/07/08/js-%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88-%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/","excerpt":"","text":"作用域是什么 存储变量的规则存储在哪里？怎么获取？ var a = 2 为一个变量分配内存，名字为a，将值为2保存进这个变量（不完全正确） var a 编译器会询问作用域是否已经存在这样一个变量存在于同一个作用域内，如果有编译器会忽略该声明，继续编译，如果没有，他会要求作用域在当前作用域内声明一个新的变量，并命名为a。 接下载编译器会为引擎生成运行时所需要的代码，这些代码被用来处理a = 2 的操作，引擎运行时会询问作用域当前作用域集合中是否存在叫做a的变量，如果有，就是用该变量，如果没有会再向再外层的作用域询问，最终会到全局作用域。找到后会将2赋值给它，找不到就会抛出异常 总结：变量的赋值操作会执行两个动作，编译器在作用域中声明，运行时引擎会查找该变量并进行赋值。 编译器：LHS查询 查找类型RHS（LHS，RHS），当变量出现在赋值操作的左侧时进行进行LHS查询，出现在右侧时进行RHS查询。 console.log（a） 执行的是RHS，要去找a的值； a = 2 执行的是LHS 要为=2找到赋值的目标。 LHS：赋值操作的目标是谁；目的是对变量进行赋值 RHS：谁是赋值操作的源头；目的是获取变量的值 ReferenceError 这个错误是找不到定义的变量 词法作用域作用域有两种主要的工作模型：词法作用域，动态作用域。 词法作用域：定义在词法阶段的作用域，就是由你写代码时将变量和块作用域写在哪里决定的，因此词法解析器处理代码时会保持作用域不变（大部分情况下是这样） 词法欺骗： eval( ) function foo(str, a) &#123; eval(str); // 欺骗 console.log(a, b); &#125; var b = 2; foo('val b = 3;', 1); // 1, 3 with(){} function foo(obj) &#123; with(obj)&#123; a = 2; &#125; &#125; var o1 = &#123; a: 3 &#125; var o2 = &#123; a: 3 &#125; foo(o1); console.log(o1.a) // 2 foo(o2); console.log(o2.a) // undefined console.log(a) // 2 ==a被泄漏到全局上面去了== 总结eval（）函数如果接受了一个或多个声明的代码，就会修改其所处的词法作用域；with声明实际上是根据传递给他的对象凭空创建了一个全新的词法作用域 eval，with会降低性能，所以不建议使用","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]}],"categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://example.com/tags/vue2-0/"},{"name":"vue.2.0","slug":"vue-2-0","permalink":"http://example.com/tags/vue-2-0/"},{"name":"异步","slug":"异步","permalink":"http://example.com/tags/%E5%BC%82%E6%AD%A5/"},{"name":"http","slug":"http","permalink":"http://example.com/tags/http/"},{"name":"router","slug":"router","permalink":"http://example.com/tags/router/"},{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"},{"name":"markdown","slug":"markdown","permalink":"http://example.com/tags/markdown/"}]}