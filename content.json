{"meta":{"title":"chenMing","subtitle":"(ง •̀_•́)ง","description":"技术博客","author":"chenMing","url":"http://example.com","root":"/"},"pages":[{"title":"关于我","date":"2021-07-19T08:47:46.000Z","updated":"2021-07-20T01:16:24.063Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"2019年6月份毕业来到杭州参加了第一份工作，从事前端开发。 学习永无止境、宜早不宜迟！ 生活就是要快乐，快乐就是要钓鱼！"},{"title":"前端集合","date":"2021-07-19T08:16:44.000Z","updated":"2023-02-28T03:47:25.324Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":"(前端相关的一些书签列表)"},{"title":"分类","date":"2021-07-19T08:28:19.000Z","updated":"2021-07-20T01:07:45.426Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-07-19T08:44:20.000Z","updated":"2021-07-20T01:07:45.456Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"pnpm","slug":"工程化/pnpm","date":"2023-05-24T01:59:55.246Z","updated":"2023-05-24T02:01:01.714Z","comments":true,"path":"2023/05/24/工程化/pnpm/","link":"","permalink":"http://example.com/2023/05/24/%E5%B7%A5%E7%A8%8B%E5%8C%96/pnpm/","excerpt":"","text":"pnpmpnpm是一种新起的包管理器，从npm的下载量看，目前还没有超过yarn，但它的实现方式值得主流包管理器学习，某些开发者极力推荐使用pnpm 从结果上来看，它具有以下优势： 目前，安装效率高于npm和yarn的最新版 极其简洁的node_modules目录 避免了开发时使用间接依赖的问题 能极大的降低磁盘空间的占用 安装和使用全局安装pnpm npm install -g pnpm 之后在使用时，只需要把npm替换为pnpm即可 如果要执行安装在本地的CLI，可以使用pnpx，它和 npx 的功能完全一样，唯一不同的是，在使用pnpx执行一个需要安装的命令时，会使用pnpm进行安装 比如npx mocha执行本地的mocha命令时，如果mocha没有安装，则npx会自动的、临时的安装mocha，安装好后，自动运行mocha命令 pnpm原理 同 yarn 和 npm 一样，pnpm 仍然使用缓存来保存已经安装过的包，以及使用 pnpm-lock.yaml 来记录详细的依赖版本 不同于 yarn 和 npm， pnpm 使用符号链接和硬链接（可将它们想象成快捷方式）的做法来放置依赖，从而规避了从缓存中拷贝文件的时间，使得安装和卸载的速度更快 由于使用了符号链接和硬链接，pnpm可以规避windows操作系统路径过长的问题，因此，它选择使用树形的依赖结果，有着几乎完美的依赖管理。也因为如此，项目中只能使用直接依赖，而不能使用间接依赖 注意事项由于 pnpm 会改动 node_modules 目录结构，使得每个包只能使用直接依赖，而不能使用间接依赖，因此，如果使用 pnpm 安装的包中包含间接依赖，则会出现问题(现在不会了，除非使用了绝对路径) 由于 pnpm 超高的安装卸载效率，越来越多的包开始修正之前的间接依赖代码","categories":[],"tags":[]},{"title":"yarn","slug":"工程化/yarn","date":"2023-05-16T16:00:00.000Z","updated":"2023-05-17T05:57:08.796Z","comments":true,"path":"2023/05/17/工程化/yarn/","link":"","permalink":"http://example.com/2023/05/17/%E5%B7%A5%E7%A8%8B%E5%8C%96/yarn/","excerpt":"","text":"yarn 简介 yarn 官网：https://www.yarnpkg.com/zh-Hans/ yarn 是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具，它仍然使用 npm 的registry，不过提供了全新 CLI 来对包进行管理 过去，yarn 的出现极大的抢夺了 npm 的市场，甚至有人戏言，npm 只剩下一个 registry 了。 之所以会出现这种情况，是因为在过去，npm 存在下面的问题： 依赖目录嵌套层次深：过去，npm 的依赖是嵌套的，这在 windows 系统上是一个极大的问题，由于众所周知的原因，windows 系统无法支持太深的目录 下载速度慢 由于嵌套层次的问题，所以npm对包的下载只能是串行的，即前一个包下载完后才会下载下一个包，导致带宽资源没有完全利用 多个相同版本的包被重复的下载 控制台输出繁杂：过去，npm 安装包的时候，每安装一个依赖，就会输出依赖的详细信息，导致一次安装有大量的信息输出到控制台，遇到错误极难查看 工程移植问题：由于 npm 的版本依赖可以是模糊的，可能会导致工程移植后，依赖的确切版本不一致。 针对上述问题，yarn 从诞生那天就已经解决，它用到了以下的手段： 使用扁平的目录结构 并行下载 使用本地缓存 控制台仅输出关键信息 使用yanr-lock文件记录确切依赖 不仅如此，yarn还优化了以下内容： 增加了某些功能强大的命令 让既有的命令更加语义化 本地安装的CLI工具可以使用 yarn 直接启动 将全局安装的目录当作一个普通的工程，生成package.json文件，便于全局安装移植 yarn 的出现给 npm 带来了巨大的压力，很快，npm 学习了 yarn 先进的理念，不断的对自身进行优化，到了目前的npm6版本，几乎完全解决了上面的问题： 目录扁平化 并行下载 本地缓存 使用package-lock记录确切依赖 增加了大量的命令别名 内置了npx，可以启动本地的CLI工具 极大的简化了控制台输出 总结 npm6 之后，可以说npm已经和yarn非常接近，甚至没有差距了。很多新的项目，又重新从yarn转回到npm。 这两个包管理器是目前的主流，都必须要学习。 yarn 的核心命令 初始化 初始化：yarn init [--yes/-y] 安装 添加指定包：yarn [global] add package-name [--dev/-D] [--exact/-E] 安装package.json中的所有依赖：yarn install [--production/--prod] 脚本和本地CLI 运行脚本：yarn run 脚本名 start、stop、test可以省略run 运行本地安装的CLI：yarn run CLI名 查询 查看bin目录：yarn [global] bin 查询包信息：yarn info 包名 [子字段] 列举已安装的依赖：yarn [global] list [--depth=依赖深度] yarn的list命令和npm的list不同，yarn输出的信息更加丰富，包括顶级目录结构、每个包的依赖版本号 更新 列举需要更新的包：yarn outdated 更新包：yarn [global] upgrade [包名] 卸载 卸载包：yarn remove 包名 yarn 的特别礼物在终端命令上，yarn不仅仅是对npm的命令做了一个改名，还增加了一些原本没有的命令，这些命令在某些时候使用起来非常方便 yarn check 使用yarn check命令，可以验证package.json文件的依赖记录和lock文件是否一致 这对于防止篡改非常有用 yarn audit 使用yarn audit命令，可以检查本地安装的包有哪些已知漏洞，以表格的形式列出，漏洞级别分为以下几种： INFO：信息级别 LOW: 低级别 MODERATE：中级别 HIGH：高级别 CRITICAL：关键级别 yarn why 使用yarn why 包名命令，可以在控制台打印出为什么安装了这个包，哪些包会用到它 yarn create 非常有趣的命令 今后，我们会学习一些脚手架，所谓脚手架，就是使用一个命令来搭建一个工程结构 过去，我们都是使用如下的做法： 全局安装脚手架工具 使用全局命令搭建脚手架 由于大部分脚手架工具都是以create-xxx的方式命名的，比如react的官方脚手架名称为create-react-app 因此，可以使用yarn create命令来一步完成安装和搭建 例如： yarn create react-app my-app # 等同于下面的两条命令 yarn global add create-react-app create-react-app my-app","categories":[],"tags":[]},{"title":"","slug":"工程化/包的安装、配置、使用","date":"2023-05-04T06:35:53.748Z","updated":"2023-05-11T01:25:02.946Z","comments":true,"path":"2023/05/04/工程化/包的安装、配置、使用/","link":"","permalink":"http://example.com/2023/05/04/%E5%B7%A5%E7%A8%8B%E5%8C%96/%E5%8C%85%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E9%85%8D%E7%BD%AE%E3%80%81%E4%BD%BF%E7%94%A8/","excerpt":"","text":"包的安装 安装（install）即下载包由于 npm 的官方 registry 服务器位于国外，可能受网速影响导致下载缓慢或失败。因此，安装好 npm 之后，需要重新设置 registry 的地址为国内地址。目前，淘宝 https://registry.npm.taobao.org 提供了国内的 registry 地址，先设置到该地址。设置方式为npm config set registry https://registry.npm.taobao.org。设置好后，通过命令npm config get registry进行检查 npm 安装一个包，分为两种安装方式： 本地安装 全局安装 本地安装使用命令npm install 包名或npm i 包名即可完成本地安装 本地安装的包出现在当前目录下的node_modules目录中 随着开发的进展，node_modules目录会变得异常庞大，目录下的内容不适合直接传输到生产环境，因此通常使用.gitignore文件忽略该目录中的内容本地安装适用于绝大部分的包，它会在当前目录及其子目录中发挥作用通常在项目的根目录中使用本地安装安装一个包的时候，npm 会自动管理依赖，它会下载该包的依赖包到node_modules目录中如果本地安装的包带有 CLI，npm 会将它的 CLI 脚本文件放置到node_modules/.bin下，使用命令npx 命令名即可调用 全局安装全局安装的包放置在一个特殊的全局目录，该目录可以通过命令npm config get prefix查看 使用命令npm install --global 包名 或 npm i -g 包名 重要：全局安装的包并非所有工程可用，它仅提供全局的 CLI 工具 大部分情况下，都不需要全局安装包，除非： 包的版本非常稳定，很少有大的更新 提供的 CLI 工具在各个工程中使用的非常频繁 CLI 工具仅为开发环境提供支持，而非部署环境 包配置目前遇到的问题： 拷贝工程后如何还原？ 如何区分开发依赖和生产依赖？ 如果自身的项目也是一个包，如何描述包的信息 以上这些问题都需要通过包的配置文件解决 配置文件npm 将每个使用 npm 的工程本身都看作是一个包，包的信息需要通过一个名称固定的配置文件来描述 配置文件的名称固定为：package.json 可以手动创建该文件，而更多的时候，是通过命令npm init创建的 配置文件中可以描述大量的信息，包括： name：包的名称，该名称必须是英文单词字符，支持连接符 version：版本 版本规范：主版本号.次版本号.补丁版本号 主版本号：仅当程序发生了重大变化时才会增长，如新增了重要功能、新增了大量的API、技术架构发生了重大变化 次版本号：仅当程序发生了一些小变化时才会增长，如新增了一些小功能、新增了一些辅助型的API 补丁版本号：仅当解决了一些 bug 或 进行了一些局部优化时更新，如修复了某个函数的 bug、提升了某个函数的运行效率 description：包的描述 homepage：官网地址 author：包的作者，必须是有效的 npm 账户名，书写规范是 account &lt;mail&gt;，例如：zhangsan &lt;zhangsan@gmail.com&gt;，不正确的账号和邮箱可能导致发布包时失败 repository：包的仓储地址，通常指 git 或 svn 的地址，它是一个对象 type：仓储类型，git 或 svn url：地址 main：包的入口文件，使用包的人默认从该入口文件导入包的内容 keywords: 搜索关键字，发布包后，可以通过该数组中的关键字搜索到包 使用npm init --yes或npm init -y可以在生成配置文件时自动填充默认配置 保存依赖关系大部分时候，我们仅仅是开发项目，并不会把它打包发布出去，尽管如此，我们仍然需要package.json文件 package.json文件最重要的作用，是记录当前工程的依赖 dependencies：生产环境的依赖包 devDependencies：仅开发环境的依赖包 配置好依赖后，使用下面的命令即可安装依赖 ## 本地安装所有依赖 dependencies + devDependencies npm install npm i ## 仅安装生产环境的依赖 dependencies npm install --production 这样一来，代码移植就不是问题了，只需要移植源代码和package.json文件，不用移植node_modules目录，然后在移植之后通过命令即可重新恢复安装 为了更加方便的添加依赖，npm支持在使用install命令时，加入一些额外的参数，用于将安装的依赖包保存到package.json文件中 涉及的命令如下 ## 安装依赖到生产环境 npm i 包名 npm i --save 包名 npm i -S 包名 ## 安装依赖到开发环境 npm i --save-dev 包名 npm i -D 包名 自动保存的依赖版本，例如^15.1.3，这种书写方式叫做语义版本号（semver version） 包的使用nodejs 对 npm 支持非常良好 当使用 nodejs 导入模块时，如果模块路径不是以 ./ 或 ../ 开头，则 node 会认为导入的模块来自于 node_modules 目录，例如： var _ = require(\"lodash\"); 它首先会从当前目录的以下位置寻找文件 node_modules&#x2F;lodash.js node_modules&#x2F;lodash&#x2F;入口文件 若当前目录没有这样的文件，则会回溯到上级目录按照同样的方式查找 如果到顶级目录都无法找到文件，则抛出错误 上面提到的入口文件按照以下规则确定 查看导入包的package.json文件，读取main字段作为入口文件 若不包含main字段，则使用index.js作为入口文件 入口文件的规则同样适用于自己工程中的模块在 node 中，还可以手动指定路径来导入相应的文件，这种情况比较少见 语义版本思考：如果你编写了一个包A，依赖另外一个包B，你在编写代码时，包B的版本是2.4.1，你是希望使用你包的人一定要安装包B，并且是2.4.1版本，还是希望他可以安装更高的版本，如果你希望它安装更高的版本，高的什么程度呢？ 回顾：版本号规则 版本规范：主版本号.次版本号.补丁版本号 主版本号：仅当程序发生了重大变化时才会增长，如新增了重要功能、新增了大量的API、技术架构发生了重大变化 次版本号：仅当程序发生了一些小变化时才会增长，如新增了一些小功能、新增了一些辅助型的API 补丁版本号：仅当解决了一些 bug 或 进行了一些局部优化时更新，如修复了某个函数的 bug、提升了某个函数的运行效率 有的时候，我们希望：安装我的依赖包的时候，次版本号和补丁版本号是可以有提升的，但是主版本号不能变化 有的时候，我们又希望：安装我的依赖包的时候，只有补丁版本号可以提升，其他都不能提升 甚至我们希望依赖包保持固定的版本，尽管这比较少见 这样一来，就需要在配置文件中描述清楚具体的依赖规则，而不是直接写上版本号那么简单。 这种规则的描述，即语义版本 语义版本的书写规则非常丰富，下面列出了一些常见的书写方式 符号 描述 示例 示例描述 &gt; 大于某个版本 &gt;1.2.1 大于1.2.1版本 &gt;= 大于等于某个版本 &gt;=1.2.1 大于等于1.2.1版本 &lt; 小于某个版本 &lt;1.2.1 小于1.2.1版本 &lt;= 小于等于某个版本 &lt;=1.2.1 小于等于1.2.1版本 - 介于两个版本之间 1.2.1 - 1.4.5 介于1.2.1和1.4.5之间 x 不固定的版本号 1.3.x 只要保证主版本号是1，次版本号是3即可 ~ 补丁版本号可增 ~1.3.4 保证主版本号是1，次版本号是3，补丁版本号大于等于4 ^ 此版本和补丁版本可增 ^1.3.4 保证主版本号是1，次版本号可以大于等于3，补丁版本号可以大于等于4 * 最新版本 * 始终安装最新版本 避免还原的差异版本依赖控制始终是一个两难的问题 如果允许版本增加，可以让依赖包的bug得以修复（补丁版本号），可以带来一些意外的惊喜（次版本号），但同样可能带来不确定的风险（新的bug） 如果不允许版本增加，可以获得最好的稳定性，但失去了依赖包自我优化的能力 而有的时候情况更加复杂，如果依赖包升级后，依赖也发生了变化，会有更多不确定的情况出现 基于此，npm 在安装包的时候，会自动生成一个 package-lock.json 文件，该文件记录了安装包时的确切依赖关系 当移植工程时，如果移植了 package-lock.json 文件，恢复安装时，会按照 package-lock.json 文件中的确切依赖进行安装，最大限度的避免了差异 [扩展]npm的差异版本处理面对这种情况，在 node_modules 目录中，不会使用扁平的目录结构，而会形成嵌套的目录，如下图： ├── node_modules │ ├── a │ │ ├── node_modules │ │ │ ├── c │ │ │ | |—— c包的文件 │ │ │── a包的文件 │ ├── b │ │ ├── node_modules │ │ │ ├── c │ │ │ | |—— c包的文件 │ │ │── b包的文件 npm 脚本 （npm scripts）在开发的过程中，我们可能会反复使用很多的 CLI 命令，例如： 启动工程命令（node 或 一些第三方包提供的CLI命令） 部署工程命令（一些第三方包提供的CLI命令） 测试工程命令（一些第三方包提供的CLI命令） 这些命令纷繁复杂，根据第三方包的不同命令也会不一样，非常难以记忆 于是，npm 非常贴心的支持了脚本，只需要在 package.json 中配置 scripts 字段，即可配置各种脚本名称 之后，我们就可以运行简单的指令来完成各种操作了 运行方式是 npm run 脚本名称 不仅如此，npm 还对某些常用的脚本名称进行了简化，下面的脚本名称是不需要使用run的： start stop test 一些细节： 脚本中可以省略npx start脚本有默认值：node server.js 运行环境配置我们书写的代码一般有三种运行环境： 开发环境 生产环境 测试环境 有的时候，我们可能需要在 node 代码中根据不同的环境做出不同的处理 如何优雅的让 node 知道处于什么环境，是极其重要的 通常我们使用如下的处理方式： node中有一个全局变量 global (可以类比浏览器环境的window)，该变量是一个对象，对象中的所有属性均可以直接使用 global有一个属性是process，该属性是一个对象，包含了当前运行node程序的计算机的很多信息，其中有一个信息是env，是一个对象，包含了计算机中所有的系统变量 通常，我们通过系统变量 NODE_ENV 的值，来判定node程序处于何种环境 有两种方式设置 NODE_ENV 的值 永久设置 临时设置 我们一般使用临时设置 因此，我们可以配置 scripts 脚本，在设置好了 NODE_ENV 后启动程序 为了避免不同系统的设置方式的差异，可以使用第三方库 cross-env 对环境变量进行设置 在node中读取package.json有的时候，我们可能在 package.json 中配置一些自定义的字段，这些字段需要在node中读取 在node 中，可以直接导入一个json格式的文件，它会自动将其转换为js对象 其他npm命令 {ignore}安装 精确安装最新版本 npm install --save-exact 包名 npm install -E 包名 安装指定版本 npm install 包名@版本号 查询 查询包安装路径 npm root [-g] 查看包信息 npm view 包名 [子信息] ## view aliases：v info show 查询安装包 npm list [-g] [--depth&#x3D;依赖深度] ## list aliases: ls la ll 更新 检查有哪些包需要更新 npm outdated 更新包 npm update [-g] [包名] ## update 别名（aliases）：up、upgrade 卸载包npm uninstall [-g] 包名 ## uninstall aliases: remove, rm, r, un, unlink npm 配置npm的配置会对其他命令产生或多或少的影响 安装好npm之后，最终会产生两个配置文件，一个是用户配置，一个是系统配置，当两个文件的配置项有冲突的时候，用户配置会覆盖系统配置 通常，我们不关心具体的配置文件，而只关心最终生效的配置 通过下面的命令可以查询目前生效的各种配置 npm config ls [-l] [--json] 另外，可以通过下面的命令操作配置 获取某个配置项 npm config get 配置项 设置某个配置项 npm config set 配置项&#x3D;值 移除某个配置项 npm config delete 配置项 发布包准备工作 移除淘宝镜像源 到npm官网注册一个账号，并完成邮箱认证 本地使用 npm cli 进行登录 使用命令npm login登录 使用命令npm whoami查看当前登录的账号 使用命令npm logout注销 创建工程根目录 使用npm init进行初始化 发布 开发 确定版本 使用命令npm publish完成发布","categories":[],"tags":[]},{"title":"AMD和CMD","slug":"工程化/AMD和CMD","date":"2023-04-18T16:00:00.000Z","updated":"2023-04-19T09:30:36.632Z","comments":true,"path":"2023/04/19/工程化/AMD和CMD/","link":"","permalink":"http://example.com/2023/04/19/%E5%B7%A5%E7%A8%8B%E5%8C%96/AMD%E5%92%8CCMD/","excerpt":"","text":"AMD和CMD在ES6出了官方标准以后就很少使用了，所以这里只做了就可以 浏览器端模块化的难题CommonJS的工作原理 当使用require(模块路径)导入一个模块时，node会做以下两件事情（不考虑模块缓存）： 通过模块路径找到本机文件，并读取文件内容 将文件中的代码放入到一个函数环境中执行，并将执行后module.exports的值作为require函数的返回结果 正是这两个步骤，使得CommonJS在node端可以良好的被支持 可以认为，CommonJS是同步的，必须要等到加载完文件并执行完代码后才能继续向后执行 当浏览器遇到CommonJS 当想要把CommonJS放到浏览器端时，就遇到了一些挑战 浏览器要加载JS文件，需要远程从服务器读取，而网络传输的效率远远低于node环境中读取本地文件的效率。由于CommonJS是同步的，这会极大的降低运行性能 如果需要读取JS文件内容并把它放入到一个环境中执行，需要浏览器厂商的支持，可是浏览器厂商不愿意提供支持，最大的原因是CommonJS属于社区标准，并非官方标准 新的规范 基于以上两点原因，浏览器无法支持模块化 可这并不代表模块化不能在浏览器中实现 要在浏览器中实现模块化，只要能解决上面的两个问题就行了 解决办法其实很简单： 远程加载JS浪费了时间？做成异步即可，加载完成后调用一个回调就行了 模块中的代码需要放置到函数中执行？编写模块时，直接放函数中就行了 基于这种简单有效的思路，出现了AMD和CMD规范，有效的解决了浏览器模块化的问题。 AMD全称是Asynchronous Module Definition，即异步模块加载机制 require.js实现了AMD规范 在AMD中，导入和导出模块的代码，都必须放置在define函数中 // src引入require.js;通过data-main 确定模块化的入口文件 &lt;script data-main=\"./js/index.js\" src=\"./js/require.js\">&lt;/script> define([依赖的模块列表], function(模块名称列表)&#123; // 位置一一对应 *//模块内部的代码* *return* 导出的内容 &#125;) // 或者 define((require,exports,module) => &#123; const a = require('a') // 导入 module.exports = &#123; // 导出 &#125; &#125;) CMD全称是Common Module Definition，公共模块定义规范 sea.js实现了CMD规范 在CMD中，导入和导出模块的代码，都必须放置在define函数中 &lt;script src=\"./js/sea.js\">&lt;/script> // 引入sea.js &lt;script> // 确认入口文件 seajs.use(\"./js/index\") &lt;/script> define(function(require, exports, module)&#123; *//模块内部的代码* &#125;) // CMD支持异步写法 define((require, exports, module) => &#123; require.async(\"a\", function(a)&#123; console.log(a) &#125;) require.async(\"b\", function(b)&#123; console.log(b) &#125;) &#125;) 从使用时看AMD和CMD基本类似，AMD也支持CMD的写法，为什么还有个CMD呢？其实最开始的时候AMD只有一种写法，后面出来了CMD以后，开发者更喜欢CMD的写法，因为与commonjs写法比较类似，AMD再去更新了CMD的写法","categories":[],"tags":[{"name":"工程化","slug":"工程化","permalink":"http://example.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]},{"title":"构建工具","slug":"工程化/构建工具","date":"2023-03-31T16:00:00.000Z","updated":"2023-04-12T03:20:22.751Z","comments":true,"path":"2023/04/01/工程化/构建工具/","link":"","permalink":"http://example.com/2023/04/01/%E5%B7%A5%E7%A8%8B%E5%8C%96/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/","excerpt":"","text":"工程化，为复杂应用而生 核心webpack是用来搭建前端工程的 它运行在node环境中，它所做的事情，简单来说，就是打包 具体来说，就是以某个模块作为入口，根据入口分析出所有模块的依赖关系，然后对各种模块进行合并、压缩，形成最终的打包结果 在webpack的世界中，一切皆是模块 体验 以src/main.js作为入口文件 按照习惯，所有的模块均放置在src目录中 安装依赖 编写多个模块 随意编写一些模块，可以是js、图片、音视频，以入口模块为起点，形成依赖关系 运行npm run build命令，进行打包 查看打包结果 打包结果放置在dist目录中 通过上面的体验，可以发现，webpack给我们带来了至少以下好处： 可以大胆的使用任意模块化标准 无须担心兼容性问题，因为webpack完成打包后，已经没有了任何模块化语句 可以将一些非JS代码也视为模块 这样可以对css、图片等资源进行更加细粒度的划分 在前端开发中，也可以使用npm webpack不会运行你的源代码，无论是你自己写的模块，还是通过npm安装的模块，webpack一视同仁，统统视为依赖，最终合并到打包结果中 非常适合开发单页应用 单页应用是前端用户体验最好的web应用 所谓单页应用，是指只有一个html页面，页面中没有任何内容，所有的内容均靠js生成 要优雅的实现单页应用，最好依托于前端框架，比如vue、react 页面模板对于单页应用而言，只有一个空白的页面，所有内容都靠JS代码创建 webpack会自动生成一个页面，并且在页面中会自动加入对js和css的引用 它生成页面时，参考的是public/index.html，其称之为页面模板 public目录webpack会非常暴力的将public目录中的所有文件（除页面模板外），复制到打包结果中 开发服务器如果每次修改完代码，都要经过打包-&gt;运行，未免太过麻烦 在开发阶段，我们可以运行npm run serve命令获得更好的打包体验 该命令会让webpack启动一个开发服务器。 在这个阶段，webpack并不会形成打包结果文件，而是把打包的内容放到内存中，当我们请求服务器时，服务器从内存中给予我们打包结果 与此同时，当源码发生变动时，webpack会自动重新打包，同时刷新页面以访问到最新的打包结果 文件缓存可以看到，除了页面外，其他的资源在打包完成后，文件名多了一些奇奇怪怪的字符 例如：js/app-9ea93.js 其中，9ea93这样的字符称之为hash，它会随着模块内容的变化而变化 源码内容不变，hash不变；源码内容变化，hash变化 之所以这样做，是因为生产环境中，浏览器会对除页面外的静态资源进行缓存 如果不设置hash值，一旦代码更新，浏览器还会使用之前缓存的结果，无法使用最新的代码 有了hash值之后，即可解决此问题 webpack会在打包时自动处理hash值，并不会对我们写代码造成任何影响，但作为一个前端开发者，有必要了解这一点 资源路径除代码和样式模块外，其他模块被视为资源模块 值得特别注意的是，资源模块在源代码中的路径和打包后的路径是不一样的，这就导致我们在编写代码的时候，根本无法知晓最终的路径 最常见的例子，就是在css中使用背景图片 .container&#123; /* 背景图使用了源码中的路径 */ backgroud: url('../assets/1.png'); &#125; 它能正常工作吗？ 它能！ 因为webpack非常智能的发现了这一点，对于css中的路径，webpack在打包时，会将其自动转换为打包结果的路径，比如，上面的代码在打包完成后，可能被转换为下面的格式 .container&#123; /* css中的资源路径会被自动替换，我们无须关心 */ background: url(/img/1492ea.png); &#125; 但如果我们要通过js动态的使用路径，webpack是无法识别的 // 打包前 const url = './assets/1.png'; // 该路径无法被转换 img.src = url; // 打包后 const url = './assets/1.png'; // ❌ img.src = url; 正确的做法是，通过模块化的方式导入资源，并获取资源路径 // 打包前 import url from './assets/1.png'; // 打包后，url得到的将是真实的路径 img.src = url; // 打包后 const url = '/img/1492ea.png'; // ✅ img.src = url; 缺省的文件和后缀名导入模块时，所有js模块均可省略.js，若导入的模块文件名为index.js，可省略文件名 import './home'; // 若存在home.js，可省略js import './movie'; // 若movie是一个目录，此次导入的是 ./movie/index.js 路径别名随着体量的增长，不可避免的，会形成层级极深的目录 root |- src |- a |- a1 |- a2 |- index.js |- b |- b1 |- index.js 如果需要在./src/a/a1/a2/index.js中导入./src/b/b1/index.js，则可能产生下面特别恶心的代码 import '../../../b/b1/index.js'; webpack提供了别名供我们快速定位到./src目录，通常，该别名为@ 上面的导入代码可简化为 import '@/b/b1'; // @表示src目录，同时省略了index.js js兼容性当webpack读取到js代码时，会自动对其进行兼容性处理 具体的处理方案涉及到两个配置文件： babel.config.js：通过配置该文件，可以设置对哪些js代码进行降级处理 .browserslistrc：通过配置该文件，可以设置在降级时，要兼容哪些浏览器，兼容的范围越光，降级产生的代码就越多，自然，打包后的体积就越大 你无须知晓具体的配置方式 打包压缩webpack在打包时，会对所有js和css代码进行压缩 对于js，除了压缩之外，还会对其中的各种名称进行混淆 (self.webpackChunkmovie_list=self.webpackChunkmovie_list||[]).push([[587],&#123;3587:(r,t,n)=>&#123;\"use strict\";n.r(t),n(5666),n(1539),n(8674),n(9600),n(1249),n(2222);var e=n(9755),a=n.n(e);var o;function i(r)&#123;o.html(r.map((function(r)&#123;return'&lt;li>\\n &lt;a href=\"'.concat(r.url,'\" target=\"_blank\">\\n &lt;img src=\"').concat(r.cover,'\" title=\"').concat(r.title,'\">\\n &lt;/a>\\n &lt;a href=\"').concat(r.url,'\" target=\"_blank\" class=\"').concat(\"qmUYQv1xlJhGMQKz-kfAp\",'\">').concat(r.title,'&lt;/a>\\n &lt;p class=\"').concat(\"_3yV5wC-URYTUP0sPvaE0ZR\",'\">').concat(r.rate,\"&lt;/p>\\n &lt;/li>\")&#125;)).join(\"\"))&#125;o=a()(\"&lt;ul>\").addClass(\"_1fsrc5VinfYHBXCF1s58qS\").appendTo(\"#app\");var c=n(8138);const u= 混淆的作用一方面是为了进一步压缩包体积，另一方面是为了让我们的代码更难被其他人理解利用 源码地图 source map我们运行的是webpack打包后的结果，而打包后的结果是很难阅读的 但这样一来会带来新的问题，如果代码报错，我们就难以知道到底是那一行代码写的有问题 此时源码地图就发挥了作用 可以发现，js代码打包后都会跟上一个同名的、后缀为.map的文件，该文件就保存了原始代码的内容 请放心，这个内容人类是看不懂的，但浏览器可以看懂 当代码报错时，浏览器会定位到源码地图中的对应代码，而不是把真实报错的代码展示给我们 你无须关心这一点，但可以自然的从其中获得巨大的便利 css工程化webpack能够识别所有的样式代码，包括css、less、sass、stylus 在打包时，会将它们转换成纯正的css 除此之外，它还具备以下的神奇能力 自动厂商前缀css有很多兼容性问题，解决这些兼容性问题的最常见办法，就是加上厂商前缀。 比如： /* 兼容性不好的代码 */ .container&#123; display: flex; transition: 1s; &#125; /* 兼容性好的代码 */ .container &#123; display: -webkit-box; display: -webkit-flex; display: flex; -webkit-transition: 1s; transition: 1s; &#125; webpack会根据.browserlistrc中指定的浏览器范围，按需、自动加上厂商前缀 我们开发无须关心 css modulecss文件多了后，你怎么保证它们里面没有冲突的类样式？ 靠层级选择器？就不担心效率？ 靠命名规范？就不担心脑袋爆炸？ 要靠就靠css module 当样式文件以xxx.mdoule.xxx的方式命名时，webpack会将该文件当成一个开启了css module的文件 比如：index.module.less、movie.module.css，都是开启了css module的文件 文件中的所有类名都会被hash化 // 源码 .container&#123;&#125; .list&#123;&#125; .item&#123;&#125; // 打包结果，绝无可能重名 ._2GFVidHvoHtfgtrdifua24&#123;&#125; ._1fsrc5VinfYHBXCF1s58qS&#123;&#125; .urPUKUukdS_UTSuWRI5-5&#123;&#125; 现在就一个问题，我们在使用类名时，如何知道它打包结果的类名呢？ import './index.module.less'; dom.classList.add('container'); // ❌ 最终的类名可不是这个 正确的方式如下： // styles 是一个对象，里面映射了源码类名和打包类名的关系 import styles from './index.module.less'; dom.classList.add(styles.container); // ✅ 属性container中记录的就是container转换后的类名 真正的webpack没有那么神奇实际上，webpack没有做这么多事，我们不能把功劳（怨念）全归结于它 它只是站在巨人（其他流氓）肩膀上而已 下图可以看个热闹 webpack通过插件（plugin）和加载器（loader）将这些技术整合在一起 工程中的文件： .browserslistrc，表达适配的浏览器范围，会被工程化中的其他技术所使用 babel.config.js，babel的配置文件，做js降级处理 postcss.config.js，postcss的配置文件，做css代码转换 webpack.config.js，webpack的配置文件，整合其他工程化技术，以及配置打包细节、开发服务器、路径别名等等 对我们开发的影响 学会访问开发服务器查看效果 学会动态获取资源文件路径 import url from './assets/1.png'; img.src = url; 学会省略文件和后缀名 import './home'; // 若存在home.js，可省略js import './movie'; // 若movie是一个目录，此次导入的是 ./movie/index.js 学会使用别名简化导入代码 import '@/b/b1'; // 实际导入： src/b/b1/index.js (若b1是目录) 学会使用css module // styles 是一个对象，里面映射了源码类名和打包类名的关系 import styles from './index.module.less'; dom.classList.add(styles.container);","categories":[],"tags":[{"name":"工程化","slug":"工程化","permalink":"http://example.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]},{"title":"less","slug":"工程化/less","date":"2023-03-30T16:00:00.000Z","updated":"2023-03-31T05:47:30.949Z","comments":true,"path":"2023/03/31/工程化/less/","link":"","permalink":"http://example.com/2023/03/31/%E5%B7%A5%E7%A8%8B%E5%8C%96/less/","excerpt":"","text":"什么是Less？Less是一种更加简洁的样式代码，它非常像CSS，但又不太一样，它让编写样式变得更容易 下面是css代码和Less代码的对比，它们都表达了一样的含义 Less代码虽好，但它无法被浏览器识别，因此需要一个工具将其转换为血统纯正的css代码 由于node环境具有读写文件的能力，于是在node环境中可以轻松的完成文件的转换 npm上有一个包叫做less，它运行在node环境中，通过它可以完成对Less代码的转换 可以看出，node环境在前端工程化中，充当了一个辅助的角色，它并不直接运行前端代码，而是让我们编写前端代码更加舒适便利，在后续的课程中，你还会不断的体会到这一点 转换代码，称之为编译(compile)，转换代码的工具，称之为编译器(compiler) 体验Less 新建index.less文件，编写下面的less代码 @green: #008c8c; .list &#123; display: flex; flex-wrap: wrap; color: @green; li &#123; margin: 1em; &amp;:hover &#123; background: @green; color: #fff; &#125; &#125; &#125; 使用npm下载less less包提供了一个cli工具lessc，你可以有两种方案使用它 方案一：全局安装less 这种方案可以让你在任何终端目录使用lessc命令，但不利于版本控制 方案二：本地安装less 这种方案会把less安装到工程目录的node_modules中，你无法全局使用lessc命令，但可以在当前工程目录中使用npx lessc运行该命令 npx是npm提供的一个小工具，它可以运行当前项目中安装到node_modules的cli命令 如果配置package.json脚本，无须使用npx 如果可以，应该尽量使用本地安装，而非全局安装 如果可以，应该尽量使用本地安装，而非全局安装 使用lessc命令，对编写的less文件进行编译 # 将 index.less 编译成为 index.css lessc index.less index.css 新建一个页面，引用编译结果index.css 目前，编写less代码会遇到一点小麻烦，就是每次编写后，都需要运行命令进行编译 这个麻烦只是暂时的，将来很快就可以解决 Less的核心语法 Less官网：https://lesscss.org/ Less民间中文网：https://less.bootcss.com/ Less提供了非常多的功能，帮助我们更加轻松的编写css代码 其中，我们最常用的功能有下面3个： 变量 嵌套 混合 另外，你需要关注Less的特殊注释","categories":[],"tags":[{"name":"工程化","slug":"工程化","permalink":"http://example.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]},{"title":"npm","slug":"工程化/npm","date":"2023-03-29T16:00:00.000Z","updated":"2023-03-31T02:00:03.092Z","comments":true,"path":"2023/03/30/工程化/npm/","link":"","permalink":"http://example.com/2023/03/30/%E5%B7%A5%E7%A8%8B%E5%8C%96/npm/","excerpt":"","text":"包的安装 安装（install）即下载包由于 npm 的官方 registry 服务器位于国外，可能受网速影响导致下载缓慢或失败。因此，安装好 npm 之后，需要重新设置 registry 的地址为国内地址。目前，淘宝 https://registry.npm.taobao.org 提供了国内的 registry 地址，先设置到该地址。设置方式为npm config set registry https://registry.npm.taobao.org。设置好后，通过命令npm config get registry进行检查 或者安装nrm 进行切换 npm 安装一个包，分为两种安装方式： 本地安装 全局安装 本地安装使用命令npm install 包名或npm i 包名即可完成本地安装 本地安装的包出现在当前目录下的node_modules目录中 随着开发的进展，node_modules目录会变得异常庞大，目录下的内容不适合直接传输到生产环境，因此通常使用.gitignore文件忽略该目录中的内容本地安装适用于绝大部分的包，它会在当前目录及其子目录中发挥作用通常在项目的根目录中使用本地安装安装一个包的时候，npm 会自动管理依赖，它会下载该包的依赖包到node_modules目录中如果本地安装的包带有 CLI，npm 会将它的 CLI 脚本文件放置到node_modules/.bin下，使用命令npx 命令名即可调用 全局安装全局安装的包放置在一个特殊的全局目录，该目录可以通过命令npm config get prefix查看 使用命令npm install --global 包名 或 npm i -g 包名 重要：全局安装的包并非所有工程可用，它仅提供全局的 CLI 工具 大部分情况下，都不需要全局安装包，除非： 包的版本非常稳定，很少有大的更新 提供的 CLI 工具在各个工程中使用的非常频繁 CLI 工具仅为开发环境提供支持，而非部署环境 包配置目前遇到的问题： 拷贝工程后如何还原？ 如何区分开发依赖和生产依赖？ 如果自身的项目也是一个包，如何描述包的信息 以上这些问题都需要通过包的配置文件解决 配置文件npm 将每个使用 npm 的工程本身都看作是一个包，包的信息需要通过一个名称固定的配置文件来描述 配置文件的名称固定为：package.json 可以手动创建该文件，而更多的时候，是通过命令npm init创建的 配置文件中可以描述大量的信息，包括： name：包的名称，该名称必须是英文单词字符，支持连接符 version：版本 版本规范：主版本号.次版本号.补丁版本号 主版本号：仅当程序发生了重大变化时才会增长，如新增了重要功能、新增了大量的API、技术架构发生了重大变化 次版本号：仅当程序发生了一些小变化时才会增长，如新增了一些小功能、新增了一些辅助型的API 补丁版本号：仅当解决了一些 bug 或 进行了一些局部优化时更新，如修复了某个函数的 bug、提升了某个函数的运行效率 description：包的描述 homepage：官网地址 author：包的作者，必须是有效的 npm 账户名，书写规范是 account &lt;mail&gt;，例如：zhangsan &lt;zhangsan@gmail.com&gt;，不正确的账号和邮箱可能导致发布包时失败 repository：包的仓储地址，通常指 git 或 svn 的地址，它是一个对象 type：仓储类型，git 或 svn url：地址 main：包的入口文件，使用包的人默认从该入口文件导入包的内容 keywords: 搜索关键字，发布包后，可以通过该数组中的关键字搜索到包 使用npm init --yes或npm init -y可以在生成配置文件时自动填充默认配置 保存依赖关系大部分时候，我们仅仅是开发项目，并不会把它打包发布出去，尽管如此，我们仍然需要package.json文件 package.json文件最重要的作用，是记录当前工程的依赖 dependencies：生产环境的依赖包 devDependencies：仅开发环境的依赖包 配置好依赖后，使用下面的命令即可安装依赖 ## 本地安装所有依赖 dependencies + devDependencies npm install npm i ## 仅安装生产环境的依赖 dependencies npm install --production 这样一来，代码移植就不是问题了，只需要移植源代码和package.json文件，不用移植node_modules目录，然后在移植之后通过命令即可重新恢复安装 为了更加方便的添加依赖，npm支持在使用install命令时，加入一些额外的参数，用于将安装的依赖包保存到package.json文件中 涉及的命令如下 ## 安装依赖到生产环境 npm i 包名 npm i --save 包名 npm i -S 包名 ## 安装依赖到开发环境 npm i --save-dev 包名 npm i -D 包名 自动保存的依赖版本，例如^15.1.3，这种书写方式叫做语义版本号（semver version），具体规则后续讲解 包的使用nodejs 对 npm 支持非常良好 当使用 nodejs 导入模块时，如果模块路径不是以 ./ 或 ../ 开头，则 node 会认为导入的模块来自于 node_modules 目录，例如： var _ = require(\"lodash\"); 它首先会从当前目录的以下位置寻找文件 node_modules&#x2F;lodash.js node_modules&#x2F;lodash&#x2F;入口文件 若当前目录没有这样的文件，则会回溯到上级目录按照同样的方式查找 如果到顶级目录都无法找到文件，则抛出错误 上面提到的入口文件按照以下规则确定 查看导入包的package.json文件，读取main字段作为入口文件 若不包含main字段，则使用index.js作为入口文件 入口文件的规则同样适用于自己工程中的模块在 node 中，还可以手动指定路径来导入相应的文件，这种情况比较少见 语义版本思考：如果你编写了一个包A，依赖另外一个包B，你在编写代码时，包B的版本是2.4.1，你是希望使用你包的人一定要安装包B，并且是2.4.1版本，还是希望他可以安装更高的版本，如果你希望它安装更高的版本，高的什么程度呢？ 回顾：版本号规则 版本规范：主版本号.次版本号.补丁版本号 主版本号：仅当程序发生了重大变化时才会增长，如新增了重要功能、新增了大量的API、技术架构发生了重大变化 次版本号：仅当程序发生了一些小变化时才会增长，如新增了一些小功能、新增了一些辅助型的API 补丁版本号：仅当解决了一些 bug 或 进行了一些局部优化时更新，如修复了某个函数的 bug、提升了某个函数的运行效率 有的时候，我们希望：安装我的依赖包的时候，次版本号和补丁版本号是可以有提升的，但是主版本号不能变化 有的时候，我们又希望：安装我的依赖包的时候，只有补丁版本号可以提升，其他都不能提升 甚至我们希望依赖包保持固定的版本，尽管这比较少见 这样一来，就需要在配置文件中描述清楚具体的依赖规则，而不是直接写上版本号那么简单。 这种规则的描述，即语义版本 语义版本的书写规则非常丰富，下面列出了一些常见的书写方式 符号 描述 示例 示例描述 &gt; 大于某个版本 &gt;1.2.1 大于1.2.1版本 &gt;= 大于等于某个版本 &gt;=1.2.1 大于等于1.2.1版本 &lt; 小于某个版本 &lt;1.2.1 小于1.2.1版本 &lt;= 小于等于某个版本 &lt;=1.2.1 小于等于1.2.1版本 - 介于两个版本之间 1.2.1 - 1.4.5 介于1.2.1和1.4.5之间 x 不固定的版本号 1.3.x 只要保证主版本号是1，次版本号是3即可 ~ 补丁版本号可增 ~1.3.4 保证主版本号是1，次版本号是3，补丁版本号大于等于4 ^ 此版本和补丁版本可增 ^1.3.4 保证主版本号是1，次版本号可以大于等于3，补丁版本号可以大于等于4 * 最新版本 * 始终安装最新版本 避免还原的差异版本依赖控制始终是一个两难的问题 如果允许版本增加，可以让依赖包的bug得以修复（补丁版本号），可以带来一些意外的惊喜（次版本号），但同样可能带来不确定的风险（新的bug） 如果不允许版本增加，可以获得最好的稳定性，但失去了依赖包自我优化的能力 而有的时候情况更加复杂，如果依赖包升级后，依赖也发生了变化，会有更多不确定的情况出现 基于此，npm 在安装包的时候，会自动生成一个 package-lock.json 文件，该文件记录了安装包时的确切依赖关系 当移植工程时，如果移植了 package-lock.json 文件，恢复安装时，会按照 package-lock.json 文件中的确切依赖进行安装，最大限度的避免了差异 [扩展]npm的差异版本处理如果两个包依赖同一个包的不同版本，如下图 面对这种情况，在 node_modules 目录中，不会使用扁平的目录结构，而会形成嵌套的目录，如下： ├── node_modules │ ├── a │ │ ├── node_modules │ │ │ ├── c │ │ │ | |—— c包的文件 │ │ │── a包的文件 │ ├── b │ │ ├── node_modules │ │ │ ├── c │ │ │ | |—— c包的文件 │ │ │── b包的文件 npm 脚本 （npm scripts）在开发的过程中，我们可能会反复使用很多的 CLI 命令，例如： 启动工程命令（node 或 一些第三方包提供的CLI命令） 部署工程命令（一些第三方包提供的CLI命令） 测试工程命令（一些第三方包提供的CLI命令） 这些命令纷繁复杂，根据第三方包的不同命令也会不一样，非常难以记忆 于是，npm 非常贴心的支持了脚本，只需要在 package.json 中配置 scripts 字段，即可配置各种脚本名称 之后，我们就可以运行简单的指令来完成各种操作了 运行方式是 npm run 脚本名称 不仅如此，npm 还对某些常用的脚本名称进行了简化，下面的脚本名称是不需要使用run的： start stop test 一些细节： 脚本中可以省略npx start脚本有默认值：node server.js 运行环境配置我们书写的代码一般有三种运行环境： 开发环境 生产环境 测试环境 有的时候，我们可能需要在 node 代码中根据不同的环境做出不同的处理 如何优雅的让 node 知道处于什么环境，是极其重要的 通常我们使用如下的处理方式： node中有一个全局变量 global (可以类比浏览器环境的window)，该变量是一个对象，对象中的所有属性均可以直接使用 global有一个属性是process，该属性是一个对象，包含了当前运行node程序的计算机的很多信息，其中有一个信息是env，是一个对象，包含了计算机中所有的系统变量 通常，我们通过系统变量 NODE_ENV 的值，来判定node程序处于何种环境 有两种方式设置 NODE_ENV 的值 永久设置 临时设置 我们一般使用临时设置 因此，我们可以配置 scripts 脚本，在设置好了 NODE_ENV 后启动程序 为了避免不同系统的设置方式的差异，可以使用第三方库 cross-env 对环境变量进行设置 在node中读取package.json有的时候，我们可能在 package.json 中配置一些自定义的字段，这些字段需要在node中读取 在node 中，可以直接导入一个json格式的文件，它会自动将其转换为js对象 其他npm命令 {ignore}[toc] 安装 精确安装最新版本 npm install --save-exact 包名 npm install -E 包名 安装指定版本 npm install 包名@版本号 查询 查询包安装路径 npm root [-g] 查看包信息 npm view 包名 [子信息] ## view aliases：v info show 查询安装包 npm list [-g] [--depth&#x3D;依赖深度] ## list aliases: ls la ll 更新 检查有哪些包需要更新 npm outdated 更新包 npm update [-g] [包名] ## update 别名（aliases）：up、upgrade 卸载包npm uninstall [-g] 包名 ## uninstall aliases: remove, rm, r, un, unlink npm 配置npm的配置会对其他命令产生或多或少的影响 安装好npm之后，最终会产生两个配置文件，一个是用户配置，一个是系统配置，当两个文件的配置项有冲突的时候，用户配置会覆盖系统配置 通常，我们不关心具体的配置文件，而只关心最终生效的配置 通过下面的命令可以查询目前生效的各种配置 npm config ls [-l] [--json] 另外，可以通过下面的命令操作配置 获取某个配置项 npm config get 配置项 设置某个配置项 npm config set 配置项&#x3D;值 移除某个配置项 npm config delete 配置项 发布包准备工作 移除淘宝镜像源 到npm官网注册一个账号，并完成邮箱认证 本地使用 npm cli 进行登录 使用命令npm login登录 使用命令npm whoami查看当前登录的账号 使用命令npm logout注销 创建工程根目录 使用npm init进行初始化 发布 开发 确定版本 使用命令npm publish完成发布 # 开源协议 可以通过网站 http://choosealicense.online/appendix/ 选择协议，并复制协议内容","categories":[],"tags":[{"name":"工程化","slug":"工程化","permalink":"http://example.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]},{"title":"包管理器概述","slug":"工程化/包管理器概述","date":"2023-03-29T16:00:00.000Z","updated":"2023-03-30T06:31:51.026Z","comments":true,"path":"2023/03/30/工程化/包管理器概述/","link":"","permalink":"http://example.com/2023/03/30/%E5%B7%A5%E7%A8%8B%E5%8C%96/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E6%A6%82%E8%BF%B0/","excerpt":"","text":"包管理工具概述 前置知识：JavaScript、ES6、模块化、git所有代码均书写在 nodejs 环境中，不涉及浏览器环境 概念模块（module） 通常以单个文件形式存在的功能片段，入口文件通常称之为入口模块或主模块 库（library，简称lib） 以一个或多个模块组成的完整功能块，为开发中某一方面的问题提供完整的解决方案 包（package） 包含元数据的库，这些元数据包括：名称、描述、git主页、许可证协议、作者、依赖等等 背景CommonJS 的出现，使 node 环境下的 JS 代码可以用模块更加细粒度的划分。一个类、一个函数、一个对象、一个配置等等均可以作为模块，这种细粒度的划分，是开发大型应用的基石。 为了解决在开发过程中遇到的常见问题，比如加密、提供常见的工具方法、模拟数据等等，一时间，在前端社区涌现了大量的第三方库。这些库使用 CommonJS 标准书写而成，非常容易使用。 然而，在下载使用这些第三方库的时候，遇到难以处理的问题： 下载过程繁琐 进入官网或 github 主页 找到并下载相应的版本 拷贝到工程的目录中 如果遇到有同名的库，需要更改名称 如果该库需要依赖其他库，还需要按照要求先下载其他库 开发环境中安装的大量的库如何在生产环境中还原，又如何区分 更新一个库极度麻烦 自己开发的库，如何在下一次开发使用 以上问题，就是包管理工具要解决的问题 前端包管理器 npm：重点yarn：次重点其他：了解 几乎可以这样认为，前端所有的包管理器都是基于 npm 的，目前，npm 即是一个包管理器，也是其他包管理的基石 npm 全称为 node package manager，即 node 包管理器，它运行在 node 环境中，让开发者可以用简单的方式完成包的查找、安装、更新、卸载、上传等操作 npm 之所以要运行在 node 环境，而不是浏览器环境，根本原因是因为浏览器环境无法提供下载、删除、读取本地文件的功能。而 node 属于服务器环境，没有浏览器的种种限制，理论上可以完全掌控运行 node 的计算机。 npm 的出现，弥补了 node 没有包管理器的缺陷，于是很快，node 在安装文件中内置了 npm，当开发者安装好 node 之后，就自动安装了 npm，不仅如此，node 环境还专门为 npm 提供了良好的支持，使用 npm 下载的包更加方便了。 npm 由三部分组成： registry：入口 可以把它想象成一个庞大的数据库 第三方库的开发者，将自己的库按照 npm 的规范，打包上传到数据库中 使用者通过统一的地址下载第三方包 官网：https://www.npmjs.com/ 查询包 注册、登录、管理个人信息 CLI：command-line interface 命令行接口 讲解的重点 安装好 npm 后，通过 CLI 来使用 npm 的各种功能 node 和 npm 是互相成就的，node 的出现让 npm 火了，npm 的火爆带动了大量的第三方库的发展，很多优秀的第三方库打包上传到了 npm，这些第三方库又为 node 带来了大量的用户","categories":[],"tags":[{"name":"工程化","slug":"工程化","permalink":"http://example.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]},{"title":"CommonJs","slug":"工程化/CommonJs","date":"2023-03-28T16:00:00.000Z","updated":"2023-03-30T06:20:05.306Z","comments":true,"path":"2023/03/29/工程化/CommonJs/","link":"","permalink":"http://example.com/2023/03/29/%E5%B7%A5%E7%A8%8B%E5%8C%96/CommonJs/","excerpt":"","text":"在nodejs中，由于有且仅有一个入口文件（启动文件），而开发一个应用肯定会涉及到多个文件配合，因此，nodejs对模块化的需求比浏览器端要大的多 由于nodejs刚刚发布的时候，前端没有统一的、官方的模块化规范，因此，它选择使用社区提供的CommonJS作为模块化规范 在学习CommonJS之前，首先认识两个重要的概念：模块的导出和模块的导入 模块的导出要理解模块的导出，首先要理解模块的含义 什么是模块？ 模块就是一个JS文件，它实现了一部分功能，并隐藏自己的内部实现，同时提供了一些接口供其他模块使用 模块有两个核心要素：隐藏和暴露 隐藏的，是自己内部的实现 暴露的，是希望外部使用的接口 任何一个正常的模块化标准，都应该默认隐藏模块中的所有实现，而通过一些语法或api调用来暴露接口 暴露接口的过程即模块的导出 模块的导入当需要使用一个模块时，使用的是该模块暴露的部分（导出的部分），隐藏的部分是永远无法使用的。 当通过某种语法或api去使用一个模块时，这个过程叫做模块的导入 CommonJS规范CommonJS使用exports导出模块，require导入模块 具体规范如下： 如果一个JS文件中存在exports或require，该JS文件是一个模块 模块内的所有代码均为隐藏代码，包括全局变量、全局函数，这些全局的内容均不应该对全局变量造成任何污染 如果一个模块需要暴露一些API提供给外部使用，需要通过exports导出，exports是一个空的对象，你可以为该对象添加任何需要导出的内容 如果一个模块需要导入其他模块，通过require实现，require是一个函数，传入模块的路径即可返回该模块导出的整个内容 nodejs对CommonJS的实现为了实现CommonJS规范，nodejs对模块做出了以下处理 为了保证高效的执行，仅加载必要的模块。nodejs只有执行到require函数时才会加载并执行模块 为了隐藏模块中的代码，nodejs执行模块时，会将模块中的所有代码放置到一个函数中执行，以保证不污染全局变量。 (function()&#123; //模块中的代码 &#125;)() 为了保证顺利的导出模块内容，nodejs做了以下处理 在模块开始执行前，初始化一个值module.exports = &#123;&#125; module.exports即模块的导出值 为了方便开发者便捷的导出，nodejs在初始化完module.exports后，又声明了一个变量exports = module.exports (function(module)&#123; module.exports = &#123;&#125;; var exports = module.exports; //模块中的代码 return module.exports; &#125;)() 为了避免反复加载同一个模块，nodejs默认开启了模块缓存，如果加载的模块已经被加载过了，则会自动使用之前的导出结果","categories":[],"tags":[{"name":"工程化","slug":"工程化","permalink":"http://example.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]},{"title":"ES module","slug":"工程化/ES module","date":"2023-03-28T16:00:00.000Z","updated":"2023-03-30T06:18:49.478Z","comments":true,"path":"2023/03/29/工程化/ES module/","link":"","permalink":"http://example.com/2023/03/29/%E5%B7%A5%E7%A8%8B%E5%8C%96/ES%20module/","excerpt":"","text":"ES6模块化简介ECMA组织参考了众多社区模块化标准，终于在2015年，随着ES6发布了官方的模块化标准，后成为ES6模块化 ES6模块化具有以下的特点 使用依赖预声明的方式导入模块 依赖延迟声明 优点：某些时候可以提高效率 缺点：无法在一开始确定模块依赖关系（比较模糊） 依赖预声明 优点：在一开始可以确定模块依赖关系 缺点：某些时候效率较低 灵活的多种导入导出方式 规范的路径表示法：所有路径必须以./或../开头 基本导入导出模块的引入注意：这一部分非模块化标准 目前，浏览器使用以下方式引入一个ES6模块文件 &lt;script src=\"入口文件\" type=\"module\"> 模块的基本导出和导入ES6中的模块导入导出分为两种： 基本导入导出 默认导入导出 基本导出类似于 exports.xxx = xxxx 基本导出可以有多个，每个必须有名称 基本导出的语法如下： export 声明表达式 或 export &#123;具名符号&#125; 由于基本导出必须具有名称，所以要求导出内容必须跟上声明表达式或具名符号 基本导入由于使用的是依赖预加载，因此，导入任何其他模块，导入代码必须放置到所有代码之前 对于基本导出，如果要进行导入，使用下面的代码 import &#123;导入的符号列表&#125; from \"模块路径\" 注意以下细节： 导入时，可以通过关键字as对导入的符号进行重命名 导入时使用的符号是常量，不可修改 可以使用*号导入所有的基本导出，形成一个对象 默认导入导出 默认导出每个模块，除了允许有多个基本导出之外，还允许有一个默认导出 默认导出类似于CommonJS中的module.exports，由于只有一个，因此无需具名 具体的语法是 export default 默认导出的数据 或 export &#123;默认导出的数据 as default&#125; 由于每个模块仅允许有一个默认导出，因此，每个模块不能出现多个默认导出语句 默认导入需要想要导入一个模块的默认导出，需要使用下面的语法 import 接收变量名 from \"模块路径\" 类似于CommonJS中的 var 接收变量名 = require(\"模块路径\") 由于默认导入时变量名是自行定义的，因此没有别名一说 如果希望同时导入某个模块的默认导出和基本导出，可以使用下面的语法 import 接收默认导出的变量, &#123;接收基本导出的变量&#125; from \"模块路径\" 注：如果使用*号，会将所有基本导出和默认导出聚合到一个对象中，默认导出会作为属性default存在 ES6模块化的其他细节 尽量导出不可变值 当导出一个内容时，尽量保证该内容是不可变的（大部分情况都是如此） 因为，虽然导入后，无法更改导入内容，但是在导入的模块内部却有可能发生更改，这将导致一些无法预料的事情发生 可以使用无绑定的导入用于执行一些初始化代码 如果我们只是想执行模块中的一些代码，而不需要导入它的任何内容，可以使用无绑定的导入： import \"模块路径\" 可以使用绑定再导出，来重新导出来自另一个模块的内容 有的时候，我们可能需要用一个模块封装多个模块，然后有选择的将多个模块的内容分别导出，可以使用下面的语法轻松完成 export &#123;绑定的标识符&#125; from \"模块路径\"","categories":[],"tags":[{"name":"工程化","slug":"工程化","permalink":"http://example.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]},{"title":"浏览器渲染原理","slug":"js/浏览器渲染原理","date":"2023-03-15T16:00:00.000Z","updated":"2023-03-16T06:06:39.277Z","comments":true,"path":"2023/03/16/js/浏览器渲染原理/","link":"","permalink":"http://example.com/2023/03/16/js/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/","excerpt":"","text":"渲染时间点 渲染流⽔线 1. 解析 HTML - Parse HTML 为了提⾼解析效率，浏览器会启动⼀个预解析器率先下载和解析 CSS 渲染主线程遇到 JS 时必须暂停⼀切⾏为，等待下载执⾏完后才能继续预解析线程可以分担⼀点下载 JS 的任务 2. 样式计算 - Recalculate Style 3. 布局 - Layout DOM 树 和 Layout 树不⼀定是⼀⼀对应的 4. 分层 - Layer 页面变动的时候不会整体重绘 5. 绘制 - Paint渲染主线程的⼯作到此为⽌，剩余步骤交给其他线程完成 6. 分块 - Tiling 7. 光栅化 - Raster 8. 画 - Draw 完整过程 常⻅⾯试题什么是 reflow ？ 什么是 什么是 repaint? 什么是 什么是 为什么 transform 效率⾼？","categories":[],"tags":[]},{"title":"代码评审","slug":"工作项目/工作-代码评审","date":"2023-03-01T16:00:00.000Z","updated":"2023-03-02T03:38:52.140Z","comments":true,"path":"2023/03/02/工作项目/工作-代码评审/","link":"","permalink":"http://example.com/2023/03/02/%E5%B7%A5%E4%BD%9C%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E4%BD%9C-%E4%BB%A3%E7%A0%81%E8%AF%84%E5%AE%A1/","excerpt":"","text":"代码规范的必要性 规范的代码可以促进团队合作 规范的代码可以减少bug处理 规范的代码可以降低维护成本 养成代码规范的习惯，有助于程序员自身的成长… 代码展示超长if判断const fn = () => &#123; i.isThum = !i.isThum; if (i.isThum === true) &#123; // 判断类型，后续要添加(没有5) if (i.sourceType == 5) &#123; articleCommentThumb(data) .then((res) => &#123; i.likeCount++; uni.showToast(&#123; title: \"点赞成功\", icon: \"none\", duration: 1000, &#125;); &#125;) .catch((err) => &#123; uni.showToast(&#123; title: \"点赞失败\", icon: \"none\", duration: 1000, &#125;); &#125;); &#125; else if (i.sourceType == 1) &#123; perfumeCommentThumb(i.commentId) .then((res) => &#123; i.likeCount++; uni.showToast(&#123; title: \"点赞成功\", icon: \"none\", duration: 1000, &#125;); &#125;) .catch((err) => &#123; uni.showToast(&#123; title: \"点赞失败\", icon: \"none\", duration: 1000, &#125;); &#125;); &#125; else if (i.sourceType == 2) &#123; moodLike(&#123; moodId: i.commentId, &#125;) .then((res) => &#123; i.likeCount++; uni.showToast(&#123; title: \"点赞成功\", icon: \"none\", duration: 1000, &#125;); &#125;) .catch((err) => &#123; uni.showToast(&#123; title: \"点赞失败\", icon: \"none\", duration: 1000, &#125;); &#125;); &#125; else if (i.sourceType == 4) &#123; let datas = &#123; id: i.commentId, title: i.title, &#125;; ordinaryThumb(datas) .then((res) => &#123; i.likeCount++; uni.showToast(&#123; title: \"点赞成功\", icon: \"none\", duration: 1000, &#125;); &#125;) .catch((err) => &#123; uni.showToast(&#123; title: \"点赞失败\", icon: \"none\", duration: 1000, &#125;); &#125;); &#125; this.memberGrowthActivity(); &#125; else &#123; // 判断类型，后续要添加 if (i.sourceType == 5) &#123; articleCommentThumb(data) .then((res) => &#123; i.likeCount--; uni.showToast(&#123; title: \"取消点赞\", icon: \"none\", duration: 1000, &#125;); &#125;) .catch((err) => &#123; uni.showToast(&#123; title: \"取消失败\", icon: \"none\", duration: 1000, &#125;); &#125;); &#125; else if (i.sourceType == 1) &#123; perfumeCommentThumb(i.commentId) .then((res) => &#123; i.likeCount--; uni.showToast(&#123; title: \"取消点赞\", icon: \"none\", duration: 1000, &#125;); &#125;) .catch((err) => &#123; uni.showToast(&#123; title: \"取消失败\", icon: \"none\", duration: 1000, &#125;); &#125;); &#125; else if (i.sourceType == 4) &#123; let datas = &#123; id: i.commentId, title: i.title, &#125;; ordinaryThumb(datas) .then((res) => &#123; i.likeCount--; uni.showToast(&#123; title: \"取消点赞\", icon: \"none\", duration: 1000, &#125;); &#125;) .catch((err) => &#123; uni.showToast(&#123; title: \"取消失败\", icon: \"none\", duration: 1000, &#125;); &#125;); &#125; else if (i.sourceType == 2) &#123; moodLike(&#123; moodId: i.commentId, &#125;) .then((res) => &#123; i.likeCount--; uni.showToast(&#123; title: \"取消点赞\", icon: \"none\", duration: 1000, &#125;); &#125;) .catch((err) => &#123; uni.showToast(&#123; title: \"取消失败\", icon: \"none\", duration: 1000, &#125;); &#125;); &#125; &#125; &#125; 阅读性太差 缺少注释 复用性几乎没有 修改思路 不管取消点赞还是点赞，调用的接口都是同一个，所以没必要根据现有状态判断执行两次，唯一的变化是数量的减少和状态的修改 同一个属性多个不同的状态，可以改写成object[key]()的方式调用 根据数值判断的状态需要注释，时间长了就不记得了状态值得意思 // 点击成功执行 const successPrompt = () => &#123; let title = '点赞成功' if(i.isThum)&#123; i.likeCount--; title = '取消成功' &#125; else&#123; i.likeCount++; title = '点赞成功' &#125; uni.showToast(&#123; title, icon: \"none\", duration: 1000, &#125;); &#125; // 点击失败 const failurePrompt = () => &#123; let title = '点赞失败' if(i.isThum)&#123; title = '点赞失败' &#125; else&#123; title = '取消失败' &#125; uni.showToast(&#123; title, icon: \"none\", duration: 1000, &#125;); &#125; // 这里写一下注释 const data = &#123; 1: () => &#123; perfumeCommentThumb(i.commentId) .then((res) => &#123; successPrompt() &#125;) .catch((err) => &#123; failurePrompt() &#125;); &#125;, 2:() => &#123; moodLike(&#123;moodId: i.commentId&#125;) .then((res) => &#123; successPrompt() &#125;) .catch((err) => &#123; failurePrompt() &#125;); &#125;, 4:() => &#123; ordinaryThumb(&#123; id: i.commentId, title: i.title, &#125;) .then((res) => &#123; successPrompt() &#125;) .catch((err) => &#123; failurePrompt() &#125;); &#125; &#125; data[i.sourceType]()","categories":[],"tags":[{"name":"美逆项目","slug":"美逆项目","permalink":"http://example.com/tags/%E7%BE%8E%E9%80%86%E9%A1%B9%E7%9B%AE/"}]},{"title":"JS 事件循环","slug":"js/js-事件循环","date":"2023-02-27T16:00:00.000Z","updated":"2023-04-04T08:22:16.405Z","comments":true,"path":"2023/02/28/js/js-事件循环/","link":"","permalink":"http://example.com/2023/02/28/js/js-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"浏览器的进程模型何为进程？每个应⽤⾄少有⼀个进程，进程之间相互独⽴，即使要通信，也需要双⽅同意。 何为线程？有了进程后，就可以运⾏程序的代码了。运⾏代码的「⼈」称之为「线程」。 ⼀个进程⾄少有⼀个线程，所以在进程开启后会⾃动创建⼀个线程来运⾏代码，该线程称之为主线程。 如果程序需要同时执⾏多块代码，主线程就会启动更多的线程来执⾏代码，所以⼀个进程中可以包含多个线程。 浏览器有哪些进程和线程？浏览器是⼀个多进程多线程的应⽤程序 浏览器内部⼯作极其复杂。 为了避免相互影响，为了减少连环崩溃的⼏率，当启动浏览器后，它会⾃动启动多个进程 可以在浏览器的任务管理器中查看当前的所有进程 其中，最主要的进程有： 浏览器进程 主要负责界⾯显示、⽤户交互、⼦进程管理等。浏览器进程内部会启动多个线程处理不同的任务。 ⽹络进程 负责加载⽹络资源。⽹络进程内部会启动多个线程来处理不同的⽹络任务。 渲染进程 渲染进程启动后，会开启⼀个渲染主线程，主线程负责执⾏ HTML、CSS、JS 代码。 默认情况下，浏览器会为每个标签⻚开启⼀个新的渲染进程，以保证不同的标签⻚之间不相互影响 渲染主线程是如何⼯作的？ 渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于： 解析 HTML 解析 CSS 计算样式 布局 处理图层 每秒把⻚⾯画 60 次 执⾏全局 JS 代码 执⾏事件处理函数 执⾏计时器的回调函数… 如何调度任务？ 在最开始的时候，渲染主线程会进⼊⼀个⽆限循环 每⼀次循环会检查消息队列中是否有任务存在。如果有，就取出第⼀个任务执⾏，执⾏完⼀个后进⼊下⼀次循环；如果没有，则进⼊休眠状态。 其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务 整个过程，被称之为事件循环（消息循环） 何为异步？代码在执⾏过程中，会遇到⼀些⽆法⽴即处理的任务，⽐如： 计时完成后需要执⾏的任务 —— setTimeout 、 setInterval ⽹络通信完成后需要执⾏的任务 – XHR 、 Fetch ⽤户操作后需要执⾏的任务 – addEventListener如果让渲染主线程等待这些任务的时机达到，就会导致主线程⻓期处于「阻塞」的状态，从⽽导致浏览器「卡死」 渲染主线程承担着极其重要的⼯作，⽆论如何都不能阻塞！ ⾯试题：如何理解 JS 的异步？ 参考答案： JS是⼀⻔单线程的语⾔，这是因为它运⾏在浏览器的渲染主线程中，⽽渲染主线程只有⼀个。⽽渲染主线程承担着诸多的⼯作，渲染⻚⾯、执⾏ JS 都在其中运⾏。 如果使⽤同步的⽅式，就极有可能导致主线程产⽣阻塞，从⽽导致消息队列中的很多其他任务⽆法得到执⾏。这样⼀来，⼀⽅⾯会导致繁忙的主线程⽩⽩的消耗时间，另⼀⽅⾯导致⻚⾯⽆法及时更新，给⽤户造成卡死现象。所以浏览器采⽤异步的⽅式来避免。具体做法是当某些任务发⽣时，⽐如计时器、⽹络、事件监听，主线程将任务交给其他线程去处理，⾃身⽴即结束任务的执⾏，转⽽执⾏后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加⼊到消息队列末尾排队，等待主线程调度执⾏。 在这种异步模式下，浏览器永不阻塞，从⽽最⼤限度的保证了单线程的流畅运⾏ 任务有优先级吗？任务没有优先级，在消息队列中先进先出但消息队列是有优先级的 每个任务都有⼀个任务类型，同⼀个类型的任务必须在⼀个队列，不同类型的任务可以分属于不同的队列。 在⼀次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执⾏。浏览器必须准备好⼀个微队列，微队列中的任务优先所有其他任务执⾏ 随着浏览器的复杂度急剧提升，W3C 不再使⽤宏队列的说法 在⽬前 chrome 的实现中，⾄少包含了下⾯的队列： 微队列：⽤户存放需要最快执⾏的任务，优先级「最⾼」 交互队列：⽤于存放⽤户操作后产⽣的事件处理任务，优先级「⾼」 延时队列：⽤于存放计时器到达后的回调任务，优先级「中」 ⾯试题：阐述⼀下 JS 的事件循环参考答案：事件循环⼜叫做消息循环，是浏览器渲染主线程的⼯作⽅式。在 Chrome 的源码中，它开启⼀个不会结束的 for 循环，每次循环从消息队列中取出第⼀个任务执⾏，⽽其他线程只需要在合适的时候将任务加⼊到队列末尾即可。过去把消息队列简单分为宏队列和微队列，这种说法⽬前已⽆法满⾜复杂的浏览器环境，取⽽代之的是⼀种更加灵活多变的处理⽅式。根据 W3C 官⽅的解释，每个任务有不同的类型，同类型的任务必须在同⼀个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级在⼀次事件循环中，由浏览器⾃⾏决定取哪⼀个队列的任务。但浏览器必须有⼀个微队列，微队列的任务⼀定具有最⾼的优先级，必须优先调度执⾏。 ⾯试题：JS 中的计时器能做到精确计时吗？为什么？参考答案：不⾏，因为：1.计算机硬件没有原⼦钟，⽆法做到精确计时2.操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调⽤的是操作系统的函数，也就携带了这些偏差3.按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时⼜带来了偏差4.受事件循环的影响，计时器的回调函数只能在主线程空闲时运⾏，因此⼜带来了偏差","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"addEventListener方法使用","slug":"js/js-addEventListener","date":"2022-09-23T03:27:15.101Z","updated":"2022-09-23T07:27:47.020Z","comments":true,"path":"2022/09/23/js/js-addEventListener/","link":"","permalink":"http://example.com/2022/09/23/js/js-addEventListener/","excerpt":"","text":"addEventListener() 方法用于向指定元素添加监听事件。且同一元素目标可重复添加，不会覆盖之前相同事件，配合 removeEventListener() 方法来移除事件 document.getElementById(元素id).addEventListener(\"click\", function()&#123; console.log(\"目标元素被点击了\"); &#125;); 参数说明：有三个参数参数一、事件名称，字符串，必填。 事件名称不用带 “on” 前缀，点击事件直接写：”click”，键盘放开事件写：”keyup”参数二、执行函数，必填。 填写需要执行的函数，如：function(){代码…}当目标对象事件触发时，会传入一个事件参数，参数名称可自定义，如填写event，不需要也可不填写。 事件对象的类型取决于特定的事件。例如， “click” 事件属于 MouseEvent(鼠标事件) 对象。function(event){console.log(event)}参数三、触发类型，布尔型，可空 true - 事件在捕获阶段执行false - 事件在冒泡阶段执行，默认是false 参数一的事件类型大致有如下选择 鼠标事件click 当用户点击某个对象时调用的事件句柄。contextmenu 在用户点击鼠标右键打开上下文菜单时触发dblclick 当用户双击某个对象时调用的事件句柄。mousedown 鼠标按钮被按下。mouseenter 当鼠标指针移动到元素上时触发。mouseleave 当鼠标指针移出元素时触发mousemove 鼠标被移动。mouseover 鼠标移到某元素之上。mouseout 鼠标从某元素移开。mouseup 鼠标按键被松开。 键盘事件属性 描述 DOMkeydown 某个键盘按键被按下。keypress 某个键盘按键被按下并松开。keyup 某个键盘按键被松开。 框架/对象（Frame/Object）事件abort 图像的加载被中断。 ( )beforeunload 该事件在即将离开页面（刷新或关闭）时触发error 在加载文档或图像时发生错误。 ( , 和 )hashchange 该事件在当前 URL 的锚部分发生修改时触发。load 一张页面或一幅图像完成加载。pageshow 该事件在用户访问页面时触发pagehide 该事件在用户离开当前网页跳转到另外一个页面时触发resize 窗口或框架被重新调整大小。scroll 当文档被滚动时发生的事件。unload 用户退出页面。 ( 和 ) 表单事件blur 元素失去焦点时触发change 该事件在表单元素的内容改变时触发( , , , 和 )focus 元素获取焦点时触发focusin 元素即将获取焦点是触发focusout 元素即将失去焦点是触发input 元素获取用户输入是触发reset 表单重置时触发search 用户向搜索域输入文本时触发 ( 剪贴板事件copy 该事件在用户拷贝元素内容时触发cut 该事件在用户剪切元素内容时触发paste 该事件在用户粘贴元素内容时触发 打印事件afterprint 该事件在页面已经开始打印，或者打印窗口已经关闭时触发beforeprint 该事件在页面即将开始打印时触发 拖动事件drag 该事件在元素正在拖动时触发dragend 该事件在用户完成元素的拖动时触发dragenter 该事件在拖动的元素进入放置目标时触发dragleave 该事件在拖动元素离开放置目标时触发dragover 该事件在拖动元素在放置目标上时触发dragstart 该事件在用户开始拖动元素时触发drop 该事件在拖动元素放置在目标区域时触发 多媒体（Media）事件abort 事件在视频/音频（audio/video）终止加载时触发。canplay 事件在用户可以开始播放视频/音频（audio/video）时触发。canplaythrough 事件在视频/音频（audio/video）可以正常播放且无需停顿和缓冲时触发。durationchange 事件在视频/音频（audio/video）的时长发生变化时触发。emptied The event occurs when the current playlist is emptyended 事件在视频/音频（audio/video）播放结束时触发。error 事件在视频/音频（audio/video）数据加载期间发生错误时触发。loadeddata 事件在浏览器加载视频/音频（audio/video）当前帧时触发触发。loadedmetadata 事件在指定视频/音频（audio/video）的元数据加载后触发。loadstart 事件在浏览器开始寻找指定视频/音频（audio/video）触发。pause 事件在视频/音频（audio/video）暂停时触发。play 事件在视频/音频（audio/video）开始播放时触发。playing 事件在视频/音频（audio/video）暂停或者在缓冲后准备重新开始播放时触发。progress 事件在浏览器下载指定的视频/音频（audio/video）时触发。ratechange 事件在视频/音频（audio/video）的播放速度发送改变时触发。seeked 事件在用户重新定位视频/音频（audio/video）的播放位置后触发。seeking 事件在用户开始重新定位视频/音频（audio/video）时触发。stalled 事件在浏览器获取媒体数据，但媒体数据不可用时触发。suspend 事件在浏览器读取媒体数据中止时触发。timeupdate 事件在当前的播放位置发送改变时触发。volumechange 事件在音量发生改变时触发。waiting 事件在视频由于要播放下一帧而需要缓冲时触发。 动画事件animationend 该事件在 CSS 动画结束播放时触发animationiteration 该事件在 CSS 动画重复播放时触发animationstart 该事件在 CSS 动画开始播放时触发 过渡事件transitionend 该事件在 CSS 完成过渡后触发。 其他事件message 该事件通过或者从对象(WebSocket, Web Worker, Event Source 或者子 frame 或父窗口)接收到消息时触发online 该事件在浏览器开始在线工作时触发。offline 该事件在浏览器开始离线工作时触发。popstate 该事件在窗口的浏览历史（history 对象）发生改变时触发。 event occurs when the window’s history changesshow 该事件当 元素在上下文菜单显示时触发storage 该事件在 Web Storage(HTML 5 Web 存储)更新时触发toggle 该事件在用户打开或关闭 元素时触发wheel 该事件在鼠标滚轮在元素上下滚动时触发","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"前端生成文档","slug":"工具/前端生成文档","date":"2022-06-12T16:00:00.000Z","updated":"2022-06-13T07:54:20.738Z","comments":true,"path":"2022/06/13/工具/前端生成文档/","link":"","permalink":"http://example.com/2022/06/13/%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E7%94%9F%E6%88%90%E6%96%87%E6%A1%A3/","excerpt":"","text":"前端生成文档需要插件file-saver、html-docx-jsyarn add file-saver --save yarn add html-docx-js --save 生成方式主要通过将html代码转化成文档 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\" /> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;div onclick=\"gogogo()\">下载&lt;/div> &lt;/body> &lt;script src=\"./node_modules/file-saver/dist/FileSaver.min.js\">&lt;/script> &lt;script src=\"./node_modules/html-docx-js/dist/html-docx.js\">&lt;/script> &lt;script src=\"./htmlTemp.js\">&lt;/script> &lt;script> function gogogo() &#123; var domString = htmlTemp(&#123;&#125;); var converted = htmlDocx.asBlob(domString); saveAs(converted, \"1111.docx\"); &#125; &lt;/script> &lt;/html> /* 注意事项: 1. 经过反复尝试, 设置div高度在docx文件中无效 解决设置上下垂直距离方法： &lt;div class=\"item-kong\">&amp;nbsp;&amp;nbsp;&lt;/div> */ // 打印word的html模板 function htmlTemp(&#123; d = \"测试\" &#125;) &#123; const htmlTemp = `&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>&lt;/title> &lt;style> .head-title&#123; text-align: center; font-size: 20px; &#125; .base-title&#123; font-size: 20px; font-weight: 800; &#125; .base-items .item&#123; font-size: 14px; height: 20px; line-height:20px; &#125; .set-color-one &#123; color:#e63f32; &#125; .set-color-two&#123; color:#fc011a; &#125; .err-msg&#123; font-size: 28px; font-weight: 800; color:red; &#125; &lt;/style> &lt;/head> &lt;body> &lt;div class=\"head-title\">自评得分&lt;/div> &lt;div class=\"part-one\"> &lt;div class=\"base-title\">一、基本信息&lt;/div> &lt;div>&amp;nbsp;&amp;nbsp;&lt;/div> &lt;div class=\"base-items\"> &lt;div class=\"item\">计划名称：&lt;/div> &lt;div class=\"item\">自评组：$&#123;d&#125;&lt;/div> &lt;div class=\"item\">填报人：$&#123;d&#125;&lt;/div> &lt;div class=\"item\">实评时间：$&#123;d&#125;&lt;/div> &lt;div class=\"item\">自评组长：$&#123;d&#125;&lt;/div> &lt;div class=\"item\">自评组员：$&#123;d&#125;&lt;/div> &lt;/div> &lt;div>&amp;nbsp;&amp;nbsp;&lt;/div> &lt;/div> &lt;div class=\"part-two\"> &lt;div class=\"base-title\">二、$&#123;d&#125;考评项目&lt;/div> &lt;div>&amp;nbsp;&amp;nbsp;&lt;/div> &lt;div class=\"base-items\"> $&#123;d&#125; &lt;/div> &lt;div>&amp;nbsp;&amp;nbsp;&lt;/div> &lt;/div> &lt;div class=\"part-three\"> &lt;div class=\"base-title\">三、自评得分统计&lt;/div> &lt;div>&amp;nbsp;&amp;nbsp;&lt;/div> &lt;div class=\"base-items\"> &lt;div>总扣分项(不计小项)：$&#123;d&#125;&lt;/div> &lt;div>总目标分：$&#123;d&#125;&lt;/div> &lt;div>总扣分值：$&#123;d&#125;&lt;/div> &lt;div>总实得分：$&#123;d&#125;&lt;/div> &lt;div>总得分率：$&#123;d&#125;&lt;/div> &lt;/div> &lt;div>&amp;nbsp;&amp;nbsp;&lt;/div> &lt;/div> &lt;div class=\"part-four\"> &lt;div class=\"base-title\">四、主要问题及整改建议（凡扣分项均应有问题与整改建议）&lt;/div> &lt;div>&amp;nbsp;&amp;nbsp;&lt;/div> &lt;div class=\"base-items\"> &lt;div>$&#123;d&#125;&lt;/div> &lt;/div> &lt;div>&amp;nbsp;&amp;nbsp;&lt;/div> &lt;/div> &lt;/body> &lt;/html>`; return htmlTemp; &#125;","categories":[],"tags":[]},{"title":"新疆纤检项目总结","slug":"工作项目/新疆纤检项目总结","date":"2022-06-08T16:00:00.000Z","updated":"2022-06-10T03:13:01.330Z","comments":true,"path":"2022/06/09/工作项目/新疆纤检项目总结/","link":"","permalink":"http://example.com/2022/06/09/%E5%B7%A5%E4%BD%9C%E9%A1%B9%E7%9B%AE/%E6%96%B0%E7%96%86%E7%BA%A4%E6%A3%80%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/","excerpt":"","text":"使用技术vue2.0 + element + axios + vue-router + vuex + pdf.js 项目概要新疆维吾尔自治区纤维质量监测中心的一个用来管理培训的项目从用户的角度来说一共有两种：管理人员和用户（用户分为企业用户和个人用户）主要的功能是对用户进行培训开班，可以理解为一个报名系统。还有一些附带的功能。 培训管理系统 知识库 信用平台 统一登录平台 培训管理系统普通管理系统 O(∩_∩)O哈哈~ 系统管理 菜单管理 角色管理 用户管理 资源分配 首页 培训管理 班级管理 证书管理 订单管理 财务管理 通过角色分配不同的菜单，进入对应的角色页面 知识库知识库分页用户查看页面和后台页面 后台 首页 标准管理 全部标准 录入标准 分类 回收站 查看页面主要功能 查看后台增加的标准 查看pdf这里有个查看pdf并且不让下载打印，使用到pdf.js，然后再插件里面通过js控制不让打印&lt;script type=\"text/javascript\"> // function stop() &#123; // return false; // &#125; // document.oncontextmenu = stop; const disabled = () => &#123; // console.log('禁止脚本，运行成功'); const config = &#123; rightKey: false, // 是否开启右键菜单 controller: false, // 是否开启控制台 print: false, // 是否允许打印 savePage: false, // 是否允许 ctrl + s 保存网页 乌发禁用菜单保存 &#125;; function loadStyleString(cssText) &#123; var style = document.createElement(\"style\"); style.type = \"text/css\"; try &#123; // firefox、safari、chrome和Opera style.appendChild(document.createTextNode(cssText)); &#125; catch (ex) &#123; // IE早期的浏览器 ,需要使用style元素的stylesheet属性的cssText属性 style.styleSheet.cssText = cssText; &#125; document.getElementsByTagName(\"head\")[0].appendChild(style); &#125; // disabeld // 禁用部分功能 // 右键禁用 if (!config.rightKey) document.oncontextmenu = () => false; // 打印 if (!config.print) &#123; let cssIndex = Array(...document.styleSheets).findIndex( (item) => item.href == null ); // 禁止打印 添加媒体查询 css 打印时隐藏所有内容 loadStyleString(` @media print &#123; body &#123; display: none; &#125; html::after &#123; content: \"禁止打印!\"; position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 80px; letter-spacing: 15px; color: brown; &#125; &#125; `); &#125; // 禁用 ctrl + s 和 F12 控制台 window.addEventListener( \"keydown\", function (e) &#123; if (e.keyCode == 123 &amp;&amp; !config.controller) &#123; e.preventDefault(); return false; // alert('禁止打开控制台') &#125; //可以判断是不是mac，如果是mac,ctrl变为花键 //event.preventDefault() 方法阻止元素发生默认的行为。 if ( e.keyCode == 83 &amp;&amp; (navigator.platform.match(\"Mac\") ? e.metaKey : e.ctrlKey) &amp;&amp; !config.savePage ) &#123; e.preventDefault(); return false; // Process event... // alert('禁止保存网页') &#125; &#125;, false ); // 控制台 if (!config.controller) &#123; var threshold = 200; var widthThreshold = window.outerWidth - window.innerWidth > threshold; var heightThreshold = window.outerHeight - window.innerHeight > threshold; function exit() &#123; loadStyleString(` body &#123; display: none; &#125; html::after &#123; content: \"请关闭控台，并F5重新刷新页面!\"; position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 50px; letter-spacing: 15px; color: brown; &#125; `); &#125; // (function () &#123; var re = /x/; var i = 0; console.log(re); re.toString = function () &#123; exit(); &#125;; &#125;)(); // if (widthThreshold || heightThreshold) &#123; exit(); &#125; &#125; &#125;; window.addEventListener(\"load\", disabled); &lt;/script> 信用平台主要就是增删改，上传一些企业用户的基础信息 项目感受还是比较简单的项目，以后还是想挑战难一点的东西。不想再写业务逻辑了。。。。。。只接触到dpf.js禁止打印一个新东西 function set()&#123; console.log(1); setTimeout(() => &#123; console.log(2) &#125;,0) new Promise((reolve) => &#123; console.log(3) reolve() &#125;).then(() => &#123; console.log(4); &#125;) &#125;","categories":[],"tags":[{"name":"项目总结","slug":"项目总结","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"}]},{"title":"管理系统的菜单和路由","slug":"工作项目/管理系统菜单和路由","date":"2022-04-21T16:00:00.000Z","updated":"2022-06-09T07:36:53.304Z","comments":true,"path":"2022/04/22/工作项目/管理系统菜单和路由/","link":"","permalink":"http://example.com/2022/04/22/%E5%B7%A5%E4%BD%9C%E9%A1%B9%E7%9B%AE/%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%8F%9C%E5%8D%95%E5%92%8C%E8%B7%AF%E7%94%B1/","excerpt":"","text":"前端菜单和路由菜单 直接前端写死菜单 根据路由来渲染 路由 前端直接写死 后端返回 根据路由渲染的菜单怎么区分哪些是菜单前端直接写死在写路由的时候可以加上属性 hidden: true如果 hidden是true的时候我们就不把这个路由显示为菜单 &#123; path: '/enterprise', component: Layout, name: 'enterprise', meta: &#123; title: '企业管理', icon: 'product' &#125;, children: [&#123; path: 'information', name: 'information', component: () => import('@/views/enterprise/information'), meta: &#123; title: '企业信息' &#125;, hidden: false &#125;, &#123; path: 'detail', name: 'detail', component: () => import('@/views/enterprise/detail'), meta: &#123; title: '新增企业' &#125;, hidden: true &#125;, ] &#125; 后端返回（大多数情况也后端返回的） 后端返回的话就会有个菜单管理，我们可以新增菜单和配置菜单的地址和我们前端组件的相对地址 后端返回的数据也有两种格式（1.直接返回菜单树 2.返回的是一维数组，这时候我们需要根据id和pid的关系处理成菜单树） 需要使用递归生成路由表// 处理路由 const loadView = (url) => &#123; // 路由懒加载 return (resolve) => require([`@/views$&#123;url&#125;`], resolve) &#125; // 这个方法返回的结果是一个路由表 跟你手写的路由表是一样的 我这里删除了一些其他的逻辑 只留了主要逻辑 不能拿到其他项目使用!!! function settingUpDynamicRouting(data) &#123; const res = [] for (let i = 0; i &lt; data.length; i++) &#123; const obj = &#123;&#125; if (data[i].children &amp;&amp; data[i].children.length > 0) &#123; if (data[i].extend.type === 1) &#123; // 这里根据type === 1 来判断是布局组件还是布局页面下的二级路由 （每个项目判断的方式都不一样，看你们公司怎么判断，而且每个项目也都不一样，你明白原理就行） obj.children = settingUpDynamicRouting(data[i].children) obj.component = Layout // Layout这个是布局组件，你也可以理解为一级路由 &#125; else if (data[i].extend.type === 2) &#123; // type === 2 是二级路由，就是布局页面下展示的页面 obj.component = loadView(data[i].extend.path) // loadView() 通过这个方法动态获取组件 &#125; &#125; res.push(obj) &#125; return res &#125; // 最后需要通过router.addRoutes()方法把我们要添加的路由加进去。 （这句话可以不管：这里是我们现在常用的vue-router的方法 最新版本的好像是改名字了 但是用法是一样的） router.beforeEach(async(to, from, next) => &#123; // async 你能理解的话就看，要是不懂的话就不管。这个也可以不要，可以后面学学 const hasToken = getToken() if (hasToken) &#123; // 登录了 if (store.getters.menuList.length > 0) &#123; // 有路由信息，我这里请求的时候也存到了vuex，因为vuex里面的数据刷新以后就没有了，所以刷新页面以后是会重新请求的 next() &#125; else &#123; // 没有路由信息，就重新去请求 store .dispatch('user/getMenu', userInfo.id) // 处理路由数据的方法我放到vuex里面去做了，所以这个方法返回的是直接可以使用的路由表 .then((res) => &#123; // 获取获取菜单 router.addRoutes(res) // 动态添加可访问路由表。 （router除了可以添加路由表，也有删除路由的方法，这些东西平常你多看文档） next(&#123; ...to, replace: true &#125;)// 路由添加以后进入要去的页面 &#125;) .catch(() => &#123; next(&#123; path: '/login' &#125;) // 请求失败的话去登录页面。我这里让用户去登录页面了，因为大部分是因为token过期，但是这个做其实不太好，应该在请求响应拦截器做这件事 &#125;) &#125; &#125; else &#123;// 没登录 if (whiteList.indexOf(to.path) !== -1) &#123; // whiteList这个是路由的白名单，如登录页面，注册页面等不需要登录能够直接进去的 next() // 进入页面 &#125; else &#123; // 否则就跳到到登录页面 next(`/login?redirect=$&#123;to.path&#125;`) &#125; &#125; &#125;) 动态路由的菜单渲染部分是一样的 根据hidden来判断要显示哪些菜单按钮","categories":[],"tags":[{"name":"管理系统","slug":"管理系统","permalink":"http://example.com/tags/%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"}]},{"title":"关于面试","slug":"面试/关于面试","date":"2022-03-14T16:00:00.000Z","updated":"2022-03-15T08:56:06.351Z","comments":true,"path":"2022/03/15/面试/关于面试/","link":"","permalink":"http://example.com/2022/03/15/%E9%9D%A2%E8%AF%95/%E5%85%B3%E4%BA%8E%E9%9D%A2%E8%AF%95/","excerpt":"","text":"面试注意事项 要写清楚自己会哪些东西 要把上家公司描述清楚，做什么业务的，项目来源于什么 工作经历，尽量详细，具体到做了什么项目，用了什么技术 项目要写清楚项目交付结果或者上线反应 注意写的时候不要有读的有问题的介绍 投简历可以多投，投放时间尽量在上班时间 面试可以多接受，去不了的可以要求视频面或者电话面 面试过程中不要紧张，把自己当做一个工作很多年的工作者，听清楚面试官说的话。没听清或者不懂的地方可以再问面试官 面试官问一个问题以后如果你知道后面涉及到的问题尽量往深了说、尽量详细、逻辑要清楚。 如果面试官问的问题确实不会，就说这方面的东西没有用到过(但是不要是非常常见的知识点哈),不太清楚,稍后会去了解。 面试前要多刷题，如果面试官问你平常怎么学习，你就说看文档，买课看视频都可以。 面试完成以后要立即把面试官问的问题记录下来，并且找到答案。然后总结一下面试 我面试的套路 我会让面试者先自我介绍,然后根据他的介绍引出问题。 要求： 个人信息 上家公司是做什么的 团队的组成和运作方式 掌握哪些技术 讲一个简历上的项目（项目是做什么的，怎么搭建，用了什么技术以及使用目的，项目是否交付或者上线，评价如何，个人对这个项目的评价或者感受，学习到了什么。。。） 如果面试者介绍的比较简单我会主动去问6. 针对他自我介绍的项目具体问怎么使用某一个技术。 如: 1、怎么使用router,有哪些钩子函数，怎么使用，什么场景下使用。… 2、响应式原理。。。7. css方面的 flex px/rem/em什么意思以及比例的计算（我个人面试css问的比较少）8. js方面 js数据类型 -&gt; 基础数据类型和引用数据类型的区别 -&gt; 怎么解决引用数据类型赋值问题 -&gt; 深拷贝和浅拷贝的区别 -&gt; 使用JSON深拷贝的弊端 -&gt; 手写深拷贝方法的逻辑 js类型转换 -&gt; 哪些操作造成类型转换 -&gt; 怎么判断类型(判断的方法很多，如果你说typeof，就会问你他的弊端，最好的方式是Object.prototype.toString.call([])) 作用域 -&gt; 查找方式 -&gt; 闭包 -&gt; 闭包会造成什么 -&gt; 为什么会这样 -&gt;js垃圾回收机制 -&gt; 标记清除/引用计数的逻辑 -&gt; 怎么解决闭包中的变量无法释放 原型链 -&gt; 查找方式 -&gt; proto 与 prototype 的区别 es6 -&gt; 用过哪些特性 -&gt; let、const、var的区别 -&gt; 箭头函数与普通函数的区别 怎么创建一个原生请求(new XMLHttpRequest()) -&gt; 怎么封装一个通用请求 js执行机制 -&gt; 事件循环 -&gt; 微任务宏任务 -&gt; 哪些是微任务哪些是宏任务 Promise怎么使用、async\\await怎么使用 -&gt; async\\await实现原理 -&gt; 怎么在async\\await中抛出错误 再就是vue或者react上的问题了，这个问的太广了。可以是使用层面上，也可以是源码级别的。这种就网上看看常见的记住，或者直接背下来","categories":[],"tags":[]},{"title":"网络基础","slug":"网络/网络基础","date":"2022-01-25T16:00:00.000Z","updated":"2022-02-11T03:46:34.003Z","comments":true,"path":"2022/01/26/网络/网络基础/","link":"","permalink":"http://example.com/2022/01/26/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/","excerpt":"","text":"网络数据传输方式一层一层的打包 然后一层一层的解析 发送者的数据从应用层到传输层 会增加TCP Header (端口) 然后到网络层 会增加IP header (IP地址) 然后到链路层 会增加以太网 Header (MAC地址) 通过传输介质到接收者 以太网发现有个 以太网的Header 就把这个包给对应的MAC地址 然后传到网络层 IP协议解析这个包 找到对应的IP地址 发送过去 然后传到传输层 解析到端口 传给对应端口的应用 以太网 网卡和MAC地址MAC地址： 00-05-5D-E8-0F-A3交换机就是根据MAC地址转发数据的 电脑通过网卡连接网络 每块网卡有个厂商设定的MAC地址（又称物理地址） 这个地址是设备的唯一标识 网卡的MAC地址可以通过驱动改变（只要在同一个链路里面没有相同的话不会有影响） 以太网的Header 目标MAC地址（6字节） 源MAC地址（6字节） 类型 （2字节） 数据（46~1500字节） FCS（4字节，帧检验序列） IP协议IP地址 又32位二进制数组成 分为网络标识和主机标识两部分 子网掩码确定了32位里面哪些是主机标识哪些是网络标识1为网络标识，0为主机标识 路由控制在同一个网络下的数据传输： 应用层192.168.0.1 给 192.168.0.1 发送信息 传输层 增加TCP Header 记录端口： from 80 to 80 网络层 增加IP Header 记录ip: from 192.168.0.1 to 192.168.0.2 以太网 增加以太网 Header from 00-05-5D-E8-A3 to ???这个时候以太网知道发送者的MAC地址，同时在MAC地址表记录下来，但是不知道接收者192.168.0.2 的MAC地址 这时候会发一个ARP广播 对应的信息有发送者的ip和MAC地址接收者的IP地址和MAC（FFFFFF） 交换机收到目标MAC地址为FFFFFF 会发送一个广播给连接交换机的所有电脑 查询对目标IP对应电脑MAC地址 当目标电脑收到信息以后会将MAC地址告诉发送者，同时也会经过交换机，交换机会在MAC地址表记录下来 知道目标的MAC地址以后就可以将MAC地址补到之前缺失的MAC地址上 最后一层层解析数据就到了192.168.0.2的电脑上 网络之间的数据传输 将出数据从192.168.0.1 发送给 172.6.0.1 因为ip不是在同一个网段所以会发送给网关（192.168.0.254） 但是不知道网关的MAC地址，所以会发起ARP查询 然后收到网关的ARP响应，将MAC地址补上并且把数据发送给网关192.168.0.254） 网关收到192.168.0.1发来的数据，发现目标的IP地址也不是自己，然后查询路由表得知自己应该发送给路由器B 也就是192.168.1.254 然后再次发起ARP查询 找到192.168.1.254 MAC地址 并发送给过去 直到发送到路由器C，路由器C查询他自己的路由表发现，这个网段是自己直连的，然后查询ARP缓存里面有没有IP对应的MAC地址，只要172.6.0.1往外面发过数据，那么他的MAC地址就会被缓存下来，如果没有发送过那就发起ARP广播查询172.6.0.1MAC地址，拿到地址以后将目标的MAC地址更改为172.6.0.1MAC地址，将数据发送过去。 经过网络层和传输层172.6.0.1拿到最终数据 IP分片和重组 不同的网络上最大传输单元（MTU）的大小是不一样的 IP协议这是网络的上层封装，它对此进行了抽象 路径发现MTU会在发送数据帧超过网络MTU时自动调整并重发数据 IP报文由路由器进行分片，目标主机进行重组","categories":[],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}]},{"title":"前端常见面试题","slug":"面试/前端常见面试题","date":"2022-01-23T16:00:00.000Z","updated":"2022-03-15T07:30:54.424Z","comments":true,"path":"2022/01/24/面试/前端常见面试题/","link":"","permalink":"http://example.com/2022/01/24/%E9%9D%A2%E8%AF%95/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"vue单页面应用（SPA） 是加载单个 HTML 页面并在用户与应用程序交互时动态更新该页面的。它将所有的活动局限于一个 Web 页面中，仅在该 Web 页面初始化时加载相应的 HTML 、 JavaScript 、 CSS 。一旦页面加载完成， SPA 不会因为用户的操作而进行页面的重新加载或跳转，而是利用 JavaScript 动态的变换 HTML（采用的是 div 切换显示和隐藏），从而实现UI与用户的交互。在 SPA 应用中，应用加载之后就不会再有整页刷新。相反，展示逻辑预先加载，并有赖于内容Region（区域）中的视图切换来展示内容。 优点 有良好的交互体验能提升页面切换体验，用户在访问应用页面是不会频繁的去切换浏览页面，从而避免了页面的重新加载； 2. 前后端分离开发单页Web应用可以和 RESTful 规约一起使用，通过 REST API 提供接口数据，并使用 Ajax 异步获取，这样有助于分离客户端和服务器端工作。更进一步，可以在客户端也可以分解为静态页面和页面交互两个部分； 3. 减轻服务器压力服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍； 4. 共用一套后端程序代码不用修改后端程序代码就可以同时用于 Web 界面、手机、平板等多种客户端；缺点 SEO难度较高由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势，所以如果你的站点对SEO很看重，且要用单页应用，那么就做些静态页面给搜索引擎用吧； 前进、后退管理由于单页Web应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理，当然此问题也有解决方案，比如利用URI中的散列+iframe实现； 初次加载耗时多为实现单页Web应用功能及显示效果，需要在加载页面的时候将JavaScript、CSS统一加载，部分页面可以在需要的时候加载。所以必须对JavaScript及CSS代码进行合并压缩处理；性能优化在SPA中，通常一开始就会加载所有必需的代码（HTML，JavaScript和CSS），有时候考虑到首屏加载太慢会按需加载，按需加载就是按照当前呈现的不同页面加载不同的文件，而不是最开始就把所有文件都加载出来，从而避免首屏加载很慢。当首屏加载完毕后，设备&amp;网络处于空闲状态，可以对其他路由组件进行预加载，以便提升页面切换性能。根据路由拆分减少初始加载体积,利用异步加载方式，在路由注册时提供异步拉取组件的方法，仅在需要进入对应路由时，对应组件才会被加载进来。 * 初次加载的速度 单页应用的第一页加载会比基于服务器的应用慢。这是因为首次加载必须先拿到框架和应用程序的代码，再在浏览器中呈现所需的视图。基于服务器的应用程序只需将所需的HTML推送到浏览器，从而减少了延迟和下载用时。 * 加快页面加载速度 有一些方法可以加快单页应用的初次加载速度，比如采用多项缓存措施、需要时再加载某些模块（懒加载）。 * 页面生命周期 单页应用在初始页面加载时被完全加载，然后页面区域被替换或更新为按需从服务器加载的新页面片段。为避免过度下载未使用的功能，单页应用通常会逐渐下载更多内容，如所需要的功能、页面的一小块，或者完整的一页。 MVVMvue的响应式原理data为什么是函数v-if 和 v-show 的区别v-mode 原理computed、watch、methodvue生命周期vue组件通讯vue单向数据流keep-alive组件slot 插槽vue检测数组或对象的变化虚拟domnextTick的原理vueXvue-rouer的两种模式vue-router有哪几种导航钩子","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"docker","slug":"网络/docker","date":"2022-01-22T16:00:00.000Z","updated":"2022-01-23T07:02:29.800Z","comments":true,"path":"2022/01/23/网络/docker/","link":"","permalink":"http://example.com/2022/01/23/%E7%BD%91%E7%BB%9C/docker/","excerpt":"","text":"docke常用命令： 命令 意义 docker pull &lt;镜像名称&gt; 获取镜像 docker run -it &lt;镜像名称&gt; /bin/bash 启动容器 exit 退出终端 docker ps -a 查看所有的容器 docker rm -f &lt;容器id&gt; 删除容器 docker start docker start b750bbbcfd88 docker run -itd –name ubuntu-test ubuntu /bin/bash 后台运行 docker stop &lt;容器 ID&gt; 停止一个容器 docker restart &lt;容器 ID&gt; 重启一个容器 docker attach &lt;容器 ID&gt; 退出容器（会停止） docker exec -it &lt;容器 ID&gt; /bin/bash 进入出容器（不会停止） exit 退出容器 docker export &lt;容器 ID&gt; &gt; &lt;容器名称&gt;.tar 导出容器 cat docker/ubuntu.tar docker import - test/ubuntu:v1 docker import http://example.com/exampleimage.tgz example/imagerepo 通过地址导入 docker port &lt;容器id或者名称&gt; 查看容器端口的映射情况 docker logs -f bf08b7f2cd89 docker logs [ID或者名字] 可以查看容器内部的标准输出 docker top &lt;容器名称&gt; 查看容器内部运行的进程 docker search httpd 查找镜像 docker rmi hello-world 删除镜像 docker images 查看当前的镜像列表 docker network create &lt;名称&gt; 创建一个网络 docker network ls 查看网络 docker network rm &lt;名称&gt; 断开和移除网络 docker network inspect &lt;名称&gt; 查看网络信息 docker cp /www/runoob 96f7f14e99ab:/www/ 将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下 使用nginx江橙的笔记： 首先在你的服务器上面创建一个工作目录 例如以下创建的是目录为 dockerDatasystemctl start docker //启动dockersystemctl enable docker //设置为开机启动docker version 验证安装是否成功(有client和service两部分表示docker安装启动都成功了docker network create my_net 创建一个网络 docker工作区和宿主机目录挂载了之后，修改的文件会进行同步，一般来说只需要修改宿主机的文件就行了，不需要修改工作区修改宿主机的文件需要重启容器才会同步过去，修改工作区(容器)会立即同步到宿主机里面删除容器不会删除宿主机的挂载目录的数据 1、拉取镜像 去dockerhub拉取合适的版本即可 docker pull nginx:1.20.1-alpine2、创建配置目录和项目目录 -v /dockerData/nginx:/etc/nginx 3、跑不带映射的容器 docker run -itd –name nginx 7f18bdc92ca5(镜像id)4、docker cp nginx:/etc/nginx/ /dockerData/nginx/ | docker exec -it nginx sh(目录为容器的目录)5、删除容器 docker rm -f ngxin(指的是容器名) 因为删除容器是不会删除宿主机的文件的，但是更新容器里面的挂载目录文件时，会更新宿主机文件，更新宿主机文件也会更新容器文件(需重启容器) # &#x2F;dockerData&#x2F;nginx&#x2F;www:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \\ 挂载目录地址 # &#x2F;dockerData&#x2F;nginx:&#x2F;etc&#x2F;nginx \\ 挂载nginx配置地址 # &#x2F;dockerData&#x2F;nginx&#x2F;log:var&#x2F;log&#x2F;nginx \\ 挂载log日志地址 docker run -itd --name nginx -p 80:80 -p 443:443 \\ -v &#x2F;dockerData&#x2F;nginx&#x2F;www:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \\ -v &#x2F;dockerData&#x2F;nginx:&#x2F;etc&#x2F;nginx \\ -v &#x2F;dockerData&#x2F;nginx&#x2F;log:&#x2F;var&#x2F;log&#x2F;nginx \\ --network my_net --network-alias nginx 7f18bdc92ca5 配置nginx以后需要重新启动docker stop nginx","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"}]},{"title":"nginx学习","slug":"网络/服务器-nginx","date":"2022-01-20T16:00:00.000Z","updated":"2022-01-21T09:56:34.989Z","comments":true,"path":"2022/01/21/网络/服务器-nginx/","link":"","permalink":"http://example.com/2022/01/21/%E7%BD%91%E7%BB%9C/%E6%9C%8D%E5%8A%A1%E5%99%A8-nginx/","excerpt":"","text":"主要配置 conf更改配置以后需要重启 docker restart nginx server &#123; // 根据你的需求改变此端口 listen 80; //也可以是1.2.3.4:80的形式 // 多个主机名可以用空格隔开，当然这个信息也是需要按照你的需求而改变的。 server_name star.yourdomain.com *.yourdomain.com www.*.yourdomain.com; //或者可以使用：_ * (具体内容参见本维基其他页面) root /PATH/TO/WEBROOT/$host; alias error_page 404 // http://yourdomain.com/errors/404.html; access_log logs/star.yourdomain.com.access.log; location / &#123; root /PATH/TO/WEBROOT/$host/; // 项目的存放地址 index index.html; // 打开的根目录 &#125; // 直接支持静态文件 (从配置上看来不是直接支持啊) location ~* ^.+.(jpg|jpeg|gif|css|png|js|ico|html)$ &#123; access_log off; expires 30d; &#125; location ~ .php$ &#123; // 如果需要，你可以为不同的FCGI进程设置不同的服务信息 fastcgi_pass 127.0.0.1:YOURFCGIPORTHERE; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /PATH/TO/WEBROOT/$host/$fastcgi_script_name; fastcgi_param QUERY_STRING $query_string; fastcgi_param REQUEST_METHOD $request_method; fastcgi_param CONTENT_TYPE $content_type; fastcgi_param CONTENT_LENGTH $content_length; fastcgi_intercept_errors on; &#125; location ~ /\\.ht &#123; deny all; &#125; &#125;","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"extends和implements区别","slug":"js/extends和implements区别","date":"2022-01-09T16:00:00.000Z","updated":"2022-01-10T08:27:01.574Z","comments":true,"path":"2022/01/10/js/extends和implements区别/","link":"","permalink":"http://example.com/2022/01/10/js/extends%E5%92%8Cimplements%E5%8C%BA%E5%88%AB/","excerpt":"","text":"extends与implements的不同 在类的声明中，通过关键字extends来创建一个类的子类。一个类通过关键字implements声明自己使用一个或者多个接口。extends 是继承某个类, 继承之后可以使用父类的方法, 也可以重写父类的方法;implements 是实现多个接口, 接口的方法一般为空的, 必须重写才能使用 extends是继承父类，只要那个类不是声明为final或者那个类定义为abstract的就能继承Java中不支持多重继承，但是可以用接口 来实现，这样就要用到implements，继承只能继承一个类，但implements可以实现多个接口，用逗号分开就行了 比如 ：class A extends B implements C,D,E接口实现的注意点： 实现一个接口就是要实现该接口的所有的方法(抽象类除外)。 接口中的方法都是抽象的。 多个无关的类可以实现同一个接口，一个类可以实现多个无关的接口。","categories":[],"tags":[]},{"title":"vue3的使用方式","slug":"vue3/vue3使用","date":"2022-01-05T16:00:00.000Z","updated":"2022-01-06T09:44:06.311Z","comments":true,"path":"2022/01/06/vue3/vue3使用/","link":"","permalink":"http://example.com/2022/01/06/vue3/vue3%E4%BD%BF%E7%94%A8/","excerpt":"","text":"vue3的使用方式 基本使用&lt;template> &lt;div class=\"home\"> &lt;!-- 父子组件传值 --> &lt;son num=\"66\" name=\"trist\" :age=\"age\" @baba=\"getSon\">&lt;a>我是插槽&lt;/a>&lt;/son> &lt;/div> &lt;/template> &lt;script> import son from './son.vue'; import &#123; reactive, toRefs &#125; from 'vue'; import &#123; useRoute, useRouter &#125; from 'vue-router'; export default &#123; name: 'home', components: &#123; son &#125;, setup(props, ctx) &#123; // 获取当前路由信息 const route = useRoute(); // 全局路由的实例 const router = useRouter(); const state = reactive(&#123; name: 'trist', age: 22, sex: 'boy' &#125;); // 监听子组件事件 const getSon = val => &#123; console.log(val); &#125; return &#123; ...toRefs(state), getSon &#125;; &#125; &#125;; &lt;/script> ＜script setup＞语法糖&lt;template> &lt;div> &lt;div @click=\"log\">&#123;&#123; msg &#125;&#125;&lt;/div> &lt;MyComponent /> &lt;/div> &lt;/template> &lt;script setup> import MyComponent from './MyComponent.vue' import &#123; ref &#125; from 'vue'; // 变量 const msg = ref('Hello!');//响应式数据依然需要ref // 函数 function log() &#123; console.log(msg); &#125; // &lt;script setup> 中可以使用顶层 await。结果代码会被编译成async setup() const post = await fetch(`/api/post/1`).then(r => r.json()) &lt;/script> 类组件跟react的类组件相似可以跟装饰器一起使用 &lt;template> &lt;div class=\"hello\"> &lt;h1>&#123;&#123; msg &#125;&#125;&lt;/h1> &lt;h2 @click=\"(event) => setData('1', event)\">&#123;&#123; flag &#125;&#125;&lt;/h2> &lt;h2>initVar:&#123;&#123; initVar &#125;&#125;&lt;/h2> &lt;/div> &lt;/template> ... &lt;script lang=\"ts\"> import &#123; Options, Vue &#125; from \"vue-class-component\"; @Options(&#123; props: &#123; msg: String, &#125;, data() &#123; return &#123; flag: \"这是一个欢迎组件\", initVar: 1, &#125;; &#125;, &#125;) export default class HelloWorld extends Vue &#123; msg!: string; flag!: string; initVar!: number; public mounted(): void &#123; console.log(this.initVar); &#125; setData(value: string, event: PointerEvent): boolean &#123; console.log(event); this.initVar = 1 + 1; this.flag = this.flag + value; return false; &#125; &#125; &lt;/script>","categories":[],"tags":[{"name":"vue3","slug":"vue3","permalink":"http://example.com/tags/vue3/"}]},{"title":"vue3学习","slug":"vue3/vue2进阶vue3","date":"2022-01-04T16:00:00.000Z","updated":"2022-01-06T02:19:57.533Z","comments":true,"path":"2022/01/05/vue3/vue2进阶vue3/","link":"","permalink":"http://example.com/2022/01/05/vue3/vue2%E8%BF%9B%E9%98%B6vue3/","excerpt":"","text":"Vue3与Vue2在应用中的区别 响应式数据在Vue3中变得更加灵活和友善。Vue2中 data 里没有定义的属性在后续无法正常的进行响应操作，必须通过 Vue.set 这个 API 向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property (比如 this.myObject.newProperty = ‘hi’); 然而在 Vue3 中我们可以通过引入 ref 来操作响应值。ref 是一个实例方法，接受一个内部值并返回一个响应式且可变的 ref 对象。ref 对象具有指向内部值的单个 property.value。const count = ref(0) console.log(count.value) // 0 count.value++ console.log(count.value) // 1 Vue3 采用了 ES6的一项新特性：Proxy 来实现Vue3中数据响应式的设计。通过下面的伪代码我们可以对比一下：Object.definProperty(data,'count',&#123; get()&#123;&#125;, set()&#123;&#125; &#125;) new Proxy(data,'count',&#123; get(key)&#123;&#125;, set(key,value)&#123;&#125; &#125;) Object.defineProperty 要修改 data 中的属性必须要明确的知道 key 值（count）, Proxy 在使用中是读取或者设置data中任意的 key，所以不管是修改已有的属性还是新增属性，都可以实现响应式的要求。 vue3使用 关于生命周期钩子函数 vue2 vue3 beforeCreate() use setup() created() use setup() beforeMount() onBeforeMount mounted() onMounted beforeUpdate() onBeforeUpdate updated() onUpdated beforeDestory() onBeforeUnmount destoryed() onUnmounted activated() onActivated deactivated() onDeactivated errorCaptured() onErrorCaptured onRenderTracked(新增) — DebuggerEvent 调试用 onRenderTriggered(新增) — DebuggerEvent 调试用 Vue3中的钩子函数都在 setup() 中调用。 computed，watch 可直接调用 const count = ref(0) const double = computed(() => &#123; return count.value * 2 &#125;) watch 接收两个参数，第一个参数是监听的属性，多个属性可传入数组， 第二个参数是一个回调函数，回调函数有两个参数（newVal, oldVal）；当 watch 的第一个参数是一个数组时，newVal 与 oldVal 对应的也是数组形式，一一对应。 // 监听count watch('count', (newVal, oldVal) => &#123; console.log('newVal:', newVal) console.log('oldVal:', oldVal) &#125;) // 监听多个属性值 watch(['count', 'name'], (newVal, oldVal) => &#123; console.log('newVal:', newVal) // 数组 console.log('oldVal:', oldVal) // 数组 &#125;) 如果是需要监听定义在 reacitive 对象中的单一属性，需要通过函数返回值来进行监听。 watch(() => data.count, (newVal, oldVal) => &#123; console.log('newVal:', newVal) console.log('oldVal:', oldVal) &#125;) Option API 与 Composition API vue 2.x 使用的是Option API 构建组件。一个组件的功能需要通过methods，computed，watch，data等属性和方法，共同处理页面逻辑。存在多个业务功能共同使用一个实例化new vue()这种构建方式在业务逻辑复杂的大项目中，API比较分散，可能会存在分不清哪个方法对应哪个功能。项目的易读性、可复用性相对较差，耦合性较高。 vue 3.x 使用的是Composition API 构建组件。代码是根据逻辑功能来组织的，一个功能所定义的所有api会放在一起 （高内聚，低耦合），我们能快速的定位到这个功能所用到的所有API，提高代码可读性和可维护性 setup函数是使用Composition API的入口 在创建组件实例时，在初始组件解析之后调用setup。在生命周期方面，它在beforeCreate钩子之前调用； 可以返回一个对象，这个对象的属性被合并到渲染上下文，并可以在模板中直接使用 可以返回一个渲染函数，如下： return () =&gt; h(‘div’, [count.value, object.foo]) 接收props对象作为第一个参数，接收来的props对象，props对象是响应式的(reactive), 当传入的新的props对象时会对其进行更新，且可以通过watchEffect或watch监视其变化。props对象不支持解构,解构会导致失去响应性： export default &#123; props: &#123; name: String &#125;, setup(&#123; name &#125;) &#123; watchEffect(() => &#123; console.log(`name is: ` + name) // Will not be reactive! &#125;) &#125; &#125; 接受context对象作为第二个参数，这个对象包含attrs（属性），slots（作用域插槽），emit（事件传播函数）三个属性。（还有expose 函数，实际为4个属性， 可以通过expose 向父级暴露一些子组件的函数、属性等，父组件可以通过ref直接获取到）与 prop 不同，context 是普通对象，不是响应式的，slots 和 attr 的值会在组件更新时而更新，如果需要监听 slots 、‘attr’ 的更新触发的副作用，建议在 setup() 函数中添加 onUpdated 函数监听副作用 // comp-a.vue &#123; name: 'comp-a', setup(props, &#123; attrs, slots, emit, expose &#125;) &#123; const observed = reactive(&#123; a: 1 &#125;) function setObservedA(value) &#123; observed.a = value &#125; expose(&#123; setObservedA &#125;) return &#123; observed, &#125; &#125; &#125; // comp-b.vue &#123; template: ` &lt;comp-a ref=\"compa\" /> `, setup() &#123; const compa = ref(null) onMounted(() => &#123; // comp-a 调用 expose 之后, 父组件 ref 拿到的结果为调用 expose 时的参数。而不再是组件实例了 compa.value.setObservedA(2) &#125;) return &#123; compa &#125; &#125; &#125; setup() 中的 this 不是当前组件实例，实际打印发现为 undefined ， 不建议 setup() 与 Option API 混用，可能会造成混乱。 vue3 中的h函数 h函数就是vue中的createElement方法，这个函数作用就是创建虚拟dom对象，通过diff算法，追踪dom变化的 createElement函数，它返回的实际上不是一个DOM元素，更准确的名字是：createNodeDescription（直译为——创建节点描述），因为它所包含的信息会告诉vue页面上需要渲染什么样的节点，包括其子节点的描述信息。我们把这样的节点叫做：“虚拟节点（virtual node）”，也常简写为：“VNode” h函数接受三个参数：参数一：tag（标签名）、组件的选项对象、函数（必选）；参数二：一个对象，标签的属性对应的数据，如：class、id、disabled 等等（可选）；参数三：子级虚拟节点，字符串形式或数组形式，子级虚拟节点也需要使用createElement构建。 dom节点 bable编译前后对比： Vue3.0 toRaw函数和markRaw函数 toRaw方法是把被reactive或readonly后的Proxy对象转换为原来的target对象，而markRaw则直接让target不能被reactive或readonly","categories":[],"tags":[{"name":"vue3","slug":"vue3","permalink":"http://example.com/tags/vue3/"}]},{"title":"git相关操作","slug":"其他/git-相关操作","date":"2021-12-29T16:00:00.000Z","updated":"2022-04-08T01:26:52.808Z","comments":true,"path":"2021/12/30/其他/git-相关操作/","link":"","permalink":"http://example.com/2021/12/30/%E5%85%B6%E4%BB%96/git-%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/","excerpt":"","text":"git commit 代码提交规范type(scope) : subject type（必须） : commit 的类别，只允许使用下面几个标识： feat : 新功能 fix : 修复bug docs : 文档改变 style : 代码格式改变 refactor : 某个已有功能重构 perf : 性能优化 test : 增加测试 build : 改变了build工具 如 grunt换成了 npm revert : 撤销上一次的 commit chore : 构建过程或辅助工具的变动 scope（可选） : 用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。 subject（必须） : commit 的简短描述，不超过50个字符。 使用commitizen 规范提交 npm install -g commitizen commitizen init cz-conventional-changelog –save –save-exact 用 git cz 命令取代 git commit 使用git commit 提交 npm i @commitlint/config-conventional @commitlint/cli -D // 配置 package.json \"commitlint\": &#123; \"extends\": [ \"@commitlint/config-conventional\" ] &#125; // 或者在项目根目录下创建配置文件： .commitlintrc.js module.exports = &#123; extends: ['@commitlint/config-conventional'] &#125; 安装Husky npm i husky -D 配置 package.json\"husky\": &#123; \"hooks\": &#123; \"commit-msg\": \"commitlint -e $HUSKY_GIT_PARAMS\" &#125; &#125; // 或者在项目根目录下创建配置文件：.huskyrc &#123; \"hooks\": &#123; \"commit-msg\": \"commitlint -e $HUSKY_GIT_PARAMS\" &#125; &#125; npx husky install npx husky add .husky/commit-msg ‘npx –no-install commitlint –edit “$1”‘ git分支相关报错 指定pull命令的更新方式git config pull.rebase false # 默认策略 git config pull.rebase true git config pull.ff only","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"ts学习","slug":"TS/TS学习","date":"2021-12-28T16:00:00.000Z","updated":"2022-01-21T05:28:32.666Z","comments":true,"path":"2021/12/29/TS/TS学习/","link":"","permalink":"http://example.com/2021/12/29/TS/TS%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"基础类型 布尔值let isDone:boolean = false 数字let decLiteral: number = 6; let hexLiteral: number = 0xf00d; let binaryLiteral: number = 0b1010; let octalLiteral: number = 0o744; 字符串let name: string = \"bob\"; name = \"smith\"; 数组let list: number[] = [1, 2, 3]; // 泛型 let list: Array&lt;number> = [1, 2, 3]; 元组 Tuplelet x: [string, number]; x = ['hello', 10]; // OK x = [10, 'hello']; // Error 枚举enum Color &#123;Red, Green, Blue&#125; let c: Color = Color.Green; Any （随便什么类型都可以）let notSure: any = 4; notSure = Void 没有任何类型只能为它赋予undefined和nullfunction warnUser(): void &#123; console.log(\"This is my warning message\"); &#125; let unusable: void = undefined; TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似，它们的本身的类型用处不是很大：let u: undefined = undefined; let n: null = null; 默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。 接口关键字 interface? 是可选readonly 是只读 interface SquareConfig &#123; color?: string; width?: number; readonly name: string &#125; function createSquare(config: SquareConfig): &#123;color: string; area: number&#125; &#123; let newSquare = &#123;color: \"white\", area: 100&#125;; if (config.color) &#123; newSquare.color = config.color; &#125; if (config.width) &#123; newSquare.area = config.width * config.width; &#125; return newSquare; &#125; let mySquare = createSquare(&#123;color: \"black\"&#125;); 你可以通过赋值一个对象字面量来构造一个Point。 赋值后， x和y再也不能被改变了。 let p1: Point = &#123; x: 10, y: 20 &#125;; p1.x = 5; // error! 函数类型 interface SearchFunc &#123; (source: string, subString: string): boolean; &#125; let mySearch: SearchFunc; mySearch = function(source: string, subString: string) &#123; let result = source.search(subString); return result > -1; &#125; // 对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配 let mySearch: SearchFunc; mySearch = function(src, sub) &#123; let result = src.search(sub); return result > -1; &#125; 可索引的类型 interface StringArray &#123; [index: number]: string; &#125; let myArray: StringArray; myArray = [\"Bob\", \"Fred\"]; let myStr: string = myArray[0]; 类类型 interface ClockInterface &#123; currentTime: Date; setTime(d: Date); &#125; class Clock implements ClockInterface &#123; currentTime: Date; setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123; &#125; &#125; 类class Greeter &#123; greeting: string; constructor(message: string) &#123; this.greeting = message; &#125; greet() &#123; return \"Hello, \" + this.greeting; &#125; &#125; let greeter = new Greeter(\"world\"); 继承 class Animal &#123; name: string; constructor(theName: string) &#123; this.name = theName; &#125; move(distanceInMeters: number = 0) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`); &#125; &#125; class Snake extends Animal &#123; constructor(name: string) &#123; super(name); &#125; move(distanceInMeters = 5) &#123; console.log(\"Slithering...\"); super.move(distanceInMeters); &#125; &#125; class Horse extends Animal &#123; constructor(name: string) &#123; super(name); &#125; move(distanceInMeters = 45) &#123; console.log(\"Galloping...\"); super.move(distanceInMeters); &#125; &#125; let sam = new Snake(\"Sammy the Python\"); let tom: Animal = new Horse(\"Tommy the Palomino\"); sam.move(); tom.move(34); 派生类包含了一个构造函数，它 必须调用 super()，它会执行基类的构造函数。 而且，在构造函数里访问 this的属性之前，我们 一定要调用 super()。 这个是TypeScript强制执行的一条重要规则。 公共，私有与受保护的修饰符 // 在TypeScript里，成员都默认为 public。 class Animal &#123; public name: string; public constructor(theName: string) &#123; this.name = theName; &#125; public move(distanceInMeters: number) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`); &#125; &#125; // 当成员被标记成 private时，它就不能在声明它的类的外部访问 class Animal &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125; &#125; new Animal(\"Cat\").name; // 错误: 'name' 是私有的. // protected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问。 class Person &#123; protected name: string; constructor(name: string) &#123; this.name = name; &#125; &#125; class Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name) this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125; &#125; let howard = new Employee(\"Howard\", \"Sales\"); console.log(howard.getElevatorPitch()); console.log(howard.name); // 错误 函数函数和JavaScript一样，TypeScript函数可以创建有名字的函数和匿名函数。 你可以随意选择适合应用程序的方式，不论是定义一系列API函数还是只使用一次的函数。 // Named function function add(x, y) &#123; return x + y; &#125; // Anonymous function let myAdd = function(x, y) &#123; return x + y; &#125;; // 使用ts function add(x: number, y: number): number &#123; return x + y; &#125; let myAdd = function(x: number, y: number): number &#123; return x + y; &#125;; 我们可以给每个参数添加类型之后再为函数本身添加返回值类型。 TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它。 书写完整函数类型let myAdd: (x: number, y: number) => number = function(x: number, y: number): number &#123; return x + y; &#125;; // 编译后 var myAdd = function (x, y) &#123; return x + y; &#125;; 只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。 对于返回值，我们在函数和返回值类型之前使用( =&gt;)符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为 void而不能留空。 可选参数和默认参数TypeScript里的每个函数参数都是必须的。 这不是指不能传递 null或undefined作为参数，而是说编译器检查用户是否为每个参数都传入了值。 编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。在TypeScript里我们可以在参数名旁使用 ?实现可选参数的功能。 比如，我们想让last name是可选的： function buildName(firstName: string, lastName?: string) &#123; if (lastName) return firstName + \" \" + lastName; else return firstName; &#125; 当没有传递参数的时候也可以直接设置默认值 function buildName(firstName: string, lastName = \"Smith\") &#123; return firstName + \" \" + lastName; &#125; 剩余参数默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在JavaScript里，你可以使用 arguments来访问所有传入的参数。在TypeScript里，你可以把所有参数收集到一个变量里： function buildName(firstName: string, ...restOfName: string[]) &#123; return firstName + \" \" + restOfName.join(\" \"); &#125; let employeeName = buildName(\"Joseph\", \"Samuel\", \"Lucas\", \"MacKinzie\"); // 这个省略号也会在带有剩余参数的函数类型定义上使用到： function buildName(firstName: string, ...restOfName: string[]) &#123; return firstName + \" \" + restOfName.join(\" \"); &#125; let buildNameFun: (fname: string, ...rest: string[]) => string = buildName; this和箭头函数JavaScript里，this的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。 但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。 let deck = &#123; suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"], cards: Array(52), createCardPicker: function() &#123; return function() &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;; &#125; &#125; &#125; let cardPicker = deck.createCardPicker(); let pickedCard = cardPicker(); alert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit); 可以看到createCardPicker是个函数，并且它又返回了一个函数。 如果我们尝试运行这个程序，会发现它并没有弹出对话框而是报错了。 因为 createCardPicker返回的函数里的this被设置成了window而不是deck对象。 因为我们只是独立的调用了 cardPicker()。 顶级的非方法式调用会将 this视为window。 （注意：在严格模式下， this为undefined而不是window） 为了解决这个问题，我们可以在函数被返回时就绑好正确的this。 这样的话，无论之后怎么使用它，都会引用绑定的‘deck’对象。 我们需要改变函数表达式来使用ECMAScript 6箭头语法。 箭头函数能保存函数创建时的 this值，而不是调用时的值： let deck = &#123; suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"], cards: Array(52), createCardPicker: function() &#123; // NOTE: the line below is now an arrow function, allowing us to capture 'this' right here return () => &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;; &#125; &#125; &#125; let cardPicker = deck.createCardPicker(); let pickedCard = cardPicker(); alert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit); 更好事情是，TypeScript会警告你犯了一个错误，如果你给编译器设置了–noImplicitThis标记。 它会指出 this.suits[pickedSuit]里的this的类型为any。 让我们往例子里添加一些接口，Card 和 Deck，让类型重用能够变得清晰简单些： interface Card &#123; suit: string; card: number; &#125; interface Deck &#123; suits: string[]; cards: number[]; createCardPicker(this: Deck): () => Card; &#125; let deck: Deck = &#123; suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"], cards: Array(52), // NOTE: The function now explicitly specifies that its callee must be of type Deck createCardPicker: function(this: Deck) &#123; return () => &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;; &#125; &#125; &#125; let cardPicker = deck.createCardPicker(); let pickedCard = cardPicker(); alert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit); 剩下的有点看不懂了 后面实际项目中使用到了再补充。。。 泛型我们需要一种方法使返回值的类型与传入参数的类型是相同的。 这里，我们使用了 类型变量，它是一种特殊的变量，只用于表示类型而不是值。 function identity&lt;T>(arg: T): T &#123; return arg; &#125; 我们给identity添加了类型变量T。 T帮助我们捕获用户传入的类型（比如：number），之后我们就可以使用这个类型。 之后我们再次使用了 T当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。 这允许我们跟踪函数里使用的类型的信息。 也就是说用户传的参数是类型的 T 就表示什么类型 我们把这个版本的identity函数叫做泛型，因为它可以适用于多个类型。 不同于使用 any，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。 我们定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数： let output = identity&lt;string>(\"myString\"); // type of output will be 'string' 第二种方法更普遍。利用了类型推论 – 即编译器会根据传入的参数自动地帮助我们确定T的类型： let output = identity(\"myString\"); // type of output will be 'string' 注意我们没必要使用尖括号（&lt;&gt;）来明确地传入类型；编译器可以查看myString的值，然后把T设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入T的类型，在一些复杂的情况下，这是可能出现的。 如果我们想同时打印出arg的长度。 我们很可能会这样做： function loggingIdentity&lt;T>(arg: T): T &#123; console.log(arg.length); // 因为传入的参数是任意类型的 如果是数字则没有.length 所以会报错 Error: T doesn't have .length return arg; &#125; 现在假设我们想操作T类型的数组而不直接是T。由于我们操作的是数组，所以.length属性是应该存在的。 我们可以像创建其它数组一样创建这个数组： function loggingIdentity&lt;T>(arg: T[]): T[] &#123; console.log(arg.length); // Array has a .length, so no more error 这样我们操作的是一个T类型的数组 所以不会报错 return arg; &#125; function loggingIdentity&lt;T>(arg: Array&lt;T>): Array&lt;T> &#123; console.log(arg.length); return arg; &#125; 泛型类型泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样： function identity&lt;T>(arg: T): T &#123; return arg; &#125; let myIdentity: &lt;T>(arg: T) => T = identity; 我们还可以使用带有调用签名的对象字面量来定义泛型函数： function identity&lt;T>(arg: T): T &#123; return arg; &#125; let myIdentity: &#123;&lt;T>(arg: T): T&#125; = identity; 这引导我们去写第一个泛型接口了。 泛型接口我们把上面例子里的对象字面量拿出来做为一个接口： interface GenericIdentityFn &#123; &lt;T>(arg: T): T; &#125; function identity&lt;T>(arg: T): T &#123; return arg; &#125; let myIdentity: GenericIdentityFn = identity; 一个相似的例子，我们可能想把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型（比如： Dictionary而不只是Dictionary）。 这样接口里的其它成员也能知道这个参数的类型了。 interface GenericIdentityFn&lt;T> &#123; (arg: T): T; &#125; function identity&lt;T>(arg: T): T &#123; return arg; &#125; let myIdentity: GenericIdentityFn&lt;number> = identity; 注意，我们的示例做了少许改动。 不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。 当我们使用 GenericIdentityFn的时候，还得传入一个类型参数来指定泛型类型（这里是：number），锁定了之后代码里使用的类型。 对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的。 泛型类泛型类看上去与泛型接口差不多。 泛型类使用（ &lt;&gt;）括起泛型类型，跟在类名后面。 class GenericNumber&lt;T> &#123; zeroValue: T; add: (x: T, y: T) => T; &#125; let myGenericNumber = new GenericNumber&lt;number>(); myGenericNumber.zeroValue = 0; myGenericNumber.add = function(x, y) &#123; return x + y; &#125;; // GenericNumber类的使用是十分直观的，没有什么去限制它只能使用number类型。 也可以使用字符串或其它更复杂的类型。 let stringNumeric = new GenericNumber&lt;string>(); stringNumeric.zeroValue = \"\"; stringNumeric.add = function(x, y) &#123; return x + y; &#125;; console.log(stringNumeric.add(stringNumeric.zeroValue, \"test\")); 与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。 我们在类那节说过，类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。 泛型约束定义一个接口来描述约束条件。 创建一个包含 .length属性的接口，使用这个接口和extends关键字来实现约束： interface Lengthwise &#123; length: number; &#125; function loggingIdentity&lt;T extends Lengthwise>(arg: T): T &#123; console.log(arg.length); // 现在我们知道它有一个。属性，因此不再有错误 return arg; &#125; 现在这个泛型函数被定义了约束，因此它不再是适用于任意类型： loggingIdentity(3); // Error, number doesn't have a .length property loggingIdentity(&#123;length: 10, value: 3&#125;); // 我们需要传入符合约束类型的值，必须包含必须的属性 在泛型约束中使用类型参数你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象 obj上，因此我们需要在这两个类型之间使用约束。 function getProperty(obj: T, key: K) &#123; return obj[key]; &#125; let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;; getProperty(x, \"a\"); // okay getProperty(x, \"m\"); // error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'. 错误：“m”类型的参数不能赋值给“a”|“b”|“c”|“d”。","categories":[],"tags":[{"name":"ts","slug":"ts","permalink":"http://example.com/tags/ts/"}]},{"title":"react学习","slug":"react/react学习","date":"2021-12-19T16:00:00.000Z","updated":"2022-01-05T01:35:34.612Z","comments":true,"path":"2021/12/20/react/react学习/","link":"","permalink":"http://example.com/2021/12/20/react/react%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"挂在方式ReactDOM.render( element, document.getElementById('app') ); 通过ReactDOM.render() 挂载， 第一个参数是组件，第二个参数是挂载的根节点，需要通过原生js获取，通常只会挂载一次 组件使用函数试组件 function Welcome(props) &#123; return &lt;h1>Hello, &#123;props.name&#125;&lt;/h1>; &#125; 函数式组件没有this,可以接收一个props 如果函数组件想使用state,得使用hook {useState} import React, &#123; useState, useEffect &#125; from 'react'; function Example() &#123; const [count, setCount] = useState(0); // count定义的变量，setCount改变变量的方法，useState(0)设置变量初始值为0 // 相当于 componentDidMount 和 componentDidUpdate: useEffect(() => &#123; // 使用浏览器的 API 更新页面标题 document.title = `You clicked $&#123;count&#125; times`; &#125;); return ( &lt;div> &lt;p>You clicked &#123;count&#125; times&lt;/p> &lt;button onClick=&#123;() => setCount(count + 1)&#125;> Click me &lt;/button> &lt;/div> ); &#125; 类组件import React from \"react\"; import PropsType from \"prop-types\"; class Welcome extends React.Component &#123; // constructor(props)&#123; // super(props) // this.state = &#123; // age: 18 // &#125; // this.onChang = this.onChang.bind(this) // &#125; static propTypes = React.PropsTypes(&#123; // 数据类型为字符串并且必须填 name: PropsType.string.isRequired // 为函数类型 fun: PropsType.func &#125;) static defaultProps = &#123; name:'lisi' &#125; state = &#123; age: 18 &#125; onChang = () => &#123; const &#123;age&#125; = this.state this.setState(&#123; age: age + 1 &#125;) console.log('点击事件') &#125; render() &#123; return &lt;h1 onClick=&#123;this.onChang&#125;>Hello, &#123;this.props.name&#125;&#123;this.state.age&#125;&lt;/h1>; &#125; &#125; 类组件中的state与事件定义的方式有两种一种是在constructor里面定义，需要通过bind将事件的this改变为类的this,这种定义方式每次写一个事件就需要重新绑定一次,会比较麻烦，但是比较容易理解否则事件获取不到this,因为 1、类会自己开启严格模式 2、babel也会开启严格模式二种是在定义事件的时候使用赋值的方式，我们直接赋值一个箭头函数 给这个事件（因为箭头函数没有自己的this，它会将外层的this作为自己的this) 设置组件的接收的参数需要引入propTypes, 设置属性需要使用静态属性要不在类的外面设置，要是在类里面设置需要加static 改变state里面的数据需要使用this.setState() 方法 子组件给父组件传递参数，父组件给子组件传递一个方法，然后子组件在方法里面传入参数，父组件可以把参数存进state ref class Com extends React.Component &#123; changInput = () => &#123; const &#123;input,input2&#125; = this.refs console.log(input,input2) &#125; input2 = React.createRef() render()&#123; return ( &lt;> &lt;input ref=&#123;c => this.input = c&#125; type=\"text\" /> &lt;input ref=&#123;this.input2&#125; type=\"text\" /> &lt;/> ) &#125; &#125;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"}]},{"title":"前端自检清单","slug":"其他/前端自检清单","date":"2021-11-24T16:00:00.000Z","updated":"2023-04-04T08:28:46.007Z","comments":true,"path":"2021/11/25/其他/前端自检清单/","link":"","permalink":"http://example.com/2021/11/25/%E5%85%B6%E4%BB%96/%E5%89%8D%E7%AB%AF%E8%87%AA%E6%A3%80%E6%B8%85%E5%8D%95/","excerpt":"","text":"JavaScript基础变量和类型 JavaScript规定了几种语言类型数据类型篇有讲到Post not found: js-数据类型 JavaScript目前有八种内置类型：Number，String，Boolean，Null，Undefined，Object，Symbol，BigInt 其中 Symbol是es6新加入的 BigInt 是一种内置对象，它提供了一种方法来表示大于 2^53 - 1 的整数。这原本是 Javascript中可以用 Number 表示的最大数字。BigInt 可以表示任意大的整数。可以用在一个整数字面量后面加 n 的方式定义一个 BigInt ，如：10n，或者调用函数BigInt()。 const theBiggestInt = 9007199254740991n; const alsoHuge = BigInt(9007199254740991);// ↪ 9007199254740991n const hugeString = BigInt(\"9007199254740991\");// ↪ 9007199254740991n const hugeHex = BigInt(\"0x1fffffffffffff\");// ↪ 9007199254740991n const hugeBin = BigInt(\"0b11111111111111111111111111111111111111111111111111111\"); // ↪ 9007199254740991n JavaScript对象的底层数据结构是什么 Post not found: 底层存储方式 JavaScript使用的是 堆(Heap) 和 栈( Stack) JavaScript基本类型数据都是直接按值存储在栈中的(Undefined、Null、不是new出来的布尔、数字和字符串)，每种类型的数据占用的内存空间的大小是确定的，并由系统自动分配和自动释放。这样带来的好处就是，内存可以及时得到回收，相对于堆来说 ，更加容易管理内存空间。 JavaScript引用类型数据被存储于堆中 (如对象、数组、函数等，它们是通过拷贝和new出来的）。其实，说存储于堆中，也不太准确，因为，引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据。 Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol Symbol是一种基本类型，由Symbol函数生成var a = Symbol() var b = Symbol() a === b // false 不能new，会报错，返回一个值，不是对象 Symbol 函数可以接受一个字符串作为参数 Symbol 值可以作为标识符，用于对象的属性名，可以保证不会出现同名的属性。 JavaScript中的变量在内存中的具体存储形式 let a = '1' // a存在栈内存中，‘1’也是在栈内存中 let b = &#123;b:'1'&#125; // b 存在栈内存中，&#123;b:'1'&#125;存在堆内存中，在栈内b的值是&#123;b:'1'&#125;的地址 let c = b // 其实是&#123;b:'1'&#125;存在堆内存中地址赋值给了c,也就是说在堆内存中他们是一个同一个&#123;b:'1'&#125; let d = a // 会直接在栈内存中重新创建一个‘1’给d,因为a的值是基本数据类型 栈内存 堆内存 存储基础数据类型 存储引用数据类型 按值访问 按引用访问 储存的值大小固定 储存的值大小不固定，可以动态调整 由系统自动分配内存空间 由代码进行指定分配 空间小运用效率高 空间大运用效率较低 先进后出，后进先出 无序储存，根据引用地址直接获取 基本类型对应的内置对象，以及他们之间的装箱拆箱操作 内置对象Object是 JavaScript 中所有对象的父对象 数据封装类对象：Object、Array、Boolean、Number 和 String 其他对象：Function、Math、Date、RegExp、Error。特殊的基本包装类型(String、Number、Boolean)arguments: 只存在于函数内部的一个类数组对象 装箱和拆箱 装箱：把基本数据类型转化为对应的引用数据类型的操作**，装箱分为隐式装箱和显示装箱 隐式装箱：let a = 'abc' let b = a.indexOf('a') // 0 // 上面的代码实现步骤为 let a = new String('abc') let b = a.indexOf('a') a = null 在上面的代码中，a是基本类型，它不是对象，不应该具有方法，js内部进行了一些列处理（装箱)， 使得它能够调用方法。在这个基本类型上调用方法，其实是在这个基本类型对象上调用方法。这个基本类型的对象是临时的，它只存在于方法调用那一行代码执行的瞬间，执行方法后立刻被销毁。实现机制：创建String类型的一个实例；在实例上调用指定的方法；销毁这个实例； 显示装箱let a = new String('abc') 拆箱：拆箱和装箱相反，就是把引用类型转化为基本类型的数据，通常通过引用类型的valueof()和toString（）方法实现let name = new String('name') typeof name // object name.toString() // 'name' name.valueOf() // 'name' 强制类型转换 var a = 100 + 10 //100 var b = 100 + '10' //10010 // == 运算符 100 == '100' //true 0 == '' //true null == undefined //true // 语句 var a = true if(a)&#123;&#125; var b = 100 if(b)&#123;&#125; // 把数字转换为true var c = '' if(c)&#123;&#125; // 把空字符串转换为false // 逻辑运算 console.log(10&amp;&amp;0); // 0 把10转换成true console.log('' || 'abc'); // 'abc' 把空字符串转换为false console.log(!window.abc); // window.abc是undefined 把非undefined转换成true //判断一个变量会被当做true还是false var a = 100 console.log(!!a); // true null和undefined的区别 1995年JavaScript诞生时，最初像Java一样，只设置了null作为表示”无”的值。但是，JavaScript的设计者Brendan Eich，觉得这样做还不够，有两个原因。首先，null像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich觉得表示”无”的值最好不是对象。其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果null自动转为0，很不容易发现错误。因此，Brendan Eich又设计了一个undefined。 相同点if(null || undefined ) // 在if判断中都会自动转化为 fasle undefined == null // 相等运算符甚至直接报告两者相等 不同点null表示”没有对象”，即该处不应该有值。 （1） 作为函数的参数，表示该函数的参数不是对象。 （2） 作为对象原型链的终点。undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义 （1）变量被声明了，但没有赋值时，就等于undefined。 （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 （3）对象没有赋值的属性，该属性的值为undefined。 （4）函数没有返回值时，默认返回undefined。 至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型 typeof 判断数据类型 但是引用数据类型无法具体判断 null无法直接判断 new操作符返回的都是object 函数返回的都是function instanceof运算符用于检测实例对象（参数）的原型链上是否出现构造函数的prototype语法：object instanceof constructor参数：object 某个实例对象 constructor 某个构造函数描述：instanceof运算符用来检测constructor.propertype 是否存在于参数object的原型链上。// 定义构造函数 function C() &#123; &#125; function D() &#123; &#125; var o = new C() console.log(o instanceof C) //true,因为Object.getPrototypeOf(0) === C.prototype console.log(o instanceof D) //false，D.prototype不在o的原型链上 console.log(o instanceof Object) //true 同上 C.prototype = &#123;&#125; var o2 = new C() console.log(o2 instanceof C) // true console.log(o instanceof C) // false C.prototype指向了一个空对象，这个空对象不在o的原型链上 D.prototype = new C() // 继承 var o3 = new D() console.log(o3 instanceof D) // true console.log(o3 instanceof C) // true C.prototype现在在o3的原型链上 instanceof运算符的左边必须是一个对象，像”string” instanceof String，true instanceof Boolean这样的字面量都会返回false。也就是说虽然能判断出对象的原型链上是否有构造函数的原型，但是只能判断出对象类型变量，字面量是判断不出的。 Object.prototype.toString()每个对象都有一个toString()方法，该对象被表示为一个文本字符串时，或一个对象以预期的字符串方式引用时自动调用。默认情况下，toString()方法被每个Object对象继承，如果此方法在自定义对象中未被覆盖，toString()返回“[object type]”，其中type是对象的类型// null undefined console.log(Object.prototype.toString.call(null)) //[object Null] 很给力 console.log(Object.prototype.toString.call(undefined)) //[object Undefined] 很给力 // Number console.log(Object.prototype.toString.call(Infinity)) //[object Number] console.log(Object.prototype.toString.call(Number.MAX_SAFE_INTEGER)) //[object Number] console.log(Object.prototype.toString.call(NaN)) //[object Number]，NaN一般是数字运算得到的结果，返回Number还算可以接受 console.log(Object.prototype.toString.call(1)) //[object Number] var n = 100 console.log(Object.prototype.toString.call(n)) //[object Number] console.log(Object.prototype.toString.call(0)) // [object Number] console.log(Object.prototype.toString.call(Number(1))) //[object Number] 很给力 console.log(Object.prototype.toString.call(new Number(1))) //[object Number] 很给力 console.log(Object.prototype.toString.call('1')) //[object String] console.log(Object.prototype.toString.call(new String('2'))) // [object String] // Boolean console.log(Object.prototype.toString.call(true)) // [object Boolean] console.log(Object.prototype.toString.call(new Boolean(1))) //[object Boolean] // Array console.log(Object.prototype.toString.call(new Array(1))) // [object Array] console.log(Object.prototype.toString.call([])) // [object Array] // Object console.log(Object.prototype.toString.call(new Object())) // [object Object] function foo() &#123;&#125; let a = new foo() console.log(Object.prototype.toString.call(a)) // [object Object] // Function console.log(Object.prototype.toString.call(Math.floor)) //[object Function] console.log(Object.prototype.toString.call(foo)) //[object Function] // Symbol console.log(Object.prototype.toString.call(Symbol('222'))) //[object Symbol] // RegExp console.log(Object.prototype.toString.call(/sss/)) //[object RegExp] 上面的结果，除了NaN返回Number稍微有点差池之外其他的都返回了意料之中的结果，都能满足实际开发的需求，于是我们可以写一个通用的函数来检测变量，字面量的类型。如下let Type = (function () &#123; let type = &#123;&#125;; let typeArr = ['String', 'Object', 'Number', 'Array', 'Undefined', 'Function', 'Null', 'Symbol', 'Boolean', 'RegExp', 'BigInt']; for (let i = 0; i &lt; typeArr.length; i++) &#123; (function (name) &#123; type['is' + name] = function (obj) &#123; return Object.prototype.toString.call(obj) === '[object ' + name + ']' &#125; &#125;)(typeArr[i]) &#125; return type &#125;)() let s = true console.log(Type.isBoolean(s)) // true console.log(Type.isRegExp(/22/)) // true JSON.stringify() 转成json也能根据开头结尾来判断 可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用 转换为字符串使用toString() 需要注意的是数组会直接变成字符串 [1,2,3,4] =&gt; ‘1,2,3,4’ 转换为数字ECMAScript 提供了两种把非数字的原始值转换成数字的方法，即 parseInt() 和 parseFloat() 。 只有对 String 类型调用这些方法，它们才能正确运行；对其他类型返回的都是 NaN。 转换为 Booleanundefined null ‘’ NaN 0 会转化成fasle其他的是true 强制类型转换Boolean(value) - 把给定的值转换成 Boolean 型；Number(value) - 把给定的值转换成数字（可以是整数或浮点数）； 如果转化不了就是NaNString(value) - 把给定的值转换成字符串 Boolean() 函数 Number() 函数 隐式类型转换 自动转换 Boolean 运算符 对象 出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法1、JS 数字精度丢失的一些典型问题（前端遇小数计算概率大，要有这个精度丢失的意识）2、JS 数字精度丢失的原因（计算机用二进制存储数据，由于存储位置的限制有时会存在“舍去”。当模仿十进制进行四舍五入时，0舍1入，造成误差）3、解决方案（一个对象+一个函数）（解决方案：把小数乘以倍数变成整数计算，再除以倍数变成原来的数。其中根据此思想封装了一个方法）4、 BigInt BigInt目前是第3阶段提案， 一旦添加到规范中，它就是JS 第二个数字数据类型，也将是 JS 第8种基本数据类型 原型和原型链 理解原型设计模式以及JavaScript中的原型规则 instanceof的底层实现原理，手动实现一个instanceof 实现继承的几种方式以及他们的优缺点 至少说出一种开源项目(如Node)中应用原型继承的案例 可以描述new一个对象的详细过程，手动实现一个new操作符 理解es6 class构造以及继承的底层实现原理 作用域和闭包 理解词法作用域和动态作用域 理解JavaScript的作用域和作用域链 理解JavaScript的执行上下文栈，可以应用堆栈信息快速定位问题 this的原理以及几种不同使用场景的取值 闭包的实现原理和作用，可以列举几个开发中闭包的实际应用 理解堆栈溢出和内存泄漏的原理，如何防止 如何处理循环的异步操作 理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理 执行机制 为何try里面放return，finally还会执行，理解其内部机制 JavaScript如何实现异步编程，可以详细描述EventLoop机制 宏任务和微任务分别有哪些 可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法 使用Promise实现串行 Node与浏览器EventLoop的差异 如何在保证页面运行流畅的情况下处理海量数据 语法和API 理解ECMAScript和JavaScript的关系 熟练运用es5、es6提供的语法规范， 熟练掌握JavaScript提供的全局对象（例如Date、Math）、全局函数（例如decodeURI、isNaN）、全局属性（例如Infinity、undefined） 熟练应用map、reduce、filter 等高阶函数解决问题 setInterval需要注意的点，使用settimeout实现setInterval JavaScript提供的正则表达式API、可以使用正则表达式（邮箱校验、URL解析、去重等）解决常见问题 JavaScript异常处理的方式，统一的异常处理方案 HTML和CSSHTML 从规范的角度理解HTML，从分类和语义的角度使用标签 常用页面标签的默认样式、自带属性、不同浏览器的差异、处理浏览器兼容问题的方式 元信息类标签(head、title、meta)的使用目的和配置方法 HTML5离线缓存原理 可以使用Canvas API、SVG等绘制高性能的动画 CSS CSS盒模型，在不同浏览器的差异 CSS所有选择器及其优先级、使用场景，哪些可以继承，如何运用at规则 CSS伪类和伪元素有哪些，它们的区别和实际应用 HTML文档流的排版规则，CSS几种定位的规则、定位参照物、对文档流的影响，如何选择最好的定位方式，雪碧图实现原理 水平垂直居中的方案、可以实现6种以上并对比它们的优缺点 BFC实现原理，可以解决的问题，如何创建BFC 可使用CSS函数复用代码，实现特殊效果 PostCSS、Sass、Less的异同，以及使用配置，至少掌握一种 CSS模块化方案、如何配置按需加载、如何防止CSS阻塞渲染 熟练使用CSS实现常见动画，如渐变、移动、旋转、缩放等等 CSS浏览器兼容性写法，了解不同API在不同浏览器下的兼容性情况 掌握一套完整的响应式布局方案 手写 手写图片瀑布流效果 使用CSS绘制几何图形（圆形、三角形、扇形、菱形等） 使用纯CSS实现曲线运动（贝塞尔曲线） 实现常用布局（三栏、圣杯、双飞翼、吸顶），可是说出多种方式并理解其优缺点 计算机基础编译原理 理解代码到底是什么，计算机如何将代码转换为可以运行的目标程序 正则表达式的匹配原理和性能优化 如何将JavaScript代码解析成抽象语法树(AST) base64的编码原理 几种进制的相互转换计算方法，在JavaScript中如何表示和转换 网络协议 理解什么是协议，了解TCP/IP网络协议族的构成，每层协议在应用程序中发挥的作用 三次握手和四次挥手详细原理，为什么要使用这种机制 有哪些协议是可靠，TCP有哪些手段保证可靠交付 DNS的作用、DNS解析的详细过程，DNS优化原理 CDN的作用和原理 HTTP请求报文和响应报文的具体组成，能理解常见请求头的含义，有几种请求方式，区别是什么 HTTP所有状态码的具体含义，看到异常状态码能快速定位问题 HTTP1.1、HTTP2.0带来的改变 HTTPS的加密原理，如何开启HTTPS，如何劫持HTTPS请求 理解WebSocket协议的底层原理、与HTTP的区别 设计模式 熟练使用前端常用的设计模式编写代码，如单例模式、装饰器模式、代理模式等 发布订阅模式和观察者模式的异同以及实际应用 可以说出几种设计模式在开发中的实际应用，理解框架源码中对设计模式的应用 数据结构和算法JavaScript编码能力 多种方式实现数组去重、扁平化、对比优缺点 多种方式实现深拷贝、对比优缺点 手写函数柯里化工具函数、并理解其应用场景和优势 手写防抖和节流工具函数、并理解其内部原理和应用场景 实现一个sleep函数 手动实现前端轮子 手动实现call、apply、bind 手动实现符合Promise/A+规范的Promise、手动实现async await 手写一个EventEmitter实现事件发布、订阅 可以说出两种实现双向绑定的方案、可以手动实现 手写JSON.stringify、JSON.parse 手写一个模版引擎，并能解释其中原理 手写懒加载、下拉刷新、上拉加载、预加载等效果 数据结构 理解常见数据结构的特点，以及他们在不同场景下使用的优缺点 理解数组、字符串的存储原理，并熟练应用他们解决问题 理解二叉树、栈、队列、哈希表的基本结构和特点，并可以应用它解决问题 了解图、堆的基本结构和使用场景 算法 可计算一个算法的时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗 至少理解五种排序算法的实现原理、应用场景、优缺点，可快速说出时间、空间复杂度 了解递归和循环的优缺点、应用场景、并可在开发中熟练应用 可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题 前端处理海量数据的算法方案 运行环境浏览器API 浏览器提供的符合W3C标准的DOM操作API、浏览器差异、兼容性 浏览器提供的浏览器对象模型 (BOM)提供的所有全局API、浏览器差异、兼容性 大量DOM操作、海量数据的性能优化(合并操作、Diff、requestAnimationFrame等) 浏览器海量数据存储、操作性能优化 DOM事件流的具体实现机制、不同浏览器的差异、事件代理 前端发起网络请求的几种方式及其底层实现、可以手写原生ajax、fetch、可以熟练使用第三方库 浏览器的同源策略，如何避免同源策略，几种方式的异同点以及如何选型 浏览器提供的几种存储机制、优缺点、开发中正确的选择 浏览器跨标签通信 浏览器原理 各浏览器使用的JavaScript引擎以及它们的异同点、如何在代码中进行区分 请求数据到请求结束与服务器进行了几次交互 可详细描述浏览器从输入URL到页面展现的详细过程 浏览器解析HTML代码的原理，以及构建DOM树的流程 浏览器如何解析CSS规则，并将其应用到DOM树上 浏览器如何将解析好的带有样式的DOM树进行绘制 浏览器的运行机制，如何配置资源异步同步加载 浏览器回流与重绘的底层原理，引发原因，如何有效避免 浏览器的垃圾回收机制，如何避免内存泄漏 浏览器采用的缓存方案，如何选择和控制合适的缓存方案 Node 理解Node在应用程序中的作用，可以使用Node搭建前端运行环境、使用Node操作文件、操作数据库等等 掌握一种Node开发框架，如Express，Express和Koa的区别 熟练使用Node提供的API如Path、Http、Child Process等并理解其实现原理 Node的底层运行原理、和浏览器的异同 Node事件驱动、非阻塞机制的实现原理 框架和类库TypeScript 理解泛型、接口等面向对象的相关概念，TypeScript对面向对象理念的实现 理解使用TypeScript的好处，掌握TypeScript基础语法 TypeScript的规则检测原理 可以在React、Vue等框架中使用TypeScript进行开发 React React和vue 选型和优缺点、核心架构的区别 React中setState的执行机制，如何有效的管理状态 React的事件底层实现机制 React的虚拟DOM和Diff算法的内部实现 React的Fiber工作原理，解决了什么问题 React Router和Vue Router的底层实现原理、动态加载实现原理 可熟练应用React API、生命周期等，可应用HOC、render props、Hooks等高阶用法解决问题 基于React的特性和原理，可以手动实现一个简单的React Vue 熟练使用Vue的API、生命周期、钩子函数 MVVM框架设计理念 Vue双向绑定实现原理、Diff算法的内部实现 Vue的事件机制 从template转换成真实DOM的实现机制 多端开发 单页面应用（SPA）的原理和优缺点，掌握一种快速开发SPA的方案 理解Viewport、em、rem的原理和用法，分辨率、px、ppi、dpi、dp的区别和实际应用 移动端页面适配解决方案、不同机型适配方案 掌握一种JavaScript移动客户端开发技术，如React Native：可以搭建React Native开发环境，熟练进行开发，可理解React Native的运作原理，不同端适配 掌握一种JavaScript PC客户端开发技术，如Electron：可搭建Electron开发环境，熟练进行开发，可理解Electron的运作原理 掌握一种小程序开发框架或原生小程序开发 理解多端框架的内部实现原理，至少了解一个多端框架的使用 数据流管理 掌握React和Vue传统的跨组件通信方案，对比采用数据流管理框架的异同 熟练使用Redux管理数据流，并理解其实现原理，中间件实现原理 熟练使用Mobx管理数据流，并理解其实现原理，相比Redux有什么优势 熟练使用Vuex管理数据流，并理解其实现原理 以上数据流方案的异同和优缺点，不情况下的技术选型 实用库 至少掌握一种UI组件框架，如antd design，理解其设计理念、底层实现 掌握一种图表绘制框架，如Echart，理解其设计理念、底层实现，可以自己实现图表 掌握一种GIS开发框架，如百度地图API 掌握一种可视化开发框架，如Three.js、D3 工具函数库，如lodash、underscore、moment等，理解使用的工具类或工具函数的具体实现原理 开发和调试 熟练使用各浏览器提供的调试工具 熟练使用一种代理工具实现请求代理、抓包，如charls 可以使用Android、IOS模拟器进行调试，并掌握一种真机调试方案 了解Vue、React等框架调试工具的使用 前端工程项目构建 理解npm、yarn依赖包管理的原理，两者的区别 可以使用npm运行自定义脚本 理解Babel、ESLint、webpack等工具在项目中承担的作用 ESLint规则检测原理，常用的ESLint配置 Babel的核心原理，可以自己编写一个Babel插件 可以配置一种前端代码兼容方案，如Polyfill Webpack的编译原理、构建流程、热更新原理，chunk、bundle和module的区别和应用 可熟练配置已有的loaders和plugins解决问题，可以自己编写loaders和plugins nginx 正向代理与反向代理的特点和实例 可手动搭建一个简单的nginx服务器、 熟练应用常用的nginx内置变量，掌握常用的匹配规则写法 可以用nginx实现请求过滤、配置gzip、负载均衡等，并能解释其内部原理 开发提速 熟练掌握一种接口管理、接口mock工具的使用，如yapi 掌握一种高效的日志埋点方案，可快速使用日志查询工具定位线上问题 理解TDD与BDD模式，至少会使用一种前端单元测试框架 版本控制 理解Git的核心原理、工作流程、和SVN的区别 熟练使用常规的Git命令、git rebase、git stash等进阶命令 可以快速解决线上分支回滚、线上分支错误合并等复杂问题 持续集成 理解CI/CD技术的意义，至少熟练掌握一种CI/CD工具的使用，如Jenkins 可以独自完成架构设计、技术选型、环境搭建、全流程开发、部署上线等一套完整的开发流程（包括Web应用、移动客户端应用、PC客户端应用、小程序、H5等等） 项目和业务 了解后端的开发方式，在应用程序中的作用，至少会使用一种后端语言 掌握数据最终在数据库中是如何落地存储的，能看懂表结构设计、表之间的关联，至少会使用一种数据库 性能优化 了解前端性能衡量指标、性能监控要点，掌握一种前端性能监控方案 了解常见的Web、App性能优化方案 SEO排名规则、SEO优化方案、前后端分离的SEO SSR实现方案、优缺点、及其性能优化 Webpack的性能优化方案 Canvas性能优化方案 React、Vue等框架使用性能优化方案 前端安全 XSS攻击的原理、分类、具体案例，前端如何防御 CSRF攻击的原理、具体案例，前端如何防御 HTTP劫持、页面劫持的原理、防御措施 业务相关 能理解所开发项目的整体业务形态、业务目标、业务架构，可以快速定位线上业务问题 能理解所开发项目整体的技术架构、能快读的根据新需求进行开发规划、能快速根据业务报警、线上日志等定位并解决线上技术问题 可以将自己的想法或新技术在业务中落地实践，尽量在团队中拥有一定的不可替代性 资源转载作者：ConardLi链接：https://juejin.cn/post/6844903830887366670来源：稀土掘金","categories":[],"tags":[{"name":"前端自检清单","slug":"前端自检清单","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E8%87%AA%E6%A3%80%E6%B8%85%E5%8D%95/"}]},{"title":"底层存储方式","slug":"计算机/底层存储方式","date":"2021-11-24T16:00:00.000Z","updated":"2021-11-25T03:42:40.976Z","comments":true,"path":"2021/11/25/计算机/底层存储方式/","link":"","permalink":"http://example.com/2021/11/25/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/","excerpt":"","text":"语言中所有的底层存储方式是是什么？ 数组(Array)数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。数组可以说是最基本的数据结构，在各种编程语言中都有对应。一个数组可以分解为多个数组元素，按照数据元素的类型，数组可以分为整型数组、字符型数组、浮点型数组、指针数组和结构数组等。数组还可以有一维、二维以及多维等表现形式。 栈( Stack)栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。栈按照后进先出的原则来存储数据，也就是说，先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据时，从栈顶开始逐个读出。栈在汇编语言程序中，经常用于重要数据的现场保护。栈中没有数据时，称为空栈。 队列(Queue)队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。一般来说，进行插入操作的一端称为队尾，进行删除操作的一端称为队头。队列中没有元素时，称为空队列 链表( Linked List)链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。链表由一系列数据结点构成，每个数据结点包括数据域和指针域两部分。其中，指针域保存了数据结构中下一个元素存放的地址。链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的。 树( Tree)树是典型的非线性结构，它是包括，2个结点的有穷集合K。在树结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个后继结点，m≥0 图(Graph)图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系 堆(Heap)堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。堆的特点是根结点的值是所有结点中最小的或者最大的，并且根结点的两个子树也是一个堆结构 散列表(Hash)散列表源自于散列函数(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录","categories":[],"tags":[{"name":"底层存储方式","slug":"底层存储方式","permalink":"http://example.com/tags/%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/"}]},{"title":"webpack入口起点","slug":"其他/webpack-入口起点","date":"2021-09-15T16:00:00.000Z","updated":"2021-09-16T07:14:45.217Z","comments":true,"path":"2021/09/16/其他/webpack-入口起点/","link":"","permalink":"http://example.com/2021/09/16/%E5%85%B6%E4%BB%96/webpack-%E5%85%A5%E5%8F%A3%E8%B5%B7%E7%82%B9/","excerpt":"","text":"单个入口（简写）语法用法：entry: string | [string]webpack.config.js module.exports = &#123; entry: './path/to/my/entry/file.js', &#125;; module.exports = &#123; entry: &#123; main: './path/to/my/entry/file.js', &#125;, &#125;; 我们也可以将一个文件路径数组传递给 entry 属性，这将创建一个所谓的 “multi-main entry”。在你想要一次注入多个依赖文件，并且将它们的依赖关系绘制在一个 “chunk” 中时，这种方式就很有用。 module.exports = &#123; entry: ['./src/file_1.js', './src/file_2.js'], output: &#123; filename: 'bundle.js', &#125;, &#125;; 对象语法用法：entry: { string | [string] } | {} module.exports = &#123; entry: &#123; app: './src/app.js', adminApp: './src/adminApp.js', &#125;, &#125; 对象语法会比较繁琐。然而，这是应用程序中定义入口的最可扩展的方式。","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://example.com/tags/webpack/"}]},{"title":"webpack学习概念篇","slug":"其他/webpack-学习","date":"2021-08-30T16:00:00.000Z","updated":"2021-09-16T06:55:19.733Z","comments":true,"path":"2021/08/31/其他/webpack-学习/","link":"","permalink":"http://example.com/2021/08/31/%E5%85%B6%E4%BB%96/webpack-%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"entry 入口入口起点(entry point) 指示 webpack 应该使用哪个模块，来作为构建其内部 依赖图(dependency graph) 的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。默认值是 ./src/index.js，但你可以通过在 webpack configuration 中配置 entry 属性，来指定一个（或多个）不同的入口起点。例如：webpack.config.js module.exports = &#123; entry: './path/to/my/entry/file.js', &#125;; output 输出output 属性告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。主要输出文件的默认值是 ./dist/main.js，其他生成文件默认放置在 ./dist 文件夹中。你可以通过在配置中指定一个 output 字段，来配置这些处理过程：webpack.config.js const path = require('path'); module.exports = &#123; entry: './path/to/my/entry/file.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'my-first-webpack.bundle.js', &#125;, &#125;; 在上面的示例中，我们通过 output.filename 和 output.path 属性，来告诉 webpack bundle 的名称，以及我们想要 bundle 生成(emit)到哪里。可能你想要了解在代码最上面导入的 path 模块是什么，它是一个 Node.js 核心模块，用于操作文件路径。 loderwebpack 只能理解 JavaScript 和 JSON 文件，这是 webpack 开箱可用的自带能力。loader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 模块，以供应用程序使用，以及被添加到依赖图中。 在更高层面，在 webpack 的配置中，loader 有两个属性： test 属性，识别出哪些文件会被转换。 use 属性，定义出在进行转换时，应该使用哪个 loader。webpack.config.js const path = require('path'); module.exports = &#123; output: &#123; filename: 'my-first-webpack.bundle.js', &#125;, module: &#123; rules: [&#123; test: /\\.txt$/, use: 'raw-loader' &#125;], &#125;, &#125;; ```` + piugin 插件 loader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量。 想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建一个插件实例。 ```js const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装 const webpack = require('webpack'); // 用于访问内置插件 module.exports = &#123; module: &#123; rules: [&#123; test: /\\.txt$/, use: 'raw-loader' &#125;], &#125;, plugins: [new HtmlWebpackPlugin(&#123; template: './src/index.html' &#125;)], &#125;; 在上面的示例中，html-webpack-plugin 为应用程序生成一个 HTML 文件，并自动将生成的所有 bundle 注入到此文件中。 mode 模式通过选择 development, production 或 none 之中的一个，来设置 mode 参数，你可以启用 webpack 内置在相应环境下的优化。其默认值为 production。 module.exports = &#123; mode: 'production', &#125;; 浏览器兼容性Webpack 支持所有符合 ES5 标准 的浏览器（不支持 IE8 及以下版本）。webpack 的 import() 和 require.ensure() 需要 Promise。如果你想要支持旧版本浏览器，在使用这些表达式之前，还需要 提前加载 polyfill。 环境Webpack 5 运行于 Node.js v10.13.0+ 的版本。","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://example.com/tags/webpack/"}]},{"title":"js字符串","slug":"js/js-字符串","date":"2021-08-27T16:00:00.000Z","updated":"2021-08-26T06:30:15.985Z","comments":true,"path":"2021/08/28/js/js-字符串/","link":"","permalink":"http://example.com/2021/08/28/js/js-%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"字符串和数组比较相似，都是类数组，都有length属性以及indexOf()和concat()方法。但是数组是可变的，字符串是不可变的。字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串。而数组的成员函数都是在其原始基础上进行操作。 许多数组函数处理字符串很方便。虽然字符串没有这些函数，但是可以通过‘借用’数组的方法来处理字符串： let a ='12345' a.map // undefined a.join // undefined let b = Array.prototype.join.call(a,'-') console.log(b) // '1-2-3-4-5' let c = Array.prototype.map.call(a, item => &#123; return item + '牙牙乐' &#125;).join('') console.log(c)","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"js数组","slug":"js/js-数组","date":"2021-08-26T16:00:00.000Z","updated":"2021-08-26T06:07:53.913Z","comments":true,"path":"2021/08/27/js/js-数组/","link":"","permalink":"http://example.com/2021/08/27/js/js-%E6%95%B0%E7%BB%84/","excerpt":"","text":"数组可以容纳任何类型的的值，可以是字符串、数字、对象、甚至是其他数组。数组申明后就可以往里面添加值，不需要预设大小。 数组方法 push()向数组的末尾添加新内容参数：要添加的项。传递多个用逗号隔开，任何数据类型都可以返回值：新增后数组的长度是否改变原数组：改变 let ary1 = [12,34,26]; ary1.push(100); //返回一个新的长度 length=4console.log(ary1)//结果为 [12,34,26,100] pop()删除数组的最后一项参数：无返回值：被删除的项是否改变原数组：改变 let ary2 = [108,112,39,10]; ary2.pop();//删除的最后一项为10 console.log(ary2);//[108, 112, 39] shift()删除数组的第一项参数：无返回值：被删除的项是否改变原数组：改变 let ary3 = [0,108,112,39]; ary3.shift();//删除的第一项为0 console.log(ary3);//[108, 112, 39] unshift()向数组首位添加新内容参数：要添加的项，多项用’,’隔开返回值：新数组的长度是否改变原数组：改变 let ary4 = ['c','d']; ary4.unshift('a','b'); console.log(ary4);//[\"a\", \"b\", \"c\", \"d\"] slice()按照条件查找出其中的部分内容参数：array.slice(n, m)，从索引n开始查找到m处（不包含m）array.slice(n) 第二个参数省略，则一直查找到末尾array.slice(0)原样输出内容，可以实现数组克隆array.slice(-n,-m) slice支持负参数，从最后一项开始算起，-1为最后一项，-2为倒数第二项返回值：返回一个新数组是否改变原数组：不改变 let ary5 = [1,2,3,4,5,6,7,8,9]; console.log(ary5.slice(2,8));//从索引2开始查找到索引为8的内容，结果为[3, 4, 5, 6, 7, 8] console.log(ary5.slice(0)); console.log(ary5.slice(-2,-1));//[8] splice()对数组进行增删改增加：ary.splice(n,0,m)从索引n开始删除0项，把m或者更多的内容插入到索引n的前面返回空数组修改：ary.splice(n,x,m)从索引n开始删除x个，m替换删除的部分把原有内容删除掉，然后用新内容替换掉删除：ary.splice(n,m) 从索引n开始删除m个内容（如果第二个参数省略，则从n删除到末尾）返回删除的新数组，原有数组改变 //增加 let ary6_z = [33,44,55,66,77,88]; ary6_z.splice(2,0,'a','b') console.log(ary6_z);// [33, 44, \"a\", \"b\", 55, 66, 77, 88] //修改 let ary6_x = [33,44,55,66,77,88]; ary6_x.splice(1,2,'x','y') console.log(ary6_x);// [33, \"x\", \"y\", 66, 77, 88] //删除 let ary6_s = [33,44,55,66,77,88]; //console.log(ary6.splice(3,2))//[66, 77] console.log(ary6_s.splice(3));//[66, 77, 88] join()用指定的分隔符将数组每一项拼接为字符串参数：指定的分隔符（如果省略该参数，则使用逗号作为分隔符）返回值：拼接好的字符串是否改变原数组：不改变 let ary7 = [1,2,3]; console.log(ary7.join('、'));//1、2、3 concat()用于连接两个或多个数组参数：参数可以是具体的值，也可以是数组对象。可以是任意多个返回值：返回连接后的新数组是否改变原数组：不改变 let ary8 = ['你']; let ary80 = ary8.concat('好'); console.log(ary80);//[\"你\", \"好\"] indexOf()检测当前值在数组中第一次出现的位置索引参数：array.indexOf(item,start) item:查找的元素 start:字符串中开始检索的位置返回值：第一次查到的索引，未找到返回-1是否改变原数组：不改变 let ary9 = ['a','b','c','d','e','a','f']; console.log(ary9.indexOf('c'));//2 console.log(ary9.indexOf('a',3))//5 lastIndexOf()检测当前值在数组中最后一次出现的位置索引参数：array.lastIndexOf(item,start) item:查找的元素 start:字符串中开始检索的位置返回值：第一次查到的索引，未找到返回-1是否改变原数组：不改变 let ary10 = ['a','b','c','d','e','a','f']; console.log(ary10.lastIndexOf('c'));//2 console.log(ary10.lastIndexOf('f',1))//-1 includes()判断一个数组是否包含一个指定的值参数：指定的内容返回值：布尔值是否改变原数组：不改变 let ary13 = ['a','b','c','d']; console.log(ary13.includes('c'));//true console.log(ary13.includes(2));//false sort()对数组的元素进行排序（默认是从小到大来排序 并且是根据字符串来排序的）参数：可选(函数) 规定排序规则 默认排序顺序为按字母升序返回值：排序后新数组是否改变原数组：改变sort在不传递参数情况下，只能处理10以内（个位数）数字排序 let ary11 = [32,44,23,54,90,12,9]; ary11.sort(function(a,b)&#123; // return a-b; // 结果[9, 12, 23, 32, 44, 54, 90] // return b-a; // 结果[90, 54, 44, 32, 23, 12, 9] &#125;) console.log(ary11); reverse()把数组倒过来排列参数：无返回值：倒序后新数组是否改变原数组：改变 let ary12 = [6,8,10,12]; console.log(ary12.reverse());//[12, 10, 8, 6] forEach()循环遍历数组每一项参数：函数 ary.forEach(function(item,index,ary){}) item:每一项 index:索引 ary:当前数组返回值：无是否改变原数组：不改变 （但是这里我们常用forEach来改变数组里面的值，需要具体去分析）forEach中不能使用continue和break，forEach中不能跳出，只能跳过(return跳过) let ary14 = ['a','b','c','d']; let item = ary14.forEach(function(item,index,ary)&#123; onsole.log(item,index,ary); &#125;) 改变原数组中引用数据类型值、不改变原数组中基本数据类型let obj = &#123;'a': 1&#125; let arr = [1,2,obj,true] arr.forEach(item => &#123; if(typeof item === 'object')&#123; item['bbb'] = 2 &#125; item = '改变后' &#125;) console.log(arr) // [1,2,&#123;'a':1,'bbb':2&#125;,true] 改变原数组中基本数据类型值let obj = &#123;'a': 1&#125; let arr = [1,2,obj,true] arr.forEach((item,key) => &#123; if(typeof item === 'object')&#123; arr[key]['bbb'] = '改变后' &#125; else&#123; arr[key] = '改变后' &#125; &#125;) console.log(arr) // [\"改变后\", \"改变后\", &#123;a: 1,bbb: \"改变后\"&#125;, \"改变后\"] 原因是循环出来的如果是基本数据类型的话，就会是一个值（1 = 2），这样肯定是实现不了的。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"vue内置组件","slug":"vue/vue-内置组件","date":"2021-08-25T16:00:00.000Z","updated":"2021-08-26T01:37:31.617Z","comments":true,"path":"2021/08/26/vue/vue-内置组件/","link":"","permalink":"http://example.com/2021/08/26/vue/vue-%E5%86%85%E7%BD%AE%E7%BB%84%E4%BB%B6/","excerpt":"","text":"是 Vue 实现的一个内置组件，也就是说 Vue 源码不仅实现了一套组件化的机制，也实现了一些内置组件，关于组件，官网如下介绍： 是Vue中内置的一个抽象组件，它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。当它包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。 这句话的意思简单来说：就是我们可以把一些不常变动的组件或者需要缓存的组件用包裹起来，这样就会帮我们把组件保存在内存中，而不是直接的销毁，这样做可以保留组件的状态或避免多次重新渲染，以提高页面性能。 &lt;div id=\"app\"> &lt;button @click=\"switchComp('child1')\">组件1&lt;/button> &lt;button @click=\"switchComp('child2')\">组件2&lt;/button> &lt;component :is=\"chooseComponent\">&lt;/component> &lt;/div> &lt;body> &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\">&lt;/script> &lt;script> var child1 = &#123; template: '&lt;div>组件1:&lt;input type=\"text\"/>&lt;/div>', &#125; var child2 = &#123; template: '&lt;div>组件2:&lt;input type=\"text\"/>&lt;/div>' &#125; var vm = new Vue(&#123; el: '##app', components: &#123; child1, child2, &#125;, data() &#123; return &#123; chooseComponent: 'child1', &#125; &#125;, methods: &#123; switchComp(component) &#123; this.chooseComponent = component; &#125; &#125; &#125;) &lt;/script> &lt;/body> 可以看到，上述代码中定义了两个子组件child1和child2，然后使用两个按钮和一个动态组件来做出点击按钮切换不同组件的效果我们给组件1和组件2的输入框中分别输入了不同的内容后，之后当我们点击按钮切换组件的时候，切换之前输入的内容已经不存在了，这就说明点击按钮切换组件是把之前的组件销毁，然后又重新挂载了一次。 但是我们有时候又会有这样的需求：当用户再次切回组件时保留切走之前的组件状态。此时Vue内置的组件就派上用场了，我们将上述代码中的动态组件用包裹一下，如下： &lt;div id=\"app\"> &lt;button @click=\"switchComp('child1')\">组件1&lt;/button> &lt;button @click=\"switchComp('child2')\">组件2&lt;/button> &lt;keep-alive> &lt;component :is=\"chooseComponent\">&lt;/component> &lt;/keep-alive> &lt;/div> 用法组件可接收三个属性： include - 字符串或正则表达式。只有名称匹配的组件会被缓存。 exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。 max - 数字。最多可以缓存多少组件实例。 include 和 exclude 属性允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示 &lt;!-- 逗号分隔字符串 --> &lt;keep-alive include=\"a,b\"> &lt;component :is=\"view\">&lt;/component> &lt;/keep-alive> &lt;!-- 正则表达式 (使用 `v-bind`) --> &lt;keep-alive :include=\"/a|b/\"> &lt;component :is=\"view\">&lt;/component> &lt;/keep-alive> &lt;!-- 数组 (使用 `v-bind`) --> &lt;keep-alive :include=\"['a', 'b']\"> &lt;component :is=\"view\">&lt;/component> &lt;/keep-alive> &lt;keep-alive :max=\"10\"> &lt;component :is=\"view\">&lt;/component> &lt;/keep-alive> 匹配时首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称 (父组件 components 选项的键值)，也就是组件的标签值。匿名组件不能被匹配。 max表示最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉。 实现原理组件的定义位于源码的 src/core/components/keep-alive.js 文件中，如下： export default &#123; name: 'keep-alive', abstract: true, props: &#123; include: [String, RegExp, Array], exclude: [String, RegExp, Array], max: [String, Number] &#125;, created () &#123; this.cache = Object.create(null) this.keys = [] &#125;, destroyed () &#123; for (const key in this.cache) &#123; pruneCacheEntry(this.cache, key, this.keys) &#125; &#125;, mounted () &#123; this.$watch('include', val => &#123; pruneCache(this, name => matches(val, name)) &#125;) this.$watch('exclude', val => &#123; pruneCache(this, name => !matches(val, name)) &#125;) &#125;, render() &#123; /* 获取默认插槽中的第一个组件节点 */ const slot = this.$slots.default const vnode = getFirstComponentChild(slot) /* 获取该组件节点的componentOptions */ const componentOptions = vnode &amp;&amp; vnode.componentOptions if (componentOptions) &#123; /* 获取该组件节点的名称，优先获取组件的name字段，如果name不存在则获取组件的tag */ const name = getComponentName(componentOptions) const &#123; include, exclude &#125; = this /* 如果name不在inlcude中或者存在于exlude中则表示不缓存，直接返回vnode */ if ( (include &amp;&amp; (!name || !matches(include, name))) || // excluded (exclude &amp;&amp; name &amp;&amp; matches(exclude, name)) ) &#123; return vnode &#125; const &#123; cache, keys &#125; = this const key = vnode.key == null // same constructor may get registered as different local components // so cid alone is not enough (##3269) ? componentOptions.Ctor.cid + (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : '') : vnode.key if (cache[key]) &#123; vnode.componentInstance = cache[key].componentInstance // make current key freshest remove(keys, key) keys.push(key) &#125; else &#123; cache[key] = vnode keys.push(key) // prune oldest entry if (this.max &amp;&amp; keys.length > parseInt(this.max)) &#123; pruneCacheEntry(cache, keys[0], keys, this._vnode) &#125; &#125; vnode.data.keepAlive = true &#125; return vnode || (slot &amp;&amp; slot[0]) &#125; &#125; 生命周期钩子组件一旦被 缓存，那么再次渲染的时候就不会执行 created、mounted 等钩子函数，但是我们很多业务场景都是希望在我们被缓存的组件再次被渲染的时候做一些事情，好在Vue 提供了 activated和deactivated 两个钩子函数，它的执行时机是 包裹的组件激活时调用和停用时调用，下面我们就通过一个简单的例子来演示一下这两个钩子函数，示例如下： let A = &#123; template: '&lt;div class=\"a\">' + '&lt;p>A Comp&lt;/p>' + '&lt;/div>', name: 'A', mounted()&#123; console.log('Comp A mounted') &#125;, activated()&#123; console.log('Comp A activated') &#125;, deactivated()&#123; console.log('Comp A deactivated') &#125; &#125; let B = &#123; template: '&lt;div class=\"b\">' + '&lt;p>B Comp&lt;/p>' + '&lt;/div>', name: 'B', mounted()&#123; console.log('Comp B mounted') &#125;, activated()&#123; console.log('Comp B activated') &#125;, deactivated()&#123; console.log('Comp B deactivated') &#125; &#125; let vm = new Vue(&#123; el: '##app', template: '&lt;div>' + '&lt;keep-alive>' + '&lt;component :is=\"currentComp\">' + '&lt;/component>' + '&lt;/keep-alive>' + '&lt;button @click=\"change\">switch&lt;/button>' + '&lt;/div>', data: &#123; currentComp: 'A' &#125;, methods: &#123; change() &#123; this.currentComp = this.currentComp === 'A' ? 'B' : 'A' &#125; &#125;, components: &#123; A, B &#125; &#125;) 我们定义了两个组件A和B并为其绑定了钩子函数，并且在根组件中用 组件包裹了一个动态组件，这个动态组件默认指向组件A，当点击switch按钮时，动态切换组件A和B。当第一次打开页面时，组件A被挂载，执行了组件A的mounted和activated钩子函数，当点击switch按钮后，组件A停止调用，同时组件B被挂载，此时执行了组件A的deactivated和组件B的mounted和activated钩子函数。此时再点击switch按钮，组件B停止调用，组件A被再次激活，我们发现现在只执行了组件A的activated钩子函数，这就验证了文档中所说的组件一旦被 缓存，那么再次渲染的时候就不会执行 created、mounted 等钩子函数。","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://example.com/tags/vue2-0/"}]},{"title":"vue全局API","slug":"vue/vue-全局api","date":"2021-08-11T16:00:00.000Z","updated":"2021-08-12T09:50:21.812Z","comments":true,"path":"2021/08/12/vue/vue-全局api/","link":"","permalink":"http://example.com/2021/08/12/vue/vue-%E5%85%A8%E5%B1%80api/","excerpt":"","text":"与实例方法不同，实例方法是将方法挂载到Vue的原型上，而全局API是直接在Vue上挂载方法。在Vue中，全局API一共有12个，分别是Vue.extend、Vue.nextTick、Vue.set、Vue.delete、Vue.directive、Vue.filter、Vue.component、Vue.use、Vue.mixin、Vue.observable、Vue.version。这12个API中有的是我们在日常业务开发中经常会用到的，有的是对Vue内部或外部插件提供的，我们在日常业务开发中几乎用不到。 Vue.extendVue.extend( options ) 参数{Object} options 作用使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。data 选项是特例，需要注意 - 在 Vue.extend() 中它必须是函数&lt;div id=\"mount-point\">&lt;/div> // 创建构造器 var Profile = Vue.extend(&#123; template: '&lt;p>&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p>', data: function () &#123; return &#123; firstName: 'Walter', lastName: 'White', alias: 'Heisenberg' &#125; &#125; &#125;) // 创建 Profile 实例，并挂载到一个元素上。 new Profile().$mount('##mount-point') &lt;p>Walter White aka Heisenberg&lt;/p> 原理分析Vue.extend的作用是创建一个继承自Vue类的子类，可接收的参数是一个包含组件选项的对象。 既然是Vue类的子类，那么除了它本身独有的一些属性方法，还有一些是从Vue类中继承而来，所以创建子类的过程其实就是一边给子类上添加上独有的属性，一边将父类的公共属性复制到子类上 Vue.extend = function (extendOptions: Object): Function &#123; extendOptions = extendOptions || &#123;&#125; const Super = this const SuperId = Super.cid const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;) if (cachedCtors[SuperId]) &#123; return cachedCtors[SuperId] &#125; const name = extendOptions.name || Super.options.name if (process.env.NODE_ENV !== 'production' &amp;&amp; name) &#123; validateComponentName(name) &#125; const Sub = function VueComponent (options) &#123; this._init(options) &#125; Sub.prototype = Object.create(Super.prototype) Sub.prototype.constructor = Sub Sub.cid = cid++ Sub.options = mergeOptions( Super.options, extendOptions ) Sub['super'] = Super if (Sub.options.props) &#123; initProps(Sub) &#125; if (Sub.options.computed) &#123; initComputed(Sub) &#125; // allow further extension/mixin/plugin usage Sub.extend = Super.extend Sub.mixin = Super.mixin Sub.use = Super.use // create asset registers, so extended classes // can have their private assets too. ASSET_TYPES.forEach(function (type) &#123; Sub[type] = Super[type] &#125;) // enable recursive self-lookup if (name) &#123; Sub.options.components[name] = Sub &#125; Sub.superOptions = Super.options Sub.extendOptions = extendOptions Sub.sealedOptions = extend(&#123;&#125;, Sub.options) // cache constructor cachedCtors[SuperId] = Sub return Sub &#125; 首先，该函数内部定义了几个变量 extendOptions：用户传入的一个包含组件选项的对象参数； Super：指向父类，即基础 Vue类； SuperId：父类的cid属性，无论是基础 Vue类还是从基础 Vue类继承而来的类，都有一个cid属性，作为该类的唯一标识； cachedCtors：缓存池，用于缓存创建出来的类； 接着，在缓存池中先尝试获取是否之前已经创建过的该子类，如果之前创建过，则直接返回之前创建的。之所以有这一步，是因为Vue为了性能考虑，反复调用Vue.extend其实应该返回同一个结果，只要返回结果是固定的，就可以将结果缓存，再次调用时，只需从缓存中取出结果即可。在API方法定义的最后，当创建完子类后，会使用父类的cid作为key，创建好的子类作为value，存入缓存池cachedCtors中。 接着，获取到传入的选项参数中的name字段，并且在开发环境下校验name字段是否合法， 创建一个类Sub，这个类就是将要继承基础Vue类的子类 到这里，我们已经把类创建好了，接下来的工作就是让该类去继承基础Vue类，让其具备一些基础Vue类的能力 首先，将父类的原型继承到子类中，并且为子类添加唯一标识cid 将父类的options与子类的options进行合并，将合并结果赋给子类的options属性 将父类保存到子类的super属性中，以确保在子类中能够拿到父类 如果选项中存在props属性，则初始化它 初始化props属性其实就是把参数中传入的props选项代理到原型的_props中 如果选项中存在computed属性，则初始化它 初始化props属性就是遍历参数中传入的computed选项，将每一项都调用defineComputed函数定义到子类原型上。此处的defineComputed函数与我们之前在生命周期初始化阶段initState中所介绍的defineComputed函数是一样的。 将父类中的一些属性复制到子类中 给子类新增三个独有的属性 使用父类的cid作为key，创建好的子类Sub作为value，存入缓存池cachedCtors中 最终将创建好的子类Sub返回 其实总体来讲，整个过程就是先创建一个类Sub，接着通过原型继承的方式将该类继承基础Vue类，然后给Sub类添加一些属性以及将父类的某些属性复制到Sub类上，最后将Sub类返回 Vue.nextTick该API的原理同实例方法 $nextTick原理一样，此处不再重复。唯一不同的是实例方法 $nextTick 中回调的 this 绑定在调用它的实例上 Vue.nextTick( [callback, context] ) 参数： {Function} [callback] {Object} [context] 作用：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 Vue.set原理同实例方法 $set原理一样。 参数： {Object | Array} target {string | number} propertyName/index {any} value 返回值：设置的值。 作用：向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 (比如 this.myObject.newProperty = ‘hi’) Vue.delete原理同实例方法 $delete原理一样 参数： {Object | Array} target {string | number} propertyName/index 仅在 2.2.0+ 版本中支持 Array + index 用法。 作用：删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到属性被删除的限制。 Vue.directiveVue.directive( id, [definition] ) 参数 {string} id {Function | Object} [definition] 作用注册或获取全局指令。// 注册 Vue.directive('my-directive', &#123; bind: function () &#123;&#125;, inserted: function () &#123;&#125;, update: function () &#123;&#125;, componentUpdated: function () &#123;&#125;, unbind: function () &#123;&#125; &#125;) // 注册 (指令函数) Vue.directive('my-directive', function () &#123; // 这里将会被 `bind` 和 `update` 调用 &#125;) // getter，返回已注册的指令 var myDirective = Vue.directive('my-directive') 原理分析该API是用来注册或获取全局指令的，接收两个参数：指令id和指令的定义。这里需要注意一点的是：注册指令是将定义好的指令存放在某个位置，获取指令是根据指令id从存放指令的位置来读取指令Vue.options = Object.create(null) Vue.options['directives'] = Object.create(null) Vue.directive= function (id,definition) &#123; if (!definition) &#123; return this.options['directives'][id] &#125; else &#123; if (type === 'directive' &amp;&amp; typeof definition === 'function') &#123; definition = &#123; bind: definition, update: definition &#125; &#125; this.options['directives'][id] = definition return definition &#125; &#125; 可以看到，我们在Vue类上创建了options属性，其属性值为一个空对象，并且在options属性中添加了directives属性，其值也是一个空对象，这个directives属性就是用来存放指令的位置。 该API可以用来注册或获取全局指令，这两种功能的切换取决于是否传入了definition参数。如果没有传入definition参数，则表示为获取指令，那么就从存放指令的地方根据指令id来读取指令并返回 如果传入了definition参数，则表示为注册指令，那么继续判断definition参数是否是一个函数，如果是函数，则默认监听bind和update两个事件，即将definition函数分别赋给bind和update两个属性。 如果definition参数不是一个函数，那么即认为它是用户自定义的指令对象，直接将其保存在this.options[‘directives’]中 Vue.filterVue.filter( id, [definition] ) 参数 {string} id {Function} [definition] 作用注册或获取全局过滤器。// 注册 Vue.filter('my-filter', function (value) &#123; // 返回处理后的值 &#125;) // getter，返回已注册的过滤器 var myFilter = Vue.filter('my-filter') 原理分析该API是用来注册或获取全局过滤器的，接收两个参数：过滤器id和过滤器的定义。同全局指令一样，注册过滤器是将定义好的过滤器存放在某个位置，获取过滤器是根据过滤器id从存放过滤器的位置来读取过滤器。 Vue.options = Object.create(null) Vue.options['filters'] = Object.create(null) Vue.filter= function (id,definition) &#123; if (!definition) &#123; return this.options['filters'][id] &#125; else &#123; this.options['filters'][id] = definition return definition &#125; &#125; 可以看到，同全局指令一样，Vue.options[‘filters’]是用来存放全局过滤器的地方。还是根据是否传入了definition参数来决定本次操作是注册过滤器还是获取过滤器。如果没有传入definition参数，则表示本次操作为获取过滤器，那么就从存放过滤器的地方根据过滤器id来读取过滤器并返回；如果传入了definition参数，则表示本次操作为注册过滤器，那就直接将其保存在this.options[‘filters’]中 使用过滤器过滤器有两种使用方式：在双花括号插值中和在 v-bind 表达式中 (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“|”符号指示： &lt;!-- 在双花括号中 --> &#123;&#123; message | capitalize &#125;&#125; &lt;!-- 在 `v-bind` 中 --> &lt;div v-bind:id=\"rawId | formatId\">&lt;/div> 过滤器的定义你可以在一个组件的选项中定义本地的过滤器： filters: &#123; capitalize: function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125; 也可以在创建 Vue 实例之前使用全局APIVue.filter来定义全局过滤器: Vue.filter('capitalize', function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125;) 串联过滤器过滤器函数总接收表达式的值 (之前的操作链的结果) 作为第一个参数。在上述例子中，capitalize 过滤器函数将会收到 message 的值作为第一个参数。过滤器可以串联： &#123;&#123; message | filterA | filterB &#125;&#125; 在这个例子中，filterA 被定义为接收单个参数的过滤器函数，表达式 message 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 filterB，将 filterA 的结果传递到 filterB 中。 过滤器是 JavaScript 函数，因此可以接收参数： &#123;&#123; message | filterA('arg1', arg2) &#125;&#125; 这里，filterA 被定义为接收三个参数的过滤器函数。其中 message 的值作为第一个参数，普通字符串 ‘arg1’ 作为第二个参数，表达式 arg2 的值作为第三个参数 Vue.componentVue.component( id, [definition] ) 参数 {string} id {Function | Object} [definition] 作用注册或获取全局组件。注册还会自动使用给定的id设置组件的名称// 注册组件，传入一个扩展过的构造器 Vue.component('my-component', Vue.extend(&#123; /* ... */ &#125;)) // 注册组件，传入一个选项对象 (自动调用 Vue.extend) Vue.component('my-component', &#123; /* ... */ &#125;) // 获取注册的组件 (始终返回构造器) var MyComponent = Vue.component('my-component') 原理分析该API是用来注册或获取全局组件的，接收两个参数：组件id和组件的定义。 同全局指令一样，注册全局组件是将定义好的组件存放在某个位置，获取组件是根据组件id从存放组件的位置来读取组件。Vue.options = Object.create(null) Vue.options['components'] = Object.create(null) Vue.filter= function (id,definition) &#123; if (!definition) &#123; return this.options['components'][id] &#125; else &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; type === 'component') &#123; validateComponentName(id) &#125; if (type === 'component' &amp;&amp; isPlainObject(definition)) &#123; definition.name = definition.name || id definition = this.options._base.extend(definition) &#125; this.options['components'][id] = definition return definition &#125; &#125; 可以看到，同全局指令一样，Vue.options[‘components’]是用来存放全局组件的地方。还是根据是否传入了definition参数来决定本次操作是注册组件还是获取组件。如果没有传入definition参数，则表示本次操作为获取组件，那么就从存放组件的地方根据组件id来读取组件并返回；如果传入了definition参数，则表示本次操作为注册组件，如果是注册组件，那么在非生产环境下首先会校验组件的name值是否合法. 接着，判断传入的definition参数是否是一个对象，如果是对象，则使用Vue.extend方法将其变为Vue的子类，同时如果definition对象中不存在name属性时，则使用组件id作为组件的name属性。 将注册好的组件保存在this.options[‘components’]中 directive、filter、component小结通过对Vue.directive、Vue.filter和Vue.component这三个API的分析，细心的你肯定会发现这三个API的代码实现非常的相似，是的，这是我们为了便于理解故意拆开的，其实在源码中这三个API的实现是写在一起的，位于源码的src/core/global-api/index,js和src/core/global-api/assets,js中 export const ASSET_TYPES = [ 'component', 'directive', 'filter' ] Vue.options = Object.create(null) ASSET_TYPES.forEach(type => &#123; Vue.options[type + 's'] = Object.create(null) &#125;) ASSET_TYPES.forEach(type => &#123; Vue[type] = function (id,definition) &#123; if (!definition) &#123; return this.options[type + 's'][id] &#125; else &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; type === 'component') &#123; validateComponentName(id) &#125; if (type === 'component' &amp;&amp; isPlainObject(definition)) &#123; definition.name = definition.name || id definition = this.options._base.extend(definition) &#125; if (type === 'directive' &amp;&amp; typeof definition === 'function') &#123; definition = &#123; bind: definition, update: definition &#125; &#125; this.options[type + 's'][id] = definition return definition &#125; &#125; &#125;) Vue.useVue.use( plugin ) 参数 {Object | Function} plugin 作用安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。该方法需要在调用 new Vue() 之前被调用。当 install 方法被同一个插件多次调用，插件将只会被安装一次 该API是用来安装Vue.js插件的。并且我们知道了，该API内部会调用插件提供的install 方法，同时将Vue 作为参数传入。另外，由于插件只会被安装一次，所以该API内部还应该防止 install 方法被同一个插件多次调用。 Vue.use = function (plugin) &#123; const installedPlugins = (this._installedPlugins || (this._installedPlugins = [])) if (installedPlugins.indexOf(plugin) > -1) &#123; return this &#125; // additional parameters const args = toArray(arguments, 1) args.unshift(this) if (typeof plugin.install === 'function') &#123; plugin.install.apply(plugin, args) &#125; else if (typeof plugin === 'function') &#123; plugin.apply(null, args) &#125; installedPlugins.push(plugin) return this &#125; 首先定义了一个变量installedPlugins,该变量初始值是一个空数组，用来存储已安装过的插件。首先判断传入的插件是否存在于installedPlugins数组中（即已被安装过），如果存在的话，则直接返回，防止重复安装。 接下来获取到传入的其余参数，并且使用toArray方法将其转换成数组，同时将Vue插入到该数组的第一个位置，这是因为在后续调用install方法时，Vue必须作为第一个参数传入。 传入的插件可以是一个提供了 install 方法的对象。也可以是一个函数，那么这个函数会被作为 install 方法。所以在接下来会根据这两种不同的情况分别处理。 首先，判断传入的插件如果是一个提供了 install 方法的对象，那么就执行该对象中提供的 install 方法并传入参数完成插件安装。 如果传入的插件是一个函数，那么就把这个函数当作install方法执行，同时传入参数完成插件安装。 插件安装完成之后，将该插件添加进已安装插件列表中，防止重复安装。 Vue.mixinVue.mixin( mixin ) 参数 {Object} mixin 作用全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混入，向组件注入自定义的行为。不推荐在应用代码中使用。 原理分析该API是用来向全局注册一个混入，即可以修改Vue.options属性，并且会影响之后的所有Vue实例，这个API虽然在日常的业务开发中几乎用不到，但是在编写Vue插件时用处非常大。下面我们就来看一下该API的内部实现原理。 Vue.mixin = function (mixin: Object) &#123; this.options = mergeOptions(this.options, mixin) return this &#125; 该API就是通过修改Vue.options属性进而影响之后的所有Vue实例。所以我们只需将传入的mixin对象与this.options合并即可，然后将合并后的新对象作为this.options传给之后的所有Vue实例，从而达到改变其原有特性的效果。 Vue.compileVue.compile( template ) 参数 {string} template 作用在 render 函数中编译模板字符串。只在独立构建时有效 var res = Vue.compile('&lt;div>&lt;span>&#123;&#123; msg &#125;&#125;&lt;/span>&lt;/div>') new Vue(&#123; data: &#123; msg: 'hello' &#125;, render: res.render, staticRenderFns: res.staticRenderFns &#125;) 原理分析该API是用来编译模板字符串的，我们在日常业务开发中几乎用不到，它内部是调用了compileToFunctions方法 Vue.compile = compileToFunctions; Vue.observableVue.observable( object ) 参数 {Object} object 用法让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象。返回的对象可以直接用于渲染函数和计算属性内，并且会在发生改变时触发相应的更新。也可以作为最小化的跨组件状态存储器，用于简单的场景：const state = Vue.observable(&#123; count: 0 &#125;) const Demo = &#123; render(h) &#123; return h('button', &#123; on: &#123; click: () => &#123; state.count++ &#125;&#125; &#125;, `count is: $&#123;state.count&#125;`) &#125; &#125; 原理分析从用法回顾中可以知道，该API是用来将一个普通对象转化成响应式对象。在日常业务开发中也几乎用不到，它内部是调用了observe方法，关于该方法在数据变化侦测篇已经做了非常详细的介绍，此处不再重复。 Vue.versionVue.version 细节: 提供字符串形式的 Vue 安装版本号。这对社区的插件和组件来说非常有用，你可以根据不同的版本号采取不同的策略。 用法var version = Number(Vue.version.split('.')[0]) if (version === 2) &#123; // Vue v2.x.x &#125; else if (version === 1) &#123; // Vue v1.x.x &#125; else &#123; // Unsupported versions of Vue &#125; 从用法回顾中可以知道，该API是用来标识当前构建的Vue.js的版本号，对于日常业务开发几乎用不到，但是对于插件编写非常有用，可以根据Vue版本的不同从而做一些不同的事情。 该API是在构建时读取了package.json中的version字段，然后将其赋值给Vue.version。","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://example.com/tags/vue2-0/"}]},{"title":"vue生命周期销毁阶段","slug":"vue/vue-生命周期-销毁阶段","date":"2021-07-31T16:00:00.000Z","updated":"2021-07-30T08:38:48.534Z","comments":true,"path":"2021/08/01/vue/vue-生命周期-销毁阶段/","link":"","permalink":"http://example.com/2021/08/01/vue/vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E9%94%80%E6%AF%81%E9%98%B6%E6%AE%B5/","excerpt":"","text":"当调用了vm.$destroy方法，Vue实例就进入了销毁阶段，该阶段所做的主要工作是将当前的Vue实例从其父级实例中删除，取消当前实例上的所有依赖追踪并且移除实例上的所有事件监听器。也就是说，当这个阶段完成之后，当前的Vue实例的整个生命流程就全部走完了 销毁阶段分析当调用了实例的$destroy方法之后，当前实例就进入了销毁阶段。所以分析销毁阶段就是分析$destroy方法的内部实现。该方法的定义位于源码的src/core/instance.lifecycle.js中，如下： Vue.prototype.$destroy = function () &#123; const vm: Component = this if (vm._isBeingDestroyed) &#123; return &#125; callHook(vm, 'beforeDestroy') vm._isBeingDestroyed = true // remove self from parent const parent = vm.$parent if (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) &#123; remove(parent.$children, vm) &#125; // teardown watchers if (vm._watcher) &#123; vm._watcher.teardown() &#125; let i = vm._watchers.length while (i--) &#123; vm._watchers[i].teardown() &#125; // remove reference from data ob // frozen object may not have observer. if (vm._data.__ob__) &#123; vm._data.__ob__.vmCount-- &#125; // call the last hook... vm._isDestroyed = true // invoke destroy hooks on current rendered tree vm.__patch__(vm._vnode, null) // fire destroyed hook callHook(vm, 'destroyed') // turn off all instance listeners. vm.$off() // remove __vue__ reference if (vm.$el) &#123; vm.$el.__vue__ = null &#125; // release circular reference (##6759) if (vm.$vnode) &#123; vm.$vnode.parent = null &#125; &#125; 首先判断当前实例的_isBeingDestroyed属性是否为true，因为该属性标志着当前实例是否处于正在被销毁的状态，如果它为true，则直接return退出函数，防止反复执行销毁逻辑。接着，触发生命周期钩子函数beforeDestroy，该钩子函数的调用标志着当前实例正式开始销毁。首先，需要将当前的Vue实例从其父级实例中删除如果当前实例有父级实例，同时该父级实例没有被销毁并且不是抽象组件，那么就将当前实例从其父级实例的$children属性中删除，即将自己从父级实例的子实例列表中删除。 把自己从父级实例的子实例列表中删除之后，接下来就开始将自己身上的依赖追踪和事件监听移除。 我们知道， 实例身上的依赖包含两部分：一部分是实例自身依赖其他数据，需要将实例自身从其他数据的依赖列表中删除；另一部分是实例内的数据对其他数据的依赖（如用户使用$watch创建的依赖），也需要从其他数据的依赖列表中删除实例内数据。所以删除依赖的时候需要将这两部分依赖都删除掉。接下来移除实例内响应式数据的引用、给当前实例上添加_isDestroyed属性来表示当前实例已经被销毁，同时将实例的VNode树设置为null，接着，触发生命周期钩子函数destroyed最后，调用实例的vm.$off方法（关于该方法在后面介绍实例方法时会详细介绍），移除实例上的所有事件监听器。","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://example.com/tags/vue2-0/"}]},{"title":"vue实例方法","slug":"vue/vue-实例方法篇","date":"2021-07-30T08:39:16.996Z","updated":"2021-08-12T07:27:00.798Z","comments":true,"path":"2021/07/30/vue/vue-实例方法篇/","link":"","permalink":"http://example.com/2021/07/30/vue/vue-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%AF%87/","excerpt":"","text":"数据相关的方法 vm.$set vm.$delete vm.$watch 事件相关的方法 vm.$on vm.$emit vm.$off vm.$once 生命周期相关的方法 vm.$mount vm.$forceUpdate vm.$nextTick vm.$destory 数据相关的方法与数据相关的实例方法有3个，分别是vm.$set、vm.$delete和vm.$watch。它们是在stateMixin函数中挂载到Vue原型上的，代码如下： import &#123;set,del&#125; from '../observer/index' // 当执行stateMixin函数后，会向Vue原型上挂载上述3个实例方法 export function stateMixin (Vue) &#123; Vue.prototype.$set = set Vue.prototype.$delete = del Vue.prototype.$watch = function (expOrFn,cb,options) &#123;&#125; &#125; vm.$watch用法vm.$watch( expOrFn, callback, [options] ) 参数 {string | Function} expOrFn {Function | Object} callback {Object} [options] {boolean} deep {boolean} immediate 返回值{Function} unwatch 用法观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。注意：在变异 (不是替换) 对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变异之前值的副本。 示例// 键路径 vm.$watch('a.b.c', function (newVal, oldVal) &#123; // 做点什么 &#125;) // 函数 vm.$watch( function () &#123; // 表达式 `this.a + this.b` 每次得出一个不同的结果时 // 处理函数都会被调用。 // 这就像监听一个未被定义的计算属性 return this.a + this.b &#125;, function (newVal, oldVal) &#123; // 做点什么 &#125; ) vm.$watch 返回一个取消观察函数，用来停止触发回调：var unwatch = vm.$watch('a', cb) // 之后取消观察 unwatch() 选项：deep为了发现对象内部值的变化，可以在选项参数中指定 deep: true 。注意监听数组的变动不需要这么做。vm.$watch('someObject', callback, &#123; deep: true &#125;) vm.someObject.nestedValue = 123 // callback is fired 选项：immediate在选项参数中指定 immediate: true 将立即以表达式的当前值触发回调：vm.$watch('a', callback, &#123; immediate: true &#125;) // 立即以 `a` 的当前值触发回调 注意在带有 immediate 选项时，你不能在第一次回调时取消侦听给定的 property。// 这会导致报错 var unwatch = vm.$watch( 'value', function () &#123; doSomething() unwatch() &#125;, &#123; immediate: true &#125; ) 如果你仍然希望在回调内部调用一个取消侦听的函数，你应该先检查其函数的可用性：var unwatch = vm.$watch( 'value', function () &#123; doSomething() if (unwatch) &#123; unwatch() &#125; &#125;, &#123; immediate: true &#125; ) 内部原理$watch的定义位于源码的src/core/instance/state.js中，如下：Vue.prototype.$watch = function (expOrFn,cb,options) &#123; const vm: Component = this if (isPlainObject(cb)) &#123; return createWatcher(vm, expOrFn, cb, options) &#125; options = options || &#123;&#125; options.user = true const watcher = new Watcher(vm, expOrFn, cb, options) if (options.immediate) &#123; cb.call(vm, watcher.value) &#125; return function unwatchFn () &#123; watcher.teardown() &#125; &#125; 在函数内部，首先判断传入的回调函数是否为一个对象，就像下面这种形式：vm.$watch( 'a.b.c', &#123; handler: function (val, oldVal) &#123; /* ... */ &#125;, deep: true &#125; ) 如果传入的回调函数是个对象，那就表明用户是把第二个参数回调函数cb和第三个参数选项options合起来传入的，此时调用createWatcher函数，该函数定义如下：function createWatcher (vm,expOrFn,handler,options) &#123; if (isPlainObject(handler)) &#123; options = handler handler = handler.handler &#125; if (typeof handler === 'string') &#123; handler = vm[handler] &#125; return vm.$watch(expOrFn, handler, options) &#125; 可以看到，该函数内部其实就是从用户合起来传入的对象中把回调函数cb和参数options剥离出来，然后再以常规的方式调用$watch方法并将剥离出来的参数穿进去接着获取到用户传入的options，如果用户没有传入则将其赋值为一个默认空对象，如下options = options || &#123;&#125; $watch方法内部会创建一个watcher实例，由于该实例是用户手动调用$watch方法创建而来的，所以给options添加user属性并赋值为true，用于区分用户创建的watcher实例和Vue内部创建的watcher实例，如下：options.user = true 接着，传入参数创建一个watcher实例，如下：const watcher = new Watcher(vm, expOrFn, cb, options) 接着判断如果用户在选项参数options中指定的immediate为true，则立即用被观察数据当前的值触发回调，如下：if (options.immediate) &#123; cb.call(vm, watcher.value) &#125; 最后返回一个取消观察函数unwatchFn，用来停止触发回调。如下：return function unwatchFn () &#123; watcher.teardown() &#125; 这个取消观察函数unwatchFn内部其实是调用了watcher实例的teardown方法，那么我们来看一下这个teardown方法是如何实现的。其代码如下：export default class Watcher &#123; constructor (/* ... */) &#123; // ... this.deps = [] &#125; teardown () &#123; let i = this.deps.length while (i--) &#123; this.deps[i].removeSub(this) &#125; &#125; &#125; 在之前介绍变化侦测篇的文章中我们说过，谁读取了数据，就表示谁依赖了这个数据，那么谁就会存在于这个数据的依赖列表中，当这个数据变化时，就会通知谁。也就是说，如果谁不想依赖这个数据了，那么只需从这个数据的依赖列表中把谁删掉即可。 在上面代码中，创建watcher实例的时候会读取被观察的数据，读取了数据就表示依赖了数据，所以watcher实例就会存在于数据的依赖列表中，同时watcher实例也记录了自己依赖了哪些数据，另外我们还说过，每个数据都有一个自己的依赖管理器dep，watcher实例记录自己依赖了哪些数据其实就是把这些数据的依赖管理器dep存放在watcher实例的this.deps = []属性中，当取消观察时即watcher实例不想依赖这些数据了，那么就遍历自己记录的这些数据的依赖管理器，告诉这些数据可以从你们的依赖列表中把我删除了。 vm.$watch( function () &#123; return this.a + this.b &#125;, function (newVal, oldVal) &#123; // 做点什么 &#125; ) 例如上面watcher实例，它观察了数据a和数据b，那么它就依赖了数据a和数据b，那么这个watcher实例就存在于数据a和数据b的依赖管理器depA和depB中，同时watcher实例的deps属性中也记录了这两个依赖管理器，即this.deps=[depA,depB]， 当取消观察时，就遍历this.deps，让每个依赖管理器调用其removeSub方法将这个watcher实例从自己的依赖列表中删除。 下面还有最后一个问题，当选项参数options中的deep属性为true时，如何实现深度观察呢？ 首先我们来看看什么是深度观察，假如有如下被观察的数据： obj = &#123; a:2 &#125; 所谓深度观察，就是当obj对象发生变化时我们会得到通知，通知当obj.a属性发生变化时我们也要能得到通知，简单的说就是观察对象内部值的变化。 在创建watcher实例的时候把obj对象内部所有的值都递归的读一遍，那么这个watcher实例就会被加入到对象内所有值的依赖列表中，之后当对象内任意某个值发生变化时就能够得到通知了。 在创建watcher实例的时候，会执行Watcher类中get方法来读取一下被观察的数据，如下： export default class Watcher &#123; constructor (/* ... */) &#123; // ... this.value = this.get() &#125; get () &#123; // ... // \"touch\" every property so they are all tracked as // dependencies for deep watching if (this.deep) &#123; traverse(value) &#125; return value &#125; &#125; 可以看到，在get方法中，如果传入的deep为true，则会调用traverse函数 vm.$setvm.$set 是全局 Vue.set 的别名，其用法相同。 用法vm.$set( target, propertyName/index, value ) 参数 {Object | Array} target {string | number} propertyName/index {any} value 返回值: 设置的值 用法向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 (比如 this.myObject.newProperty = ‘hi’) 注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象 内部原理对于object型数据，当我们向object数据里添加一对新的key/value或删除一对已有的key/value时，Vue是无法观测到的；而对于Array型数据，当我们通过数组下标修改数组中的数据时，Vue也是是无法观测到的； 正是因为存在这个问题，所以Vue设计了set和delete这两个方法来解决这一问题，下面我们就先来看看set方法的内部实现原理。 set方法的定义位于源码的src/core/observer/index.js中，如下： export function set (target, key, val)&#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; (isUndef(target) || isPrimitive(target)) ) &#123; warn(`Cannot set reactive property on undefined, null, or primitive value: $&#123;(target: any)&#125;`) &#125; if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123; target.length = Math.max(target.length, key) target.splice(key, 1, val) return val &#125; if (key in target &amp;&amp; !(key in Object.prototype)) &#123; target[key] = val return val &#125; const ob = (target: any).__ob__ if (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.' ) return val &#125; if (!ob) &#123; target[key] = val return val &#125; defineReactive(ob.value, key, val) ob.dep.notify() return val &#125; 可以看到，方法内部的逻辑并不复杂，就是根据不同的情况作出不同的处理。 首先判断在非生产环境下如果传入的target是否为undefined、null或是原始类型，如果是，则抛出警告. 接着判断如果传入的target是数组并且传入的key是有效索引的话，那么就取当前数组长度与key这两者的最大值作为数组的新长度，然后使用数组的splice方法将传入的索引key对应的val值添加进数组。这里注意一点，为什么要用splice方法呢？还记得我们在介绍Array类型数据的变化侦测方式时说过，数组的splice方法已经被我们创建的拦截器重写了，也就是说，当使用splice方法向数组内添加元素时，该元素会自动被变成响应式的. 如果传入的target不是数组，那就当做对象来处理。首先判断传入的key是否已经存在于target中，如果存在，表明这次操作不是新增属性，而是对已有的属性进行简单的修改值，那么就只修改属性值即可 接下来获取到traget的__ob__属性，我们说过，该属性是否为true标志着target是否为响应式对象，接着判断如果tragte是 Vue 实例，或者是 Vue 实例的根数据对象，则抛出警告并退出程序 接着判断如果ob属性为false，那么表明target不是一个响应式对象，那么我们只需简单给它添加上新的属性，不用将新属性转化成响应式 最后，如果target是对象，并且是响应式，那么就调用defineReactive方法将新属性值添加到target上，defineReactive方会将新属性添加完之后并将其转化成响应式，最后通知依赖更新 vm.$deletevm.$delete( target, propertyName/index ) 参数 {Object | Array} target {string | number} propertyName/index 用法删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到属性被删除的限制，但是你应该很少会使用它。 注意目标对象不能是一个 Vue 实例或 Vue 实例的根数据对象 内部原理export function del (target, key) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; (isUndef(target) || isPrimitive(target)) ) &#123; warn(`Cannot delete reactive property on undefined, null, or primitive value: $&#123;(target: any)&#125;`) &#125; if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123; target.splice(key, 1) return &#125; const ob = (target: any).__ob__ if (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.' ) return &#125; if (!hasOwn(target, key)) &#123; return &#125; delete target[key] if (!ob) &#123; return &#125; ob.dep.notify() &#125; 该方法的内部原理与set方法有几分相似，都是根据不同情况作出不同处理。 首先判断在非生产环境下如果传入的target不存在，或者target是原始值，则抛出警告 接着判断如果传入的target是数组并且传入的key是有效索引的话，就使用数组的splice方法将索引key对应的值删掉，为什么要用splice方法上文中也解释了，就是因为数组的splice方法已经被我们创建的拦截器重写了，所以使用该方法会自动通知相关依赖。 如果传入的target不是数组，那就当做对象来处理。 接下来获取到traget的__ob__属性，我们说过，该属性是否为true标志着target是否为响应式对象，接着判断如果tragte是 Vue 实例，或者是 Vue 实例的根数据对象，则抛出警告并退出程序. 接着判断传入的key是否存在于target中，如果key本来就不存在于target中，那就不用删除，直接退出程序即可 最后，如果target是对象，并且传入的key也存在于target中，那么就从target中将该属性删除，同时判断当前的target是否为响应式对象，如果是响应式对象，则通知依赖更新；如果不是，删除完后直接返回不通知更新 事件相关的方法与事件相关的实例方法有4个，分别是vm.$on、vm.$emit、vm.$off和vm.$once。它们是在eventsMixin函数中挂载到Vue原型上的 export function eventsMixin (Vue) &#123; Vue.prototype.$on = function (event, fn) &#123;&#125; Vue.prototype.$once = function (event, fn) &#123;&#125; Vue.prototype.$off = function (event, fn) &#123;&#125; Vue.prototype.$emit = function (event) &#123;&#125; &#125; vm.$onvm.$on( event, callback ) 参数 {string | Array} event (数组只在 2.2.0+ 中支持) {Function} callback 作用监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。 示例 vm.$on('test', function (msg) &#123; console.log(msg) &#125;) vm.$emit('test', 'hi') // => \"hi\" 内部原理 $on和$emit这两个方法的内部原理是设计模式中最典型的发布订阅模式，首先定义一个事件中心，通过$on订阅事件，将事件存储在事件中心里面，然后通过$emit触发事件中心里面存储的订阅事件。该方法的定义位于源码的src/core/instance/event.js中，如下： Vue.prototype.$on = function (event, fn) &#123; const vm: Component = this if (Array.isArray(event)) &#123; for (let i = 0, l = event.length; i &lt; l; i++) &#123; this.$on(event[i], fn) &#125; &#125; else &#123; (vm._events[event] || (vm._events[event] = [])).push(fn) &#125; return vm &#125; $on方法接收两个参数，第一个参数是订阅的事件名，可以是数组，表示订阅多个事件。第二个参数是回调函数，当触发所订阅的事件时会执行该回调函数。 首先，判断传入的事件名是否是一个数组，如果是数组，就表示需要一次性订阅多个事件，就遍历该数组，将数组中的每一个事件都递归调用$on方法将其作为单个事件订阅。 如果不是数组，那就当做单个事件名来处理，以该事件名作为key，先尝试在当前实例的_events属性中获取其对应的事件列表，如果获取不到就给其赋空数组为默认值，并将第二个参数回调函数添加进去。 那么问题来了，当前实例的_events属性是干嘛的呢？在介绍生命周期初始化阶段的初始化事件initEvents函数中，在该函数中，首先在当前实例上绑定了_events属性并给其赋值为空对象， export function initEvents (vm: Component) &#123; vm._events = Object.create(null) // ... &#125; 这个_events属性就是用来作为当前实例的事件中心，所有绑定在这个实例上的事件都会存储在事件中心_events属性中。 vm.$emitvm.$emit( eventName, […args] ) 参数 {string} eventName […args] 作用 触发当前实例上的事件。附加参数都会传给监听器回调。内部原理该方法接收的第一个参数是要触发的事件名，之后的附加参数都会传给被触发事件的回调函数。Vue.prototype.$emit = function (event: string): Component &#123; const vm: Component = this let cbs = vm._events[event] if (cbs) &#123; cbs = cbs.length > 1 ? toArray(cbs) : cbs const args = toArray(arguments, 1) for (let i = 0, l = cbs.length; i &lt; l; i++) &#123; try &#123; cbs[i].apply(vm, args) &#125; catch (e) &#123; handleError(e, vm, `event handler for \"$&#123;event&#125;\"`) &#125; &#125; &#125; return vm &#125; &#125; 根据传入的事件名从当前实例的_events属性（即事件中心）中获取到该事件名所对应的回调函数cbs 然后再获取传入的附加参数args 由于cbs是一个数组，所以遍历该数组，拿到每一个回调函数，执行回调函数并将附加参数args传给该回调。 vm.$offvm.$off( [event, callback] ) 参数 {string | Array} event (只在 2.2.2+ 支持数组) {Function} [callback] 作用移除自定义事件监听器。 如果没有提供参数，则移除所有的事件监听器； 如果只提供了事件，则移除该事件所有的监听器； 如果同时提供了事件与回调，则只移除这个回调的监听器内部原理通过用法回顾我们知道，该方法用来移除事件中心里面某个事件的回调函数，根据所传入参数的不同，作出不同的处理。Vue.prototype.$off = function (event, fn) &#123; const vm: Component = this // all if (!arguments.length) &#123; vm._events = Object.create(null) return vm &#125; // array of events if (Array.isArray(event)) &#123; for (let i = 0, l = event.length; i &lt; l; i++) &#123; this.$off(event[i], fn) &#125; return vm &#125; // specific event const cbs = vm._events[event] if (!cbs) &#123; return vm &#125; if (!fn) &#123; vm._events[event] = null return vm &#125; if (fn) &#123; // specific handler let cb let i = cbs.length while (i--) &#123; cb = cbs[i] if (cb === fn || cb.fn === fn) &#123; cbs.splice(i, 1) break &#125; &#125; &#125; return vm &#125; 首先，判断如果没有传入任何参数（即arguments.length为0），这就是第一种情况：如果没有提供参数，则移除所有的事件监听器。我们知道，当前实例上的所有事件都存储在事件中心_events属性中，要想移除所有的事件，那么只需把_events属性重新置为空对象即可。 判断如果传入的需要移除的事件名是一个数组，就表示需要一次性移除多个事件，那么我们只需同订阅多个事件一样，遍历该数组，然后将数组中的每一个事件都递归调用$off方法进行移除即可。 获取到需要移除的事件名在事件中心中对应的回调函数cbs 判断如果cbs不存在，那表明在事件中心从来没有订阅过该事件，那就谈不上移除该事件，直接返回，退出程序即可。 如果cbs存在，但是没有传入回调函数fn，这就是第二种情况：如果只提供了事件，则移除该事件所有的监听器。这个也不难，我们知道，在事件中心里面，一个事件名对应的回调函数是一个数组，要想移除所有的回调函数我们只需把它对应的数组设置为null即可。 如果既传入了事件名，又传入了回调函数，cbs也存在，那这就是第三种情况：如果同时提供了事件与回调，则只移除这个回调的监听器。那么我们只需遍历所有回调函数数组cbs，如果cbs中某一项与fn相同，或者某一项的fn属性与fn相同，那么就将其从数组中删除即可。 vm.$oncevm.$once( event, callback ) 参数 {string} event {Function} callback 作用监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除。 内部原理该方法的作用是先订阅事件，但是该事件只能触发一次，也就是说当该事件被触发后会立即移除。我们可以定义一个子函数，用这个子函数来替换原本订阅事件所对应的回调，也就是说当触发订阅事件时，其实执行的是这个子函数，然后再子函数内部先把该订阅移除，再执行原本的回调，以此来达到只触发一次的目的。 Vue.prototype.$once = function (event, fn) &#123; const vm: Component = this function on () &#123; vm.$off(event, on) fn.apply(vm, arguments) &#125; on.fn = fn vm.$on(event, on) return vm &#125; 可以看到，在上述代码中，被监听的事件是event，其原本对应的回调是fn，然后定义了一个子函数on。 在该函数内部，先通过$on方法订阅事件，同时所使用的回调函数并不是原本的fn而是子函数on 也就是说，当事件event被触发时，会执行子函数on 然后在子函数内部先通过$off方法移除订阅的事件，这样确保该事件不会被再次触发，接着执行原本的回调fn 另外，还有一行代码on.fn = fn是干什么的呢？上文我们说了，我们用子函数on替换了原本的订阅事件所对应的回调fn，那么在事件中心_events属性中存储的该事件名就会变成如下这个样子：vm._events = &#123; 'xxx':[on] &#125; 但是用户自己却不知道传入的fn被替换了，当用户在触发该事件之前想调用$off方法移除该事件时vm.$off('xxx',fn) 此时就会出现问题，因为在_events属性中的事件名xxx对应的回调函数列表中没有fn，那么就会移除失败。这就让用户费解了，用户明明给xxx事件传入的回调函数是fn，现在反而找不到fn导致事件移除不了了。所以，为了解决这一问题，我们需要给on上绑定一个fn属性，属性值为用户传入的回调fn，这样在使用$off移除事件的时候，$off内部会判断如果回调函数列表中某一项的fn属性与fn相同时，就可以成功移除事件了。 生命周期相关的方法与生命周期相关的实例方法有4个，分别是vm.$mount、vm.$forceUpdate、vm.$nextTick和vm.$destory。其中，$forceUpdate和$destroy方法是在lifecycleMixin函数中挂载到Vue原型上的，$nextTick方法是在renderMixin函数中挂载到Vue原型上的，而$mount方法是在跨平台的代码中挂载到Vue原型上的 export function lifecycleMixin (Vue) &#123; Vue.prototype.$forceUpdate = function () &#123;&#125; Vue.prototype.$destroy = function (fn) &#123;&#125; &#125; export function renderMixin (Vue) &#123; Vue.prototype.$nextTick = function (fn) &#123;&#125; &#125; vm.$mountvm.$mount( [elementOrSelector] ) 参数 {Element | string} [elementOrSelector] {boolean} [hydrating] 返回值: vm - 实例自身 作用如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 vm.$mount() 手动地挂载一个未挂载的实例。如果没有提供 elementOrSelector 参数，模板将被渲染为文档之外的的元素，并且你必须使用原生 DOM API把它插入文档中。这个方法返回实例自身，因而可以链式调用其它实例方法原理关于该方法的内部原理在介绍生命周期篇的模板编译阶段中已经详细分析过 vm.$forceUpdatevm.$forceUpdate() 作用迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。内部原理当调用了该方法，当前实例会立即重新渲染。 什么情况下实例会重新渲染？那就是当实例依赖的数据发生变化时，变化的数据会通知其收集的依赖列表中的依赖进行更新，在之前的文章中我们说过，收集依赖就是收集watcher，依赖更新就是watcher调用update方法更新，所以实例依赖的数据发生变化时，就会通知实例watcher去执行update方法进行更新。 那么我们就知道了，实例的重新渲染其实就是实例watcher执行了update方法。 Vue.prototype.$forceUpdate = function () &#123; const vm: Component = this if (vm._watcher) &#123; vm._watcher.update() &#125; &#125; 当前实例的_watcher属性就是该实例的watcher，所以要想让实例重新渲染，我们只需手动的去执行一下实例watcher的update方法即可 vm.$nextTickvm.$nextTick 是全局 Vue.nextTick 的别名，其用法相同。 vm.$nextTick( [callback] ) 参数 {Function} [callback] 用法将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。&lt;template> &lt;div id=\"example\">&#123;&#123;message&#125;&#125;&lt;/div> &lt;/template> &lt;script> var vm = new Vue(&#123; el: '##example', data: &#123; message: '123' &#125; &#125;) vm.message = 'new message' // 更改数据 console.log(vm.$el.innerHTML) // '123' Vue.nextTick(function () &#123; console.log(vm.$el.innerHTML) // 'new message' &#125;) &lt;/script> 在上面例子中，当我们更新了message的数据后，立即获取vm.$el.innerHTML，发现此时获取到的还是更新之前的数据：123。但是当我们使用nextTick来获取vm.$el.innerHTML时，此时就可以获取到更新后的数据了。这是为什么呢？ 这里就涉及到Vue中对DOM的更新策略了，Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个事件队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到事件队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新事件队列并执行实际 (已去重的) 工作。 在上面这个例子中，当我们通过 vm.message = ‘new message’更新数据时，此时该组件不会立即重新渲染。当刷新事件队列时，组件会在下一个事件循环“tick”中重新渲染。所以当我们更新完数据后，此时又想基于更新后的 DOM 状态来做点什么，此时我们就需要使用Vue.nextTick(callback)，把基于更新后的DOM 状态所需要的操作放入回调函数callback中，这样回调函数将在 DOM 更新完成后被调用。 Vue为什么要这么设计？为什么要异步更新DOM？这就涉及到另外一个知识：JS的运行机制。 JS的运行机制我们知道 JS 执行是单线程的，它是基于事件循环的。事件循环大致分为以下几个步骤： 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 主线程不断重复上面的第三步。 主线程的执行过程就是一个 tick，而所有的异步结果都是通过 “任务队列” 来调度。 任务队列中存放的是一个个的任务（task）。 规范中规定 task 分为两大类，分别是宏任务(macro task) 和微任务(micro task），并且每执行完一个个宏任务(macro task)后，都要去清空该宏任务所对应的微任务队列中所有的微任务(micro task），他们的执行顺序如下所示： for (macroTask of macroTaskQueue) &#123; // 1. 处理当前的宏任务 handleMacroTask(); // 2. 处理对应的所有微任务 for (microTask of microTaskQueue) &#123; handleMicroTask(microTask); &#125; &#125; 在浏览器环境中，常见的 宏任务(macro task) 有 setTimeout、MessageChannel、postMessage、setImmediate； 微任务(micro task）有MutationObsever 和 Promise.then。 内部原理nextTick 的定义位于源码的src/core/util/next-tick.js中，其大概可分为两大部分： 能力检测 根据能力检测以不同方式执行回调队列 能力检测Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。宏任务耗费的时间是大于微任务的，所以在浏览器支持的情况下，优先使用微任务。如果浏览器不支持微任务，使用宏任务；但是，各种宏任务之间也有效率的不同，需要根据浏览器的支持情况，使用不同的宏任务。 这一部分的源码如下： let microTimerFunc let macroTimerFunc let useMacroTask = false /* 对于宏任务(macro task) */ // 检测是否支持原生 setImmediate(高版本 IE 和 Edge 支持) if (typeof setImmediate !== 'undefined' &amp;&amp; isNative(setImmediate)) &#123; macroTimerFunc = () => &#123; setImmediate(flushCallbacks) &#125; &#125; // 检测是否支持原生的 MessageChannel else if (typeof MessageChannel !== 'undefined' &amp;&amp; ( isNative(MessageChannel) || // PhantomJS MessageChannel.toString() === '[object MessageChannelConstructor]' )) &#123; const channel = new MessageChannel() const port = channel.port2 channel.port1.onmessage = flushCallbacks macroTimerFunc = () => &#123; port.postMessage(1) &#125; &#125; // 都不支持的情况下，使用setTimeout else &#123; macroTimerFunc = () => &#123; setTimeout(flushCallbacks, 0) &#125; &#125; /* 对于微任务(micro task) */ // 检测浏览器是否原生支持 Promise if (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) &#123; const p = Promise.resolve() microTimerFunc = () => &#123; p.then(flushCallbacks) &#125; &#125; // 不支持的话直接指向 macro task 的实现。 else &#123; // fallback to macro microTimerFunc = macroTimerFunc &#125; 执行回调队列接下来就进入了核心函数nextTick中，如下： const callbacks = [] // 回调队列 let pending = false // 异步锁 // 执行队列中的每一个回调 function flushCallbacks () &#123; pending = false // 重置异步锁 // 防止出现nextTick中包含nextTick时出现问题，在执行回调函数队列前，提前复制备份并清空回调函数队列 const copies = callbacks.slice(0) callbacks.length = 0 // 执行回调函数队列 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() &#125; &#125; export function nextTick (cb?: Function, ctx?: Object) &#123; let _resolve // 将回调函数推入回调队列 callbacks.push(() => &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e) &#123; handleError(e, ctx, 'nextTick') &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) // 如果异步锁未锁上，锁上异步锁，调用异步函数，准备等同步函数执行完后，就开始执行回调函数队列 if (!pending) &#123; pending = true if (useMacroTask) &#123; macroTimerFunc() &#125; else &#123; microTimerFunc() &#125; &#125; // 如果没有提供回调，并且支持Promise，返回一个Promise if (!cb &amp;&amp; typeof Promise !== 'undefined') &#123; return new Promise(resolve => &#123; _resolve = resolve &#125;) &#125; &#125; 首先，先来看 nextTick函数，该函数的主要逻辑是：先把传入的回调函数 cb 推入 回调队列callbacks 数组，同时在接收第一个回调函数时，执行能力检测中对应的异步方法（异步方法中调用了回调函数队列）。最后一次性地根据 useMacroTask 条件执行 macroTimerFunc 或者是 microTimerFunc，而它们都会在下一个 tick 执行 flushCallbacks，对 callbacks 遍历，然后执行相应的回调函数这是当 nextTick 不传 cb 参数的时候，提供一个 Promise 化的调用，比如： nextTick().then(() => &#123;&#125;) 当 _resolve 函数执行，就会跳到 then 的逻辑中。 这里有两个问题需要注意： 如何保证只在接收第一个回调函数时执行异步方法？nextTick源码中使用了一个异步锁的概念，即接收第一个回调函数时，先关上锁，执行异步方法。此时，浏览器处于等待执行完同步代码就执行异步代码的情况。 执行 flushCallbacks 函数时为什么需要备份回调函数队列？执行的也是备份的回调函数队列？因为，会出现这么一种情况：nextTick 的回调函数中还使用 nextTick。如果 flushCallbacks 不做特殊处理，直接循环执行回调函数，会导致里面nextTick 中的回调函数会进入回调队列。 以上就是对 nextTick 的源码分析，我们了解到数据的变化到 DOM 的重新渲染是一个异步过程，发生在下一个 tick。当我们在实际开发中，比如从服务端接口去获取数据的时候，数据做了修改，如果我们的某些方法去依赖了数据修改后的 DOM 变化，我们就必须在 nextTick 后执行。 vm.$destoryvm.$destroy() 完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://example.com/tags/vue2-0/"}]},{"title":"vue生命周期挂载阶段","slug":"vue/vue-生命周期-挂载阶段","date":"2021-07-29T16:00:00.000Z","updated":"2021-07-30T01:25:24.160Z","comments":true,"path":"2021/07/30/vue/vue-生命周期-挂载阶段/","link":"","permalink":"http://example.com/2021/07/30/vue/vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E6%8C%82%E8%BD%BD%E9%98%B6%E6%AE%B5/","excerpt":"","text":"模板编译阶段完成之后，接下来就进入了挂载阶段，从官方文档给出的生命周期流程图中可以看到，挂载阶段所做的主要工作是创建Vue实例并用其替换el选项对应的DOM元素，同时还要开启对模板中数据（状态）的监控，当数据（状态）发生变化时通知其依赖进行视图更新。 挂载阶段分析在完整版本的$mount方法中将模板编译完成之后，会回过头去调只包含运行时版本的$mount方法进入挂载阶段，所以要想分析挂载阶段我们必须从只包含运行时版本的$mount方法入手。 只包含运行时版本的$mount代码如下： Vue.prototype.$mount = function (el,hydrating) &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined; return mountComponent(this, el, hydrating) &#125;; 可以看到，在该函数内部首先获取到el选项对应的DOM元素，然后调用mountComponent函数并将el选项对应的DOM元素传入，进入挂载阶段。 export function mountComponent (vm,el,hydrating) &#123; vm.$el = el if (!vm.$options.render) &#123; vm.$options.render = createEmptyVNode &#125; callHook(vm, 'beforeMount') let updateComponent updateComponent = () => &#123; vm._update(vm._render(), hydrating) &#125; new Watcher(vm, updateComponent, noop, &#123; before () &#123; if (vm._isMounted) &#123; callHook(vm, 'beforeUpdate') &#125; &#125; &#125;, true /* isRenderWatcher */) hydrating = false if (vm.$vnode == null) &#123; vm._isMounted = true callHook(vm, 'mounted') &#125; return vm &#125; 可以看到，在该函数中，首先会判断实例上是否存在渲染函数，如果不存在，则设置一个默认的渲染函数createEmptyVNode，该渲染函数会创建一个注释类型的VNode节点。 然后调用callHook函数来触发beforeMount生命周期钩子函数 该钩子函数触发后标志着正式开始执行挂载操作 接下来定义了一个updateComponent函数 在该函数内部，首先执行渲染函数vm._render()得到一份最新的VNode节点树，然后执行vm._update()方法对最新的VNode节点树与上一次渲染的旧VNode节点树进行对比并更新DOM节点(即patch操作)，完成一次渲染。 也就是说，如果调用了updateComponent函数，就会将最新的模板内容渲染到视图页面中，这样就完成了挂载操作的一半工作.因为在挂载阶段不但要将模板渲染到视图中，同时还要开启对模板中数据（状态）的监控，当数据（状态）发生变化时通知其依赖进行视图更新。 接下来创建了一个Watcher实例，并将定义好的updateComponent函数传入。要想开启对模板中数据（状态）的监控，这一段代码是关键， 可以看到，在创建Watcher实例的时候，传入的第二个参数是updateComponent函数。回顾一下我们在数据侦测篇文章中介绍Watcher类的时候，Watcher类构造函数的第二个参数支持两种类型：函数和数据路径（如a.b.c）。如果是数据路径，会根据路径去读取这个数据；如果是函数，会执行这个函数。一旦读取了数据或者执行了函数，就会触发数据或者函数内数据的getter方法，而在getter方法中会将watcher实例添加到该数据的依赖列表中，当该数据发生变化时就会通知依赖列表中所有的依赖，依赖接收到通知后就会调用第四个参数回调函数去更新视图。 换句话说，上面代码中把updateComponent函数作为第二个参数传给Watcher类从而创建了watcher实例，那么updateComponent函数中读取的所有数据都将被watcher所监控，这些数据中只要有任何一个发生了变化，那么watcher都将会得到通知，从而会去调用第四个参数回调函数去更新视图，如此反复，直到实例被销毁。 这样就完成了挂载阶段的另一半工作。 如此之后，挂载阶段才算是全部完成了，接下来调用挂载完成的生命周期钩子函数mounted 总结在该阶段中所做的主要工作是创建Vue实例并用其替换el选项对应的DOM元素，同时还要开启对模板中数据（状态）的监控，当数据（状态）发生变化时通知其依赖进行视图更新。 我们将挂载阶段所做的工作分成两部分进行了分析，第一部分是将模板渲染到视图上，第二部分是开启对模板中数据（状态）的监控。两部分工作都完成以后挂载阶段才算真正的完成了。","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://example.com/tags/vue2-0/"}]},{"title":"vue生命周期-模板编译","slug":"vue/vue-生命周期-模板编译","date":"2021-07-26T16:00:00.000Z","updated":"2021-07-30T01:15:08.009Z","comments":true,"path":"2021/07/27/vue/vue-生命周期-模板编译/","link":"","permalink":"http://example.com/2021/07/27/vue/vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/","excerpt":"","text":"前言在初始化阶段各项工作做完之后调用了vm.$mount方法，该方法的调用标志着初始化阶段的结束和进入下一个阶段，从官方文档给出的生命周期流程图中可以看到，下一个阶段就进入了模板编译阶段，该阶段所做的主要工作是获取到用户传入的模板内容并将其编译成渲染函数。 模板编译阶段并不是存在于Vue的所有构建版本中，它只存在于完整版（即vue.js）中。在只包含运行时版本（即vue.runtime.js）中并不存在该阶段，这是因为当使用vue-loader或vueify时，*.vue文件内部的模板会在构建时预编译成渲染函数，所以是不需要编译的，从而不存在模板编译阶段，由上一步的初始化阶段直接进入下一阶段的挂载阶段。 vue基于源码构建的有两个版本，一个是runtime only(一个只包含运行时的版本)，另一个是runtime + compiler(一个同时包含编译器和运行时的完整版本)。而两个版本的区别仅在于后者包含了一个编译器。 完整版本一个完整的Vue版本是包含编译器的，我们可以使用template选项进行模板编写。编译器会自动将template选项中的模板字符串编译成渲染函数的代码,源码中就是render函数。如果你需要在客户端编译模板 (比如传入一个字符串给 template 选项，或挂载到一个元素上并以其 DOM 内部的 HTML 作为模板)，就需要一个包含编译器的版本。 如下：// 需要编译器的版本 new Vue(&#123; template: '&lt;div>&#123;&#123; hi &#125;&#125;&lt;/div>' &#125;) 只包含运行时版本只包含运行时的版本拥有创建Vue实例、渲染并处理Virtual DOM等功能，基本上就是除去编译器外的完整代码。该版本的适用场景有两种： 我们在选项中通过手写render函数去定义渲染过程，这个时候并不需要包含编译器的版本便可完整执行。// 不需要编译器 new Vue(&#123; render (h) &#123; return h('div', this.hi) &#125; &#125;) 借助vue-loader这样的编译工具进行编译，当我们利用webpack进行Vue的工程化开发时，常常会利用vue-loader对*.vue文件进行编译，尽管我们也是利用template模板标签去书写代码，但是此时的Vue已经不需要利用编译器去负责模板的编译工作了，这个过程交给了插件去实现。 很明显，编译过程对性能会造成一定的损耗，并且由于加入了编译的流程代码，Vue代码的总体积也更加庞大(运行时版本相比完整版体积要小大约 30%)。因此在实际开发中，我们需要借助像webpack的vue-loader这类工具进行编译，将Vue对模板的编译阶段合并到webpack的构建流程中，这样不仅减少了生产环境代码的体积，也大大提高了运行时的性能，一举两得。 模板编译阶段分析完整版和只包含运行时版之间的差异主要在于是否有模板编译阶段，而是否有模板编译阶段主要表现在vm.$mount方法的实现上。 两种$mount方法对比只包含运行时版本的$mount代码如下： Vue.prototype.$mount = function (el,hydrating) &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined; return mountComponent(this, el, hydrating) &#125;; 在该版本中的$mount方法内部获取到el选项对应的DOM元素后直接调用mountComponent函数进行挂载操作. 而完整版本的$mount代码如下： var mount = Vue.prototype.$mount; Vue.prototype.$mount = function (el,hydrating) &#123; // 省略获取模板及编译代码 return mount.call(this, el, hydrating) &#125; 注意，在完整版本的$mount定义之前，先将Vue原型上的$mount方法先缓存起来，记作变量mount。此时你可能会问了，这$mount方法还没定义呢，怎么先缓存起来了。 其实在源码中，是先定义只包含运行时版本的$mount方法，再定义完整版本的$mount方法，所以此时缓存的mount变量就是只包含运行时版本的$mount方法。 为什么要这么做呢？上文我们说了，完整版本和只包含运行时版本之间的差异主要在于是否有模板编译阶段，只包含运行时版本没有模板编译阶段，初始化阶段完成后直接进入挂载阶段，而完整版本是初始化阶段完成后进入模板编译阶段，然后再进入挂载阶段。也就是说，这两个版本最终都会进入挂载阶段。所以在完整版本的$mount方法中将模板编译完成后需要回头去调只包含运行时版本的$mount方法以进入挂载阶段。 这也就是在完整版本的$mount方法中先把只包含运行时版本的$mount方法缓存下来，记作变量mount，然后等模板编译完成，再执行mount方法（即只包含运行时版本的$mount方法）。 所以分析模板编译阶段其实就是分析完整版的vm.$mount方法的实现。 完整版的vm.$mount方法分析完整版的vm.$mount方法定义位于源码的dist/vue.js中，如下： var mount = Vue.prototype.$mount; Vue.prototype.$mount = function (el,hydrating) &#123; el = el &amp;&amp; query(el); if (el === document.body || el === document.documentElement) &#123; warn( \"Do not mount Vue to &lt;html> or &lt;body> - mount to normal elements instead.\" ); return this &#125; var options = this.$options; // resolve template/el and convert to render function if (!options.render) &#123; var template = options.template; if (template) &#123; if (typeof template === 'string') &#123; if (template.charAt(0) === '#') &#123; template = idToTemplate(template); /* istanbul ignore if */ if (!template) &#123; warn( (\"Template element not found or is empty: \" + (options.template)), this ); &#125; &#125; &#125; else if (template.nodeType) &#123; template = template.innerHTML; &#125; else &#123; &#123; warn('invalid template option:' + template, this); &#125; return this &#125; &#125; else if (el) &#123; template = getOuterHTML(el); &#125; if (template) &#123; if (config.performance &amp;&amp; mark) &#123; mark('compile'); &#125; var ref = compileToFunctions(template, &#123; outputSourceRange: \"development\" !== 'production', shouldDecodeNewlines: shouldDecodeNewlines, shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments &#125;, this); var render = ref.render; var staticRenderFns = ref.staticRenderFns; options.render = render; options.staticRenderFns = staticRenderFns; if (config.performance &amp;&amp; mark) &#123; mark('compile end'); measure((\"vue \" + (this._name) + \" compile\"), 'compile', 'compile end'); &#125; &#125; &#125; return mount.call(this, el, hydrating) &#125;; 从代码中可以看到，该函数可大致分为三部分： 根据传入的el参数获取DOM元素； 在用户没有手写render函数的情况下获取传入的模板template； 将获取到的template编译成render函数； 首先，根据传入的el参数获取DOM元素。 由于el参数可以是元素，也可以是字符串类型的元素选择器，所以调用query函数来获取到el对应的DOM元素。query函数比较简单，就是根据传入的el参数是否为字符串从而以不同方式获取到对应的DOM元素. 另外，这里还多了一个判断，就是判断获取到el对应的DOM元素如果是body或html元素时，将会抛出警告。这是因为Vue会将模板中的内容替换el对应的DOM元素，如果是body或html元素时，替换之后将会破坏整个DOM文档，所以不允许el是body或html。 接着，在用户没有手写render函数的情况下获取传入的模板template 首先获取用户传入的template选项赋给变量template，如果变量template存在，则接着判断如果template是字符串并且以##开头，则认为template是id选择符，则调用idToTemplate函数获取到选择符对应的DOM元素的innerHTML作为模板if (template) &#123; if (typeof template === 'string') &#123; if (template.charAt(0) === '#') &#123; template = idToTemplate(template); &#125; &#125; &#125; var idToTemplate = cached(function (id) &#123; var el = query(id); return el &amp;&amp; el.innerHTML &#125;); 如果template不是字符串，那就判断它是不是一个DOM元素，如果是，则使用该DOM元素的innerHTML作为模板.if (template.nodeType) &#123; template = template.innerHTML; &#125; 如果既不是字符串，也不是DOM元素，此时会抛出警告：提示用户template选项无效。 如果变量template不存在，表明用户没有传入template选项，则根据传入的el参数调用getOuterHTML函数获取外部模板。不管是从内部的template选项中获取模板，还是从外部获取模板，总之就是要获取到用户传入的模板内容，有了模板内容接下来才能将模板编译成渲染函数。 接下来要做的事就是将其编译成渲染函数if (template) &#123; var ref = compileToFunctions(template, &#123; outputSourceRange: \"development\" !== 'production', shouldDecodeNewlines: shouldDecodeNewlines, shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments &#125;, this); var render = ref.render; var staticRenderFns = ref.staticRenderFns; options.render = render; options.staticRenderFns = staticRenderFns; &#125; 把模板编译成渲染函数是在compileToFunctions函数中进行的，该函数接收待编译的模板字符串和编译选项作为参数，返回一个对象，对象里面的render属性即是编译好的渲染函数，最后将渲染函数设置到$options上。 Vue源码构建的两种版本：完整版本和只包含运行时版本。并且我们知道了模板编译阶段只存在于完整版中，在只包含运行时版本中不存在该阶段，这是因为在只包含运行时版本中，当使用vue-loader或vueify时，.vue文件内部的模板会在构建时预编译成渲染函数，所以是不需要编译的，从而不存在模板编译阶段。然后对比了两种版本$mount方法的区别。它们的区别在于在$mount方法中是否进行了模板编译。在只包含运行时版本的$mount方法中获取到DOM元素后直接进入挂载阶段，而在完整版本的$mount方法中是先将模板进行编译，然后回过头调只包含运行时版本的$mount方法进入挂载阶段。最后，我们知道了分析模板编译阶段其实就是分析完整版的vm.$mount方法的实现，我们将完整版的vm.$mount方法源码进行了逐行分析。知道了在该阶段中所做的工作就是：从用户传入的el选项和template选项中获取到用户传入的内部或外部模板，然后将获取到的模板编译成渲染函数。","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://example.com/tags/vue2-0/"}]},{"title":"vue生命周期-初始化阶段","slug":"vue/vue-生命周期-初始化阶段","date":"2021-07-25T16:00:00.000Z","updated":"2021-07-27T01:33:26.070Z","comments":true,"path":"2021/07/26/vue/vue-生命周期-初始化阶段/","link":"","permalink":"http://example.com/2021/07/26/vue/vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5/","excerpt":"","text":"new Vue()初始化阶段所做的第一件事就是new Vue()创建一个Vue实例，那么new Vue()的内部都干了什么呢？ 我们知道，new 关键字在 JS中表示从一个类中实例化出一个对象来，由此可见， Vue 实际上是一个类。所以new Vue()实际上是执行了Vue类的构造函数 做了什么function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options) &#125; 可以看到，Vue类的定义非常简单，其构造函数核心就一行代码：this._init(options) 调用原型上的_init(options)方法并把用户所写的选项options传入。那这个_init方法是从哪来的呢？ initMixin(Vue) 这一行代码执行了initMixin函数，那initMixin函数又是从哪儿来的呢？该函数定义位于源码的src/core/instance/init.js 中，如下： export function initMixin (Vue) &#123; Vue.prototype._init = function (options) &#123; const vm = this vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ) vm._self = vm initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, 'beforeCreate') initInjections(vm) // resolve injections before data/props initState(vm) initProvide(vm) // resolve provide after data/props callHook(vm, 'created') if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125; &#125; &#125; 可以看到，在initMixin函数内部就只干了一件事，那就是给Vue类的原型上绑定_init方法，同时_init方法的定义也在该函数内部。现在我们知道了，new Vue()会执行Vue类的构造函数，构造函数内部会执行_init方法，所以new Vue()所干的事情其实就是_init方法所干的事情，那么我们着重来分析下_init方法都干了哪些事情。 首先，把Vue实例赋值给变量vm，并且把用户传递的options选项与当前构造函数的options属性及其父级构造函数的options属性进行合并（关于属性如何合并的问题下面会介绍），得到一个新的options选项赋值给$options属性，并将$options属性挂载到Vue实例上，如下： vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ) 接着，通过调用一些初始化函数来为Vue实例初始化一些属性，事件，响应式数据等，如下： initLifecycle(vm) // 初始化生命周期 initEvents(vm) // 初始化事件 initRender(vm) // 初始化渲染 callHook(vm, 'beforeCreate') // 调用生命周期钩子函数 initInjections(vm) //初始化injections initState(vm) // 初始化props,methods,data,computed,watch initProvide(vm) // 初始化 provide callHook(vm, 'created') // 调用生命周期钩子函数 可以看到，除了调用初始化函数来进行相关数据的初始化之外，还在合适的时机调用了callHook函数来触发生命周期的钩子，关于callHook函数是如何触发生命周期的钩子会在下面介绍，我们先继续往下看： if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125; callHook函数如何触发钩子函数export function callHook (vm: Component, hook: string) &#123; const handlers = vm.$options[hook] // 要执行的钩子函数 if (handlers) &#123; for (let i = 0, j = handlers.length; i &lt; j; i++) &#123; try &#123; handlers[i].call(vm) // 执行钩子函数中的每一个方法 &#125; catch (e) &#123; handleError(e, vm, `$&#123;hook&#125; hook`) &#125; &#125; &#125; &#125; 首先从实例的$options中获取到需要触发的钩子名称所对应的钩子函数数组handlers，每个生命周期钩子名称都对应了一个钩子函数数组。然后遍历该数组，将数组中的每个钩子函数都执行一遍。 initLifecycle函数export function initLifecycle (vm: Component) &#123; const options = vm.$options let parent = options.parent if (parent &amp;&amp; !options.abstract) &#123; while (parent.$options.abstract &amp;&amp; parent.$parent) &#123; parent = parent.$parent &#125; parent.$children.push(vm) &#125; vm.$parent = parent vm.$root = parent ? parent.$root : vm vm.$children = [] vm.$refs = &#123;&#125; vm._watcher = null vm._inactive = null vm._directInactive = false vm._isMounted = false vm._isDestroyed = false vm._isBeingDestroyed = false &#125; 主要是给Vue实例上挂载了一些属性并设置了默认值，同时挂载$parent 属性和$root属性 首先是给实例上挂载$parent属性： let parent = options.parent if (parent &amp;&amp; !options.abstract) &#123; while (parent.$options.abstract &amp;&amp; parent.$parent) &#123; parent = parent.$parent &#125; parent.$children.push(vm) &#125; vm.$parent = parent 如果当前组件不是抽象组件并且存在父级，那么就通过while循环来向上循环，如果当前组件的父级是抽象组件并且也存在父级，那就继续向上查找当前组件父级的父级，直到找到第一个不是抽象类型的父级时，将其赋值vm.$parent，同时把该实例自身添加进找到的父级的$children属性中。这样就确保了在子组件的$parent属性上能访问到父组件实例，在父组件的$children属性上也能访问子组件的实例 接着是给实例上挂载$root属性 vm.$root = parent ? parent.$root : vm 实例的$root属性表示当前实例的根实例，挂载该属性时，首先会判断如果当前实例存在父级，那么当前实例的根实例$root属性就是其父级的根实例$root属性，如果不存在，那么根实例$root属性就是它自己。这很好理解，举个例子：假如有一个人，他如果有父亲，那么他父亲的祖先肯定也是他的祖先，同理，他的儿子的祖先也肯定是他的祖先，我们不需要真正的一层一层的向上递归查找到他祖先本人，只需要知道他父亲的祖先是谁然后告诉他即可。如果他没有父亲，那说明他自己就是祖先，那么他后面的儿子、孙子的$root属性就是他自己了 解析事件 initEvents在Vue中，当我们在父组件中使用子组件时可以给子组件上注册一些事件，这些事件即包括使用v-on或@注册的自定义事件，也包括注册的浏览器原生事件（需要加 .native 修饰符），如下： &lt;child @select=\"selectHandler\" @click.native=\"clickHandler\">&lt;/child> 模板编译解析中，当遇到开始标签的时候，除了会解析开始标签，还会调用processAttrs 方法解析标签中的属性，processAttrs 方法位于源码的 src/compiler/parser/index.js中， 如下： export const onRE = /^@|^v-on:/ export const dirRE = /^v-|^@|^:/ function processAttrs (el) &#123; const list = el.attrsList let i, l, name, value, modifiers for (i = 0, l = list.length; i &lt; l; i++) &#123; name = list[i].name value = list[i].value if (dirRE.test(name)) &#123; // 解析修饰符 modifiers = parseModifiers(name) if (modifiers) &#123; name = name.replace(modifierRE, '') &#125; if (onRE.test(name)) &#123; // v-on name = name.replace(onRE, '') addHandler(el, name, value, modifiers, false, warn) &#125; &#125; &#125; &#125; 在对标签属性进行解析时，判断如果属性是指令，首先通过 parseModifiers 解析出属性的修饰符，然后判断如果是事件的指令，则执行 addHandler(el, name, value, modifiers, false, warn) 方法， 该方法定义在 src/compiler/helpers.js 中，如下： export function addHandler (el,name,value,modifiers) &#123; modifiers = modifiers || emptyObject // check capture modifier 判断是否有capture修饰符 if (modifiers.capture) &#123; delete modifiers.capture name = '!' + name // 给事件名前加'!'用以标记capture修饰符 &#125; // 判断是否有once修饰符 if (modifiers.once) &#123; delete modifiers.once name = '~' + name // 给事件名前加'~'用以标记once修饰符 &#125; // 判断是否有passive修饰符 if (modifiers.passive) &#123; delete modifiers.passive name = '&amp;' + name // 给事件名前加'&amp;'用以标记passive修饰符 &#125; let events if (modifiers.native) &#123; delete modifiers.native events = el.nativeEvents || (el.nativeEvents = &#123;&#125;) &#125; else &#123; events = el.events || (el.events = &#123;&#125;) &#125; const newHandler: any = &#123; value: value.trim() &#125; if (modifiers !== emptyObject) &#123; newHandler.modifiers = modifiers &#125; const handlers = events[name] if (Array.isArray(handlers)) &#123; handlers.push(newHandler) &#125; else if (handlers) &#123; events[name] = [handlers, newHandler] &#125; else &#123; events[name] = newHandler &#125; el.plain = false &#125; 在addHandler 函数里做了 3 件事情，首先根据 modifier 修饰符对事件名 name 做处理，接着根据 modifier.native 判断事件是一个浏览器原生事件还是自定义事件，分别对应 el.nativeEvents 和 el.events，最后按照 name 对事件做归类，并把回调函数的字符串保留到对应的事件中。 initInjections从函数名字上来看，该函数是用来初始化实例中的inject选项的。说到inject选项，那必然离不开provide选项，这两个选项都是成对出现的，它们的作用是：允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。 export function initInjections (vm: Component) &#123; const result = resolveInject(vm.$options.inject, vm) if (result) &#123; toggleObserving(false) Object.keys(result).forEach(key => &#123; defineReactive(vm, key, result[key]) &#125; toggleObserving(true) &#125; &#125; export let shouldObserve: boolean = true export function toggleObserving (value: boolean) &#123; shouldObserve = value &#125; 首先调用resolveInject把inject选项中的数据转化成键值对的形式赋给result，如官方文档给出的例子，那么result应为如下样子： // 父级组件提供 'foo' var Parent = &#123; provide: &#123; foo: 'bar' &#125; &#125; // 子组件注入 'foo' var Child = &#123; inject: ['foo'], &#125; // result result = &#123; 'foo':'bar' &#125; 然后遍历result中的每一对键值，调用defineReactive函数将其添加当前实例上，如下： if (result) &#123; toggleObserving(false) Object.keys(result).forEach(key => &#123; defineReactive(vm, key, result[key]) &#125; toggleObserving(true) &#125; 此处有一个地方需要注意，在把result中的键值添加到当前实例上之前，会先调用toggleObserving(false)，而这个函数内部是把shouldObserve = false，这是为了告诉defineReactive函数仅仅是把键值添加到当前实例上而不需要将其转换成响应式，这个就呼应了官方文档在介绍provide 和 inject 选项用法的时候所提示的： provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。 resolveInject export function resolveInject (inject: any, vm: Component): ?Object &#123; if (inject) &#123; const result = Object.create(null) const keys = Object.keys(inject) for (let i = 0; i &lt; keys.length; i++) &#123; const key = keys[i] const provideKey = inject[key].from let source = vm while (source) &#123; if (source._provided &amp;&amp; hasOwn(source._provided, provideKey)) &#123; result[key] = source._provided[provideKey] break &#125; source = source.$parent &#125; if (!source) &#123; if ('default' in inject[key]) &#123; const provideDefault = inject[key].default result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault &#125; else if (process.env.NODE_ENV !== 'production') &#123; warn(`Injection \"$&#123;key&#125;\" not found`, vm) &#125; &#125; &#125; return result &#125; &#125; initState 初始化实例状态从函数名字上来看，这个函数是用来初始化实例状态的,在Vue组件中会写一些如props、data、methods、computed、watch选项，我们把这些选项称为实例的状态选项。也就是说，initState函数就是用来初始化这些状态的。 export function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options if (opts.props) initProps(vm, opts.props) if (opts.methods) initMethods(vm, opts.methods) if (opts.data) &#123; initData(vm) &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125; &#125; 首先，给实例上新增了一个属性_watchers，用来存储当前实例中所有的watcher实例，无论是使用vm.$watch注册的watcher实例还是使用watch选项注册的watcher实例，都会被保存到该属性中。 这里我们再额外多说一点，在变化侦测篇中我们介绍了Vue中对数据变化的侦测是使用属性拦截的方式实现的，但是Vue并不是对所有数据都使用属性拦截的方式侦测变化，这是因为数据越多，数据上所绑定的依赖就会多，从而造成依赖追踪的内存开销就会很大，所以从Vue 2.0版本起，Vue不再对所有数据都进行侦测，而是将侦测粒度提高到了组件层面，对每个组件进行侦测，所以在每个组件上新增了vm._watchers属性，用来存放这个组件内用到的所有状态的依赖，当其中一个状态发生变化时，就会通知到组件，然后由组件内部使用虚拟DOM进行数据比对，从而降低内存开销，提高性能。 先判断实例中是否有props选项，如果有，就调用props选项初始化函数initProps去初始化props选项； 再判断实例中是否有methods选项，如果有，就调用methods选项初始化函数initMethods去初始化methods选项； 接着再判断实例中是否有data选项，如果有，就调用data选项初始化函数initData去初始化data选项；如果没有，就把data当作空对象并将其转换成响应式； 接着再判断实例中是否有computed选项，如果有，就调用computed选项初始化函数initComputed去初始化computed选项； 最后判断实例中是否有watch选项，如果有，就调用watch选项初始化函数initWatch去初始化watch选项； 总之一句话就是：有什么选项就调用对应的选项初始化子函数去初始化什么选项。 初始化propsprops选项通常是由当前组件的父级组件传入的，当父组件在调用子组件的时候，通常会把props属性值作为标签属性添加在子组件的标签上，如下： &lt;Child prop1=\"xxx\" prop2=\"yyy\">&lt;/Child> 在模板编译的时候，当解析到组件标签时会将所有的标签属性都解析出来然后在子组件实例化的时候传给子组件，当然这里面就包括props数据。 子组件接受： // 写法一 props: ['name'] // 写法二 props: &#123; name: String, // [String, Number] &#125; // 写法三 props: &#123; name:&#123; type: String &#125; &#125; Vue给用户提供的props选项写法非常自由，写法虽多但是最终处理的时候肯定只处理一种写法，将所有写法都转化成一种写法。 function normalizeProps (options, vm) &#123; const props = options.props if (!props) return const res = &#123;&#125; let i, val, name if (Array.isArray(props)) &#123; i = props.length while (i--) &#123; val = props[i] if (typeof val === 'string') &#123; name = camelize(val) res[name] = &#123; type: null &#125; &#125; else if (process.env.NODE_ENV !== 'production') &#123; warn('props must be strings when using array syntax.') &#125; &#125; &#125; else if (isPlainObject(props)) &#123; for (const key in props) &#123; val = props[key] name = camelize(key) res[name] = isPlainObject(val) ? val : &#123; type: val &#125; &#125; &#125; else if (process.env.NODE_ENV !== 'production') &#123; warn( `Invalid value for option \"props\": expected an Array or an Object, ` + `but got $&#123;toRawType(props)&#125;.`, vm ) &#125; options.props = res &#125; 上面代码中，首先拿到实例中的props选项，如果不存在，则直接返回。 如果存在，则定义一个空对象res，用来存储最终的结果。接着判断如果props选项是一个数组（写法一），则遍历该数组中的每一项元素，如果该元素是字符串，那么先将该元素统一转化成驼峰式命名，然后将该元素作为key，将{type: null}作为value存入res中；如果该元素不是字符串，则抛出异常。 如果props选项不是数组那就继续判断是不是一个对象，如果是一个对象，那就遍历对象中的每一对键值，拿到每一对键值后，先将键名统一转化成驼峰式命名，然后判断值是否还是一个对象，如果值是对象（写法三），那么就将该键值对存入res中；如果值不是对象（写法二），那么就将键名作为key，将{type: null}作为value存入res中。 如果props选项既不是数组也不是对象，那么如果在非生产环境下就抛出异常，最后将res作为规范化后的结果重新赋值给实例的props选项。 无论是三种写法的哪一种，最终都会被转化成如下写法： props: &#123; name:&#123; type: xxx &#125; &#125; initProps函数分析将props选项规范化完成之后，接下来我们就可以来真正的初始化props选项了，initProps函数的定义位于源码的src/core/instance/state.js中，如下： function initProps (vm: Component, propsOptions: Object) &#123; const propsData = vm.$options.propsData || &#123;&#125; const props = vm._props = &#123;&#125; // cache prop keys so that future props updates can iterate using Array // instead of dynamic object key enumeration. const keys = vm.$options._propKeys = [] const isRoot = !vm.$parent // root instance props should be converted if (!isRoot) &#123; toggleObserving(false) &#125; for (const key in propsOptions) &#123; keys.push(key) const value = validateProp(key, propsOptions, propsData, vm) /* istanbul ignore else */ if (process.env.NODE_ENV !== 'production') &#123; const hyphenatedKey = hyphenate(key) if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) &#123; warn( `\"$&#123;hyphenatedKey&#125;\" is a reserved attribute and cannot be used as component prop.`, vm ) &#125; defineReactive(props, key, value, () => &#123; if (vm.$parent &amp;&amp; !isUpdatingChildComponent) &#123; warn( `Avoid mutating a prop directly since the value will be ` + `overwritten whenever the parent component re-renders. ` + `Instead, use a data or computed property based on the prop's ` + `value. Prop being mutated: \"$&#123;key&#125;\"`, vm ) &#125; &#125;) &#125; else &#123; defineReactive(props, key, value) &#125; // static props are already proxied on the component's prototype // during Vue.extend(). We only need to proxy props defined at // instantiation here. if (!(key in vm)) &#123; proxy(vm, `_props`, key) &#125; &#125; toggleObserving(true) &#125; 可以看到，该函数接收两个参数：当前Vue实例和当前实例规范化后的props选项。在函数内部首先定义了4个变量： propsData:父组件传入的真实props数据。 props:指向vm._props的指针，所有设置到props变量中的属性都会保存到vm._props中。 keys:指向vm.$options._propKeys的指针，缓存props对象中的key，将来更新props时只需遍历vm.$options._propKeys数组即可得到所有props的key。 isRoot:当前组件是否为根组件。 接着，判断当前组件是否为根组件，如果不是，那么不需要将props数组转换为响应式的，toggleObserving(false)用来控制是否将数据转换成响应式。 接着，遍历props选项拿到每一对键值，先将键名添加到keys中，然后调用validateProp函数（关于该函数下面会介绍）校验父组件传入的props数据类型是否匹配并获取到传入的值value，然后将键和值通过defineReactive函数添加到props（即vm._props）中。 添加完之后再判断这个key在当前实例vm中是否存在，如果不存在，则调用proxy函数在vm上设置一个以key为属性的代码，当使用vm[key]访问数据时，其实访问的是vm._props[key]。 validateProp函数分析export function validateProp (key,propOptions,propsData,vm) &#123; const prop = propOptions[key] const absent = !hasOwn(propsData, key) let value = propsData[key] // boolean casting const booleanIndex = getTypeIndex(Boolean, prop.type) if (booleanIndex > -1) &#123; if (absent &amp;&amp; !hasOwn(prop, 'default')) &#123; value = false &#125; else if (value === '' || value === hyphenate(key)) &#123; // only cast empty string / same name to boolean if // boolean has higher priority const stringIndex = getTypeIndex(String, prop.type) if (stringIndex &lt; 0 || booleanIndex &lt; stringIndex) &#123; value = true &#125; &#125; &#125; // check default value if (value === undefined) &#123; value = getPropDefaultValue(vm, prop, key) // since the default value is a fresh copy, // make sure to observe it. const prevShouldObserve = shouldObserve toggleObserving(true) observe(value) toggleObserving(prevShouldObserve) &#125; if (process.env.NODE_ENV !== 'production') &#123; assertProp(prop, key, value, vm, absent) &#125; return value &#125; 可以看到，该函数接收4个参数，分别是： key:遍历propOptions时拿到的每个属性名。 propOptions:当前实例规范化后的props选项。 propsData:父组件传入的真实props数据。 vm:当前实例。 在函数内部首先定义了3个变量，分别是： prop:当前key在propOptions中对应的值。 absent:当前key是否在propsData中存在，即父组件是否传入了该属性。 value:当前key在propsData中对应的值，即父组件对于该属性传入的真实值。 接着，判断prop的type属性是否是布尔类型（Boolean）,getTypeIndex函数用于判断prop的type属性中是否存在某种类型，如果存在，则返回该类型在type属性中的索引（因为type属性可以是数组），如果不存在则返回-1。 如果是布尔类型的话，那么有两种边界情况需要单独处理： 如果absent为true，即父组件没有传入该prop属性并且该属性也没有默认值的时候，将该属性值设置为false，如下： if (absent &amp;&amp; !hasOwn(prop, 'default')) &#123; value = false &#125; 如果父组件传入了该prop属性，那么需要满足以下几点： 该属性值为空字符串或者属性值与属性名相等； prop的type属性中不存在String类型； 如果prop的type属性中存在String类型，那么Boolean类型在type属性中的索引必须小于String类型的索引，即Boolean类型的优先级更高;则将该属性值设置为true，如下：if (value === '' || value === hyphenate(key)) &#123; const stringIndex = getTypeIndex(String, prop.type) if (stringIndex &lt; 0 || booleanIndex &lt; stringIndex) &#123; value = true &#125; &#125; 另外，在判断属性值与属性名相等的时候，是先将属性名由驼峰式转换成用-连接的字符串，下面的这几种写法，子组件的prop都将被设置为true： &lt;Child name>&lt;/Child> &lt;Child name=\"name\">&lt;/Child> &lt;Child userName=\"user-name\">&lt;/Child> 如果不是布尔类型，是其它类型的话，那就只需判断父组件是否传入该属性即可，如果没有传入，则该属性值为undefined，此时调用getPropDefaultValue函数（关于该函数下面会介绍）获取该属性的默认值，并将其转换成响应式，如下： if (value === undefined) &#123; value = getPropDefaultValue(vm, prop, key) // since the default value is a fresh copy, // make sure to observe it. const prevShouldObserve = shouldObserve toggleObserving(true) observe(value) toggleObserving(prevShouldObserve) &#125; 如果父组件传入了该属性并且也有对应的真实值，那么在非生产环境下会调用assertProp函数（关于该函数下面会介绍）校验该属性值是否与要求的类型相匹配。如下： if (process.env.NODE_ENV !== 'production' ) &#123; assertProp(prop, key, value, vm, absent) &#125; 最后将父组件传入的该属性的真实值返回。 初始化methods它的初始化函数定义位于源码的src/core/instance/state.js中，如下： function initMethods (vm, methods) &#123; const props = vm.$options.props for (const key in methods) &#123; if (process.env.NODE_ENV !== 'production') &#123; if (methods[key] == null) &#123; warn( `Method \"$&#123;key&#125;\" has an undefined value in the component definition. ` + `Did you reference the function correctly?`, vm ) &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; warn( `Method \"$&#123;key&#125;\" has already been defined as a prop.`, vm ) &#125; if ((key in vm) &amp;&amp; isReserved(key)) &#123; warn( `Method \"$&#123;key&#125;\" conflicts with an existing Vue instance method. ` + `Avoid defining component methods that start with _ or $.` ) &#125; &#125; vm[key] = methods[key] == null ? noop : bind(methods[key], vm) &#125; &#125; 初始化methods无非就干了三件事：判断method有没有？method的命名符不符合命名规范？如果method既有又符合规范那就把它挂载到vm实例上。下面我们就逐行分析源码，来过一遍这三件事。 首先，遍历methods选项中的每一个对象，在非生产环境下判断如果methods中某个方法只有key而没有value，即只有方法名没有方法体时，抛出异常：提示用户方法未定义。接着判断如果methods中某个方法名与props中某个属性名重复了，就抛出异常：提示用户方法名重复了。接着判断如果methods中某个方法名如果在实例vm中已经存在并且方法名是以_或$开头的，就抛出异常：提示用户方法名命名不规范。（其中，isReserved函数是用来判断字符串是否以_或$开头）最后，如果上述判断都没问题，那就method绑定到实例vm上，这样，我们就可以通过this.xxx来访问methods选项中的xxx方法了，如下： vm[key] = methods[key] == null ? noop : bind(methods[key], vm) 初始化data它的初始化函数定义位于源码的src/core/instance/state.js中，如下： function initData (vm) &#123; let data = vm.$options.data data = vm._data = typeof data === 'function' ? getData(data, vm) : data || &#123;&#125; if (!isPlainObject(data)) &#123; data = &#123;&#125; process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html##data-Must-Be-a-Function', vm ) &#125; // proxy data on instance const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) &#123; const key = keys[i] if (process.env.NODE_ENV !== 'production') &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( `Method \"$&#123;key&#125;\" has already been defined as a data property.`, vm ) &#125; &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `The data property \"$&#123;key&#125;\" is already declared as a prop. ` + `Use prop default value instead.`, vm ) &#125; else if (!isReserved(key)) &#123; proxy(vm, `_data`, key) &#125; &#125; // observe data observe(data, true /* asRootData */) &#125; 跟initMethods函数的逻辑有几分相似。就是通过一系列条件判断用户传入的data选项是否合法，最后将data转换成响应式并绑定到实例vm上。下面我们就来仔细看一下代码逻辑。 首先获取到用户传入的data选项，赋给变量data，同时将变量data作为指针指向vm._data，然后判断data是不是一个函数，如果是就调用getData函数获取其返回值，将其保存到vm._data中。如果不是，就将其本身保存到vm._data中。 let data = vm.$options.data data = vm._data = typeof data === 'function' ? getData(data, vm) : data || &#123;&#125; 我们知道，无论传入的data选项是不是一个函数，它最终的值都应该是一个对象，如果不是对象的话，就抛出警告：提示用户data应该是一个对象。 if (!isPlainObject(data)) &#123; data = &#123;&#125; process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html##data-Must-Be-a-Function', vm ) &#125; 接下来遍历data对象中的每一项，在非生产环境下判断data对象中是否存在某一项的key与methods中某个属性名重复，如果存在重复，就抛出警告：提示用户属性名重复。 if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( &#96;Method &quot;$&#123;key&#125;&quot; has already been defined as a data property.&#96;, vm ) &#125; &#125; 接着再判断是否存在某一项的key与prop中某个属性名重复，如果存在重复，就抛出警告：提示用户属性名重复。 if (props &amp;&amp; hasOwn(props, key)) &#123; process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; warn( &#96;The data property &quot;$&#123;key&#125;&quot; is already declared as a prop. &#96; + &#96;Use prop default value instead.&#96;, vm ) &#125; 如果都没有重复，则调用proxy函数将data对象中key不以_或$开头的属性代理到实例vm上，这样，我们就可以通过this.xxx来访问data选项中的xxx数据了。 最后，调用observe函数将data中的数据转化成响应式. observe(data, true /* asRootData */) 初始化computed计算属性computed相信大家一定不会陌生，在日常开发中肯定会经常用到，而且我们知道计算属性有一个很大的特点就是： 计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。首先，根据官方文档的使用示例，我们来回顾一下计算属性的用法: var vm = new Vue(&#123; data: &#123; a: 1 &#125;, computed: &#123; // 仅读取 aDouble: function () &#123; return this.a * 2 &#125;, // 读取和设置 aPlus: &#123; get: function () &#123; return this.a + 1 &#125;, set: function (v) &#123; this.a = v - 1 &#125; &#125; &#125; &#125;) vm.aPlus // => 2 vm.aPlus = 3 vm.a // => 2 vm.aDouble // => 4 computed选项中的属性值可以是一个函数，那么该函数默认为取值器getter，用于仅读取数据；还可以是一个对象，对象里面有取值器getter和存值器setter，用于读取和设置数据。 initComputed函数分析initComputed函数的定义位于源码的src/core/instance/state.js中，如下： function initComputed (vm: Component, computed: Object) &#123; const watchers = vm._computedWatchers = Object.create(null) const isSSR = isServerRendering() for (const key in computed) &#123; const userDef = computed[key] const getter = typeof userDef === 'function' ? userDef : userDef.get if (process.env.NODE_ENV !== 'production' &amp;&amp; getter == null) &#123; warn( `Getter is missing for computed property \"$&#123;key&#125;\".`, vm ) &#125; if (!isSSR) &#123; // create internal watcher for the computed property. watchers[key] = new Watcher( vm, getter || noop, noop, computedWatcherOptions ) &#125; if (!(key in vm)) &#123; defineComputed(vm, key, userDef) &#125; else if (process.env.NODE_ENV !== 'production') &#123; if (key in vm.$data) &#123; warn(`The computed property \"$&#123;key&#125;\" is already defined in data.`, vm) &#125; else if (vm.$options.props &amp;&amp; key in vm.$options.props) &#123; warn(`The computed property \"$&#123;key&#125;\" is already defined as a prop.`, vm) &#125; &#125; &#125; &#125; 可以看到，在函数内部，首先定义了一个变量watchers并将其赋值为空对象，同时将其作为指针指向vm._computedWatchers接着，遍历computed选项中的每一项属性，首先获取到每一项的属性值，记作userDef，然后判断userDef是不是一个函数，如果是函数，则该函数默认为取值器getter，将其赋值给变量getter；如果不是函数，则说明是一个对象，则取对象中的get属性作为取值器赋给变量getter。接着判断在非生产环境下如果上面两种情况取到的取值器不存在，则抛出警告：提示用户计算属性必须有取值器。接着判断如果不是在服务端渲染环境下，则创建一个watcher实例，并将当前循环到的的属性名作为键，创建的watcher实例作为值存入watchers对象中。最后，判断当前循环到的的属性名是否存在于当前实例vm上，如果存在，则在非生产环境下抛出警告；如果不存在，则调用defineComputed函数为实例vm上设置计算属性。 初始化watch根据官方文档的使用示例，我们来回顾一下watch选项的用法: var vm = new Vue(&#123; data: &#123; a: 1, b: 2, c: 3, d: 4, e: &#123; f: &#123; g: 5 &#125; &#125; &#125;, watch: &#123; a: function (val, oldVal) &#123; console.log('new: %s, old: %s', val, oldVal) &#125;, // methods选项中的方法名 b: 'someMethod', // 深度侦听，该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深 c: &#123; handler: function (val, oldVal) &#123; /* ... */ &#125;, deep: true &#125;, // 该回调将会在侦听开始之后被立即调用 d: &#123; handler: 'someMethod', immediate: true &#125;, // 调用多个回调 e: [ 'handle1', function handle2 (val, oldVal) &#123; /* ... */ &#125;, &#123; handler: function handle3 (val, oldVal) &#123; /* ... */ &#125;, &#125; ], // 侦听表达式 'e.f': function (val, oldVal) &#123; /* ... */ &#125; &#125; &#125;) vm.a = 2 // => new: 2, old: 1 watch选项的用法非常灵活。首先watch选项是一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。既然给用户提供的用法灵活，那么在代码中就需要按条件来判断，根据不同的用法做相应的处理。 initWatch函数分析function initWatch (vm, watch) &#123; for (const key in watch) &#123; const handler = watch[key] if (Array.isArray(handler)) &#123; for (let i = 0; i &lt; handler.length; i++) &#123; createWatcher(vm, key, handler[i]) &#125; &#125; else &#123; createWatcher(vm, key, handler) &#125; &#125; &#125; 可以看到，在函数内部会遍历watch选项，拿到每一项的key和对应的值handler。然后判断handler是否为数组，如果是数组则循环该数组并将数组中的每一项依次调用createWatcher函数来创建watcher；如果不是数组，则直接调用createWatcher函数来创建watcher。 createWatcher函数分析function createWatcher ( vm: Component, expOrFn: string | Function, handler: any, options?: Object ) &#123; if (isPlainObject(handler)) &#123; options = handler handler = handler.handler &#125; if (typeof handler === 'string') &#123; handler = vm[handler] &#125; return vm.$watch(expOrFn, handler, options) &#125; 可以看到，该函数接收4个参数，分别是： vm:当前实例； expOrFn:被侦听的属性表达式 handler:watch选项中每一项的值 options:用于传递给vm.$watch的选项对象 在该函数内部，首先会判断传入的handler是否为一个对象，如果是一个对象，那么就认为用户使用的是这种写法： watch: &#123; c: &#123; handler: function (val, oldVal) &#123; /* ... */ &#125;, deep: true &#125; &#125; 即带有侦听选项的写法，此时就将handler对象整体记作options，把handler对象中的handler属性作为真正的回调函数记作handler，如下： if (isPlainObject(handler)) &#123; options = handler handler = handler.handler &#125; 接着判断传入的handler是否为一个字符串，如果是一个字符串，那么就认为用户使用的是这种写法： watch: &#123; // methods选项中的方法名 b: 'someMethod', &#125; 即回调函数是methods选项中的一个方法名，我们知道，在初始化methods选项的时候会将选项中的每一个方法都绑定到当前实例上，所以此时我们只需从当前实例上取出该方法作为真正的回调函数记作handler，如下： if (typeof handler === 'string') &#123; handler = vm[handler] &#125; 如果既不是对象又不是字符串，那么我们就认为它是一个函数，就不做任何处理。","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://example.com/tags/vue2-0/"}]},{"title":"vue生命周期综述","slug":"vue/vue-生命周期综述","date":"2021-07-24T16:00:00.000Z","updated":"2022-06-15T03:17:01.751Z","comments":true,"path":"2021/07/25/vue/vue-生命周期综述/","link":"","permalink":"http://example.com/2021/07/25/vue/vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%BC%E8%BF%B0/","excerpt":"","text":"在Vue中，把Vue实例从被创建出来到最终被销毁的这一过程称为Vue实例的生命周期，同时，在Vue实例生命周期的不同阶段Vue还提供了不同的钩子函数，以方便用户在不同的生命周期阶段做一些额外的事情 初始化阶段：为Vue实例上初始化一些属性，事件以及响应式数据； 模板编译阶段：将模板编译成渲染函数； 挂载阶段：将实例挂载到指定的DOM上，即将模板渲染到真实DOM中； 销毁阶段：将实例自身从父组件中删除，并取消依赖追踪及事件监听器；","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://example.com/tags/vue2-0/"}]},{"title":"vue模板编译-模板解析","slug":"vue/vue-模板编译-模板解析","date":"2021-07-23T16:00:00.000Z","updated":"2021-07-23T09:48:56.630Z","comments":true,"path":"2021/07/24/vue/vue-模板编译-模板解析/","link":"","permalink":"http://example.com/2021/07/24/vue/vue-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91-%E6%A8%A1%E6%9D%BF%E8%A7%A3%E6%9E%90/","excerpt":"","text":"整体流程在模板解析阶段主要做的工作是把用户在标签内写的模板使用正则等方式解析成抽象语法树（AST）。而这一阶段在源码中对应解析器（parser）模块。 解析器，顾名思义，就是把用户所写的模板根据一定的解析规则解析出有效的信息，最后用这些信息形成AST。我们知道在模板内，除了有常规的HTML标签外，用户还会一些文本信息以及在文本信息中包含过滤器。而这些不同的内容在解析起来肯定需要不同的解析规则，所以解析器不可能只有一个，它应该除了有解析常规HTML的HTML解析器，还应该有解析文本的文本解析器以及解析文本中如果包含过滤器的过滤器解析器。 另外，文本信息和标签属性信息却又是存在于HTML标签之内的，所以在解析整个模板的时候它的流程应该是这样子的：HTML解析器是主线，先用HTML解析器进行解析整个模板，在解析过程中如果碰到文本内容，那就调用文本解析器来解析文本，如果碰到文本中包含过滤器那就调用过滤器解析器来解析。如下图所示： // 代码位置：/src/complier/parser/index.js /** * Convert HTML string to AST. */ export function parse(template, options) &#123; // ... parseHTML(template, &#123; warn, expectHTML: options.expectHTML, isUnaryTag: options.isUnaryTag, canBeLeftOpenTag: options.canBeLeftOpenTag, shouldDecodeNewlines: options.shouldDecodeNewlines, shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref, shouldKeepComment: options.comments, start (tag, attrs, unary) &#123; &#125;, end () &#123; &#125;, chars (text: string) &#123; &#125;, comment (text: string) &#123; &#125; &#125;) return root &#125; parse 函数就是解析器的主函数，在parse 函数内调用了parseHTML 函数对模板字符串进行解析，在parseHTML 函数解析模板字符串的过程中，如果遇到文本信息，就会调用文本解析器parseText函数进行文本解析；如果遇到文本中包含过滤器，就会调用过滤器解析器parseFilters函数进行解析 总结模板解析其实就是根据被解析内容的特点使用正则等方式将有效信息解析提取出来，根据解析内容的不同分为HTML解析器，文本解析器和过滤器解析器。而文本信息与过滤器信息又存在于HTML标签中，所以在解析器主线函数parse中先调用HTML解析器parseHTML 函数对模板字符串进行解析，如果在解析过程中遇到文本或过滤器信息则再调用相应的解析器进行解析，最终完成对整个模板字符串的解析 最终目的就是：把用户所写的模板转化成供Vue实例在挂载时可调用的render函数。或者你可以这样简单的理解为：模板编译就是一台机器，给它输入模板字符串，它就输出对应的render函数。","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://example.com/tags/vue2-0/"}]},{"title":"diff算法","slug":"vue/vue-diff算法","date":"2021-07-22T16:00:00.000Z","updated":"2021-07-23T09:48:56.630Z","comments":true,"path":"2021/07/23/vue/vue-diff算法/","link":"","permalink":"http://example.com/2021/07/23/vue/vue-diff%E7%AE%97%E6%B3%95/","excerpt":"","text":"创建节点 删除节点 更新节点 patch在Vue中，把 DOM-Diff过程叫做patch过程。patch,意为“补丁”，即指对旧的VNode修补，打补丁从而得到新的VNode，非常形象哈。那不管叫什么，其本质都是把对比新旧两份VNode的过程。我们在下面研究patch过程的时候，一定把握住这样一个思想：所谓旧的VNode(即oldVNode)就是数据变化之前视图所对应的虚拟DOM节点，而新的VNode是数据变化之后将要渲染的新的视图所对应的虚拟DOM节点，所以我们要以生成的新的VNode为基准，对比旧的oldVNode，如果新的VNode上有的节点而旧的oldVNode上没有，那么就在旧的oldVNode上加上去；如果新的VNode上没有的节点而旧的oldVNode上有，那么就在旧的oldVNode上去掉；如果某些节点在新的VNode和旧的oldVNode上都有，那么就以新的VNode为准，更新旧的oldVNode，从而让新旧VNode相同。总体来说就是以新的标准，多的加上去，少的删掉，将老的改成新的 创建节点 判断是否为元素节点只需判断该VNode节点是否有tag标签即可。如果有tag属性即认为是元素节点，则调用createElement方法创建元素节点，通常元素节点还会有子节点，那就递归遍历创建所有子节点，将所有子节点创建好之后insert插入到当前元素节点里面，最后把当前元素节点插入到DOM中。 判断是否为注释节点，只需判断VNode的isComment属性是否为true即可，若为true则为注释节点，则调用createComment方法创建注释节点，再插入到DOM中。 如果既不是元素节点，也不是注释节点，那就认为是文本节点，则调用createTextNode方法创建文本节点，再插入到DOM中。// 源码位置: /src/core/vdom/patch.js function createElm (vnode, parentElm, refElm) &#123; const data = vnode.data const children = vnode.children const tag = vnode.tag if (isDef(tag)) &#123; vnode.elm = nodeOps.createElement(tag, vnode) // 创建元素节点 createChildren(vnode, children, insertedVnodeQueue) // 创建元素节点的子节点 insert(parentElm, vnode.elm, refElm) // 插入到DOM中 &#125; else if (isTrue(vnode.isComment)) &#123; vnode.elm = nodeOps.createComment(vnode.text) // 创建注释节点 insert(parentElm, vnode.elm, refElm) // 插入到DOM中 &#125; else &#123; vnode.elm = nodeOps.createTextNode(vnode.text) // 创建文本节点 insert(parentElm, vnode.elm, refElm) // 插入到DOM中 &#125; &#125; 删除节点如果某些节点再新的VNode中没有而在旧的oldVNode中有，那么就需要把这些节点从旧的oldVNode中删除。删除节点非常简单，只需在要删除节点的父元素上调用removeChild方法即可。源码如下： function removeNode (el) &#123; const parent = nodeOps.parentNode(el) // 获取父节点 if (isDef(parent)) &#123; nodeOps.removeChild(parent, el) // 调用父节点的removeChild方法 &#125; &#125; 更新节点更新节点就是当某些节点在新的VNode和旧的oldVNode中都有时，我们就需要细致比较一下，找出不一样的地方进行更新。 如果VNode和oldVNode均为静态节点,我们说了，静态节点无论数据发生任何变化都与它无关，所以都为静态节点的话则直接跳过，无需处理。 &lt;p>我是不会变化的文字&lt;/p> 如果VNode是文本节点如果VNode是文本节点即表示这个节点内只包含纯文本，那么只需看oldVNode是否也是文本节点，如果是，那就比较两个文本是否不同，如果不同则把oldVNode里的文本改成跟VNode的文本一样。如果oldVNode不是文本节点，那么不论它是什么，直接调用setTextNode方法把它改成文本节点，并且文本内容跟VNode相同。 如果VNode是元素节点如果VNode是元素节点，则又细分以下两种情况 该节点包含子节点如果新的节点内包含了子节点，那么此时要看旧的节点是否包含子节点，如果旧的节点里也包含了子节点，那就需要递归对比更新子节点；如果旧的节点里不包含子节点，那么这个旧节点有可能是空节点或者是文本节点，如果旧的节点是空节点就把新的节点里的子节点创建一份然后插入到旧的节点里面，如果旧的节点是文本节点，则把文本清空，然后把新的节点里的子节点创建一份然后插入到旧的节点里面。 该节点不包含子节点如果该节点不包含子节点，同时它又不是文本节点，那就说明该节点是个空节点，那就好办了，不管旧节点之前里面都有啥，直接清空即可。// 更新节点 function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) &#123; // vnode与oldVnode是否完全一样？若是，退出程序 if (oldVnode === vnode) &#123; return &#125; const elm = vnode.elm = oldVnode.elm // vnode与oldVnode是否都是静态节点？若是，退出程序 if (isTrue(vnode.isStatic) &amp;&amp; isTrue(oldVnode.isStatic) &amp;&amp; vnode.key === oldVnode.key &amp;&amp; (isTrue(vnode.isCloned) || isTrue(vnode.isOnce)) ) &#123; return &#125; const oldCh = oldVnode.children const ch = vnode.children // vnode有text属性？若没有： if (isUndef(vnode.text)) &#123; // vnode的子节点与oldVnode的子节点是否都存在？ if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123; // 若都存在，判断子节点是否相同，不同则更新子节点 if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly) &#125; // 若只有vnode的子节点存在 else if (isDef(ch)) &#123; /** * 判断oldVnode是否有文本？ * 若没有，则把vnode的子节点添加到真实DOM中 * 若有，则清空Dom中的文本，再把vnode的子节点添加到真实DOM中 */ if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '') addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue) &#125; // 若只有oldnode的子节点存在 else if (isDef(oldCh)) &#123; // 清空DOM中的子节点 removeVnodes(elm, oldCh, 0, oldCh.length - 1) &#125; // 若vnode和oldnode都没有子节点，但是oldnode中有文本 else if (isDef(oldVnode.text)) &#123; // 清空oldnode文本 nodeOps.setTextContent(elm, '') &#125; // 上面两个判断一句话概括就是，如果vnode中既没有text，也没有子节点，那么对应的oldnode中有什么就清空什么 &#125; // 若有，vnode的text属性与oldVnode的text属性是否相同？ else if (oldVnode.text !== vnode.text) &#123; // 若不相同：则用vnode的text替换真实DOM的文本 nodeOps.setTextContent(elm, vnode.text) &#125; &#125; 总结Vue中的DOM-Diff算法：patch过程。patch过程干了三件事，分别是：创建节点，删除节点，更新节点。","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://example.com/tags/vue2-0/"}]},{"title":"vue模板编译","slug":"vue/vue-模板编译","date":"2021-07-22T16:00:00.000Z","updated":"2021-07-23T09:48:56.630Z","comments":true,"path":"2021/07/23/vue/vue-模板编译/","link":"","permalink":"http://example.com/2021/07/23/vue/vue-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/","excerpt":"","text":"模板编译把用户在标签中写的类似于原生HTML的内容进行编译，把原生HTML的内容找出来，再把非原生HTML找出来，经过一系列的逻辑处理生成渲染函数，也就是render函数的这一段过程称之为模板编译过程 整体渲染流程 模板编译内部流程抽象语法树AST抽象语法树，在计算机科学中，抽象语法树（AbstractSyntaxTree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现；而类似于if-condition-then这样的条件跳转语句，可以使用带有两个分支的节点来表示 具体流程 模板解析阶段：将一堆模板字符串用正则等方式解析成抽象语法树AST； 优化阶段：遍历AST，找出其中的静态节点，并打上标记； 代码生成阶段：将AST转换成渲染函数； export const createCompiler = createCompilerCreator(function baseCompile ( template: string, options: CompilerOptions ): CompiledResult &#123; // 模板解析阶段：用正则等方式解析 template 模板中的指令、class、style等数据，形成AST const ast = parse(template.trim(), options) if (options.optimize !== false) &#123; // 优化阶段：遍历AST，找出其中的静态节点，并打上标记； optimize(ast, options) &#125; // 代码生成阶段：将AST转换成渲染函数； const code = generate(ast, options) return &#123; ast, render: code.render, staticRenderFns: code.staticRenderFns &#125; &#125;) 总结大致分为三个阶段，分别是模板解析阶段、优化阶段和代码生成阶段","categories":[],"tags":[{"name":"vue.2.0","slug":"vue-2-0","permalink":"http://example.com/tags/vue-2-0/"}]},{"title":"vue虚拟dom","slug":"vue/vue-虚拟dom","date":"2021-07-21T16:00:00.000Z","updated":"2021-07-23T09:48:56.630Z","comments":true,"path":"2021/07/22/vue/vue-虚拟dom/","link":"","permalink":"http://example.com/2021/07/22/vue/vue-%E8%99%9A%E6%8B%9Fdom/","excerpt":"","text":"虚拟DOM简介什么是虚拟dom所谓虚拟DOM，就是用一个JS对象来描述一个DOM节点，像如下示例: &lt;div class=\"a\" id=\"b\">我是内容&lt;/div> &#123; tag:'div', // 元素标签 attrs:&#123; // 属性 class:'a', id:'b' &#125;, text:'我是内容', // 文本内容 children:[] // 子元素 &#125; 为什么要有虚拟DOM？我们知道，Vue是数据驱动视图的，数据发生变化视图就要随之更新，在更新视图的时候难免要操作DOM,而操作真实DOM又是非常耗费性能的，这是因为浏览器的标准就把 DOM 设计的非常复杂，所以一个真正的 DOM 元素是非常庞大的，如下所示： let div = document.createElement('div') let str = '' for (const key in div) &#123; str += key + '' &#125; console.log(str) // 结果是非常长的 在页面直接操作一个dom是非常消耗新能的、所以我们再操作dom之前使用js模拟一个虚拟dom，在数据发生变化的时候通过新老虚拟dom进行比较（diff算法），从而直接更新需要改变的视图。 Vue中的虚拟DOMVNode类虚拟DOM就是用JS来描述一个真实的DOM节点。而在Vue中就存在了一个VNode类，通过这个类，我们就可以实例化出不同类型的虚拟DOM节点，源码如下 // 源码位置：src/core/vdom/vnode.js export default class VNode &#123; constructor ( tag?: string, data?: VNodeData, children?: ?Array&lt;VNode>, text?: string, elm?: Node, context?: Component, componentOptions?: VNodeComponentOptions, asyncFactory?: Function ) &#123; this.tag = tag /*当前节点的标签名*/ this.data = data /*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/ this.children = children /*当前节点的子节点，是一个数组*/ this.text = text /*当前节点的文本*/ this.elm = elm /*当前虚拟节点对应的真实dom节点*/ this.ns = undefined /*当前节点的名字空间*/ this.context = context /*当前组件节点对应的Vue实例*/ this.fnContext = undefined /*函数式组件对应的Vue实例*/ this.fnOptions = undefined this.fnScopeId = undefined this.key = data &amp;&amp; data.key /*节点的key属性，被当作节点的标志，用以优化*/ this.componentOptions = componentOptions /*组件的option选项*/ this.componentInstance = undefined /*当前节点对应的组件的实例*/ this.parent = undefined /*当前节点的父节点*/ this.raw = false /*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/ this.isStatic = false /*静态节点标志*/ this.isRootInsert = true /*是否作为跟节点插入*/ this.isComment = false /*是否为注释节点*/ this.isCloned = false /*是否为克隆节点*/ this.isOnce = false /*是否有v-once指令*/ this.asyncFactory = asyncFactory this.asyncMeta = undefined this.isAsyncPlaceholder = false &#125; get child (): Component | void &#123; return this.componentInstance &#125; &#125; 从上面的代码中可以看出：VNode类中包含了描述一个真实DOM节点所需要的一系列属性，如tag表示节点的标签名，text表示节点中包含的文本，children表示该节点包含的子节点等。通过属性之间不同的搭配，就可以描述出各种类型的真实DOM节点。 VNode的类型 注释节点 文本节点 元素节点 组件节点 函数式组件节点 克隆节点 VNode的作用我们在视图渲染之前，把写好的template模板先编译成VNode并缓存下来，等到数据发生变化页面需要重新渲染的时候，我们把数据发生变化后生成的VNode与前一次缓存下来的VNode进行对比，找出差异，然后有差异的VNode对应的真实DOM节点就是需要重新渲染的节点，最后根据有差异的VNode创建出真实的DOM节点再插入到视图中，最终完成一次视图更新 总结本章首先介绍了虚拟DOM的一些基本概念和为什么要有虚拟DOM，其实说白了就是以JS的计算性能来换取操作真实DOM所消耗的性能。接着从源码角度我们知道了在Vue中是通过VNode类来实例化出不同类型的虚拟DOM节点，并且学习了不同类型节点生成的属性的不同，所谓不同类型的节点其本质还是一样的，都是VNode类的实例，只是在实例化时传入的属性参数不同罢了。最后探究了VNode的作用，有了数据变化前后的VNode，我们才能进行后续的DOM-Diff找出差异，最终做到只更新有差异的视图，从而达到尽可能少的操作真实DOM的目的，以节省性能","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://example.com/tags/vue2-0/"}]},{"title":"async、await","slug":"js/async、await","date":"2021-07-20T16:00:00.000Z","updated":"2021-07-23T09:48:56.630Z","comments":true,"path":"2021/07/21/js/async、await/","link":"","permalink":"http://example.com/2021/07/21/js/async%E3%80%81await/","excerpt":"","text":"async 和 await 在干什么任意一个名称都是有意义的，先从字面意思来理解。async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。 async这个问题的关键在于，async 函数是怎么处理它的返回值的！我们当然希望它能直接通过 return 语句返回我们想要的值，但是如果真是这样，似乎就没 await 什么事了。所以，写段代码来试试，看它到底会返回什么： async function testAsync() &#123; return \"hello async\"; &#125; const result = testAsync(); console.log(result); // Promise &#123; 'hello async' &#125; ——输出的是一个 Promise 对象。 所以，async 函数返回的是一个 Promise 对象。从文档中也可以得到这个信息。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。 Promise.resolve(x) 可以看作是 new Promise(resolve =&gt; resolve(x)) 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。 async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，我们当然应该用原来的方式：then() 链来处理这个 Promise 对象，就像这样 testAsync().then(v => &#123; console.log(v); // 输出 hello async &#125;); await一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。 因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行 function getSomething() &#123; return \"something\"; &#125; async function testAsync() &#123; return Promise.resolve(\"hello async\"); &#125; async function test() &#123; const v1 = await getSomething(); const v2 = await testAsync(); console.log(v1, v2); &#125; test(); await 等到了要等的，然后呢await 等到了它要等的东西，一个 Promise 对象，或者其它值，然后呢？我不得不先说，await 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西。 如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。 如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。 async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。 async/await -&gt; promisefunction step1(n) &#123; console.log(`step1 with $&#123;n&#125;`); return takeLongTime(n); &#125; function step2(m, n) &#123; console.log(`step2 with $&#123;m&#125; and $&#123;n&#125;`); return takeLongTime(m + n); &#125; function step3(k, m, n) &#123; console.log(`step3 with $&#123;k&#125;, $&#123;m&#125; and $&#123;n&#125;`); return takeLongTime(k + m + n); &#125; // asyne/await async function doIt() &#123; console.time(\"doIt\"); const time1 = 300; const time2 = await step1(time1); const time3 = await step2(time1, time2); const result = await step3(time1, time2, time3); console.log(`result is $&#123;result&#125;`); console.timeEnd(\"doIt\"); &#125; doIt(); // promise function doIt() &#123; console.time(\"doIt\"); const time1 = 300; step1(time1) .then(time2 => &#123; return step2(time1, time2) .then(time3 => [time1, time2, time3]); &#125;) .then(times => &#123; const [time1, time2, time3] = times; return step3(time1, time2, time3); &#125;) .then(result => &#123; console.log(`result is $&#123;result&#125;`); console.timeEnd(\"doIt\"); &#125;); &#125; doIt(); 看起来更像是同步操作","categories":[],"tags":[{"name":"异步","slug":"异步","permalink":"http://example.com/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"vue双向绑定原理","slug":"vue/vue-双向绑定原理","date":"2021-07-20T16:00:00.000Z","updated":"2021-07-23T09:48:56.630Z","comments":true,"path":"2021/07/21/vue/vue-双向绑定原理/","link":"","permalink":"http://example.com/2021/07/21/vue/vue-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/","excerpt":"","text":"Vue双向绑定分为两个部分：对象和数组 object双向绑定原理实现方式 通过Object.defineProperty()定义一个observer类，将正常的object转换成一个可观测的object，并且加上了_ob_属性，如果读取了会通过触发get，如果改变了会触发set // 源码位置：src/core/observer/index.js /** * Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象 */ export class Observer &#123; constructor (value) &#123; this.value = value // 给value新增一个__ob__属性，值为该value的Observer实例 // 相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作 def(value,'__ob__',this) if (Array.isArray(value)) &#123; // 当value为数组时的逻辑 // ... &#125; else &#123; this.walk(value) &#125; &#125; walk (obj: Object) &#123; const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]) &#125; &#125; &#125; /** * 使一个对象转化成可观测对象 * @param &#123; Object &#125; obj 对象 * @param &#123; String &#125; key 对象的key * @param &#123; Any &#125; val 对象的某个key的值 */ function defineReactive (obj,key,val) &#123; // 如果只传了obj和key，那么val = obj[key] if (arguments.length === 2) &#123; val = obj[key] &#125; if(typeof val === 'object')&#123; new Observer(val) &#125; Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get()&#123; console.log(`$&#123;key&#125;属性被读取了`); return val; &#125;, set(newVal)&#123; if(val === newVal)&#123; return &#125; console.log(`$&#123;key&#125;属性被修改了`); val = newVal; &#125; &#125;) &#125; 收集依赖，也就是收集那里用到了这个数据的。具体做法是定义一个dep类，其实就是一个数组，那里用到了就在数据里面push进去。dep里面有几个方法，在observer的get里面depend负责收集依赖（其实就是Watcher），在set里面notify通知所有依赖更新（通知的也是Watcher，最后由Watcher通知视图更新） // 源码位置：src/core/observer/dep.js export default class Dep &#123; constructor () &#123; this.subs = [] &#125; addSub (sub) &#123; this.subs.push(sub) &#125; // 删除一个依赖 removeSub (sub) &#123; remove(this.subs, sub) &#125; // 添加一个依赖 depend () &#123; if (window.target) &#123; this.addSub(window.target) &#125; &#125; // 通知所有依赖更新 notify () &#123; const subs = this.subs.slice() for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125; &#125; /** * Remove an item from an array */ export function remove (arr, item) &#123; if (arr.length) &#123; const index = arr.indexOf(item) if (index > -1) &#123; return arr.splice(index, 1) &#125; &#125; &#125; Watcher类，Watcher先把自己设置到全局唯一的指定位置（window.target），然后读取数据。因为读取了数据，所以会触发这个数据的getter。接着，在getter中就会从全局唯一的那个位置读取当前正在读取数据的Watcher，并把这个watcher收集到Dep中去。收集好之后，当数据发生变化时，会向Dep中的每个Watcher发送通知。通过这样的方式，Watcher可以主动去订阅任意一个数据的变化。 export default class Watcher &#123; constructor (vm,expOrFn,cb) &#123; this.vm = vm; this.cb = cb; this.getter = parsePath(expOrFn) this.value = this.get() &#125; get () &#123; window.target = this; const vm = this.vm let value = this.getter.call(vm, vm) window.target = undefined; return value &#125; update () &#123; const oldValue = this.value this.value = this.get() this.cb.call(this.vm, this.value, oldValue) &#125; &#125; /** * Parse simple path. * 把一个形如'data.a.b.c'的字符串路径所表示的值，从真实的data对象中取出来 * 例如： * data = &#123;a:&#123;b:&#123;c:2&#125;&#125;&#125; * parsePath('a.b.c')(data) // 2 */ const bailRE = /[^\\w.$]/ export function parsePath (path) &#123; if (bailRE.test(path)) &#123; return &#125; const segments = path.split('.') return function (obj) &#123; for (let i = 0; i &lt; segments.length; i++) &#123; if (!obj) return obj = obj[segments[i]] &#125; return obj &#125; &#125; 总结Data通过observer转换成了getter/setter的形式来追踪变化。当外界通过Watcher读取数据时，会触发getter从而将Watcher添加到依赖中。当数据发生了变化时，会触发setter，从而向Dep中的依赖（即Watcher）发送通知。Watcher接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。 不足虽然我们通过Object.defineProperty方法实现了对object数据的可观测，但是这个方法仅仅只能观测到object数据的取值及设置值，当我们向object数据里添加一对新的key/value或删除一对已有的key/value时，它是无法观测到的，导致当我们对object数据添加或删除值时，无法通知依赖，无法驱动视图进行响应式更新。 当然，Vue也注意到了这一点，为了解决这一问题，Vue增加了两个全局API:Vue.set和Vue.delete，这两个API的实现原理将会在后面学习全局API的时候说到。 Array双向绑定原理为什么Object数据和Array型数据会有两种不同的变化侦测方式？ 这是因为对于Object数据我们使用的是JS提供的对象原型上的方法Object.defineProperty，而这个方法是对象原型上的，所以Array无法使用这个方法，所以我们需要对Array型数据设计一套另外的变化侦测机制。 万变不离其宗，虽然对Array型数据设计了新的变化侦测机制，但是其根本思路还是不变的。那就是：还是在获取数据时收集依赖，数据变化时通知依赖更新。 实现方式 收集依赖 data()&#123; return &#123; arr:[1,2,3] &#125; &#125; arr这个数据始终都存在于一个object数据对象中，而且我们也说了，谁用到了数据谁就是依赖，那么要用到arr这个数据，是不是得先从object数据对象中获取一下arr数据，而从object数据对象中获取arr数据自然就会触发arr的getter，所以我们就可以在getter中收集依赖。总结一句话就是：Array型数据还是在getter中收集依赖。 使Array型数据可观测 let arr = [1,2,3] arr.push(4) Array.prototype.newPush = function(val)&#123; console.log('arr被修改了') this.push(val) &#125; arr.newPush(4) 在上面这个例子中，我们针对数组的原生push方法定义个一个新的newPush方法，这个newPush方法内部调用了原生push方法，这样就保证了新的newPush方法跟原生push方法具有相同的功能，而且我们还可以在新的newPush方法内部干一些别的事情，比如通知变化 数组方法拦截器在Vue中创建了一个数组方法拦截器，它拦截在数组实例与Array.prototype之间，在拦截器内重写了操作数组的一些方法，当数组实例使用操作数组方法时，其实使用的是拦截器中重写的方法，而不再使用Array.prototype上的原生方法 const arrayProto = Array.prototype // 创建一个对象作为拦截器 export const arrayMethods = Object.create(arrayProto) // 改变数组自身内容的7个方法 const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse' ] /** * Intercept mutating methods and emit events */ methodsToPatch.forEach(function (method) &#123; const original = arrayProto[method] // 缓存原生方法 Object.defineProperty(arrayMethods, method, &#123; enumerable: false, configurable: true, writable: true, value:function mutator(...args)&#123; const result = original.apply(this, args) return result &#125; &#125;) &#125;) 在上面的代码中，首先创建了继承自Array原型的空对象arrayMethods，接着在arrayMethods上使用object.defineProperty方法将那些可以改变数组自身的7个方法遍历逐个进行封装。最后，当我们使用push方法的时候，其实用的是arrayMethods.push，而arrayMethods.push就是封装的新函数mutator，也就后说，实标上执行的是函数mutator，而mutator函数内部执行了original函数，这个original函数就是Array.prototype上对应的原生方法。 那么，接下来我们就可以在mutator函数中做一些其他的事，比如说发送变化通知。 使用拦截器// 源码位置：/src/core/observer/index.js export class Observer &#123; constructor (value) &#123; this.value = value if (Array.isArray(value)) &#123; const augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) &#125; else &#123; this.walk(value) &#125; &#125; &#125; // 能力检测：判断__proto__是否可用，因为有的浏览器不支持该属性 export const hasProto = '__proto__' in &#123;&#125; const arrayKeys = Object.getOwnPropertyNames(arrayMethods) /** * Augment an target Object or Array by intercepting * the prototype chain using __proto__ */ function protoAugment (target, src: Object, keys: any) &#123; target.__proto__ = src &#125; /** * Augment an target Object or Array by defining * hidden properties. */ /* istanbul ignore next */ function copyAugment (target: Object, src: Object, keys: Array&lt;string>) &#123; for (let i = 0, l = keys.length; i &lt; l; i++) &#123; const key = keys[i] def(target, key, src[key]) &#125; &#125; 依赖收集// 源码位置：/src/core/observer/index.js export class Observer &#123; constructor (value) &#123; this.value = value this.dep = new Dep() // 实例化一个依赖管理器，用来收集数组依赖 if (Array.isArray(value)) &#123; const augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) &#125; else &#123; this.walk(value) &#125; &#125; &#125; function defineReactive (obj,key,val) &#123; let childOb = observe(val) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get()&#123; if (childOb) &#123; childOb.dep.depend() &#125; return val; &#125;, set(newVal)&#123; if(val === newVal)&#123; return &#125; val = newVal; dep.notify() // 在setter中通知依赖更新 &#125; &#125;) &#125; /** * Attempt to create an observer instance for a value, * returns the new observer if successfully observed, * or the existing observer if the value already has one. * 尝试为value创建一个0bserver实例，如果创建成功，直接返回新创建的Observer实例。 * 如果 Value 已经存在一个Observer实例，则直接返回它 */ export function observe (value, asRootData)&#123; if (!isObject(value) || value instanceof VNode) &#123; return &#125; let ob if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__ &#125; else &#123; ob = new Observer(value) &#125; return ob &#125; 通知依赖我们只要能访问到被转化成响应式的数据value即可，因为vaule上的__ob__就是其对应的Observer类实例，有了Observer类实例我们就能访问到它上面的依赖管理器，然后只需调用依赖管理器的dep.notify()方法，让它去通知依赖更新即可 /** * Intercept mutating methods and emit events */ methodsToPatch.forEach(function (method) &#123; const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) &#123; const result = original.apply(this, args) const ob = this.__ob__ // notify change ob.dep.notify() return result &#125;) &#125;) 不足前文中我们说过，对于数组变化侦测是通过拦截器实现的，也就是说只要是通过数组原型上的方法对数组进行操作就都可以侦测到，但是别忘了，我们在日常开发中，还可以通过数组的下标来操作数据，如下 let arr = [1,2,3] arr[0] = 5; // 通过数组下标修改数组中的数据 arr.length = 0 // 通过修改数组长度清空数组 而使用上述例子中的操作方式来修改数组是无法侦测到的。 同样，Vue也注意到了这个问题， 为了解决这一问题，Vue增加了两个全局API:Vue.set和Vue.delete，这两个API的实现原理将会在后面学习全局API的时候说到 总结首先我们分析了对于Array型数据也在getter中进行依赖收集；其次我们发现，当数组数据被访问时我们轻而易举可以知道，但是被修改时我们却很难知道，为了解决这一问题，我们创建了数组方法拦截器，从而成功的将数组数据变的可观测。接着我们对数组的依赖收集及数据变化如何通知依赖进行了深入分析；最后我们发现Vue不但对数组自身进行了变化侦测，还对数组中的每一个元素以及新增的元素都进行了变化侦测","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://example.com/tags/vue2-0/"}]},{"title":"路由模式","slug":"工作项目/路由模式","date":"2021-07-20T06:49:57.663Z","updated":"2021-07-23T09:48:56.629Z","comments":true,"path":"2021/07/20/工作项目/路由模式/","link":"","permalink":"http://example.com/2021/07/20/%E5%B7%A5%E4%BD%9C%E9%A1%B9%E7%9B%AE/%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"路由模式 hash模式这里的 hash 就是指 url 尾巴后的 # 号以及后面的字符。这里的 # 和 css 里的 # 是一个意思。hash 也 称作 锚点，本身是用来做页面定位的，她可以使对应 id 的元素显示在可视区域内。 由于 hash 值变化不会导致浏览器向服务器发出请求，而且 hash 改变会触发 hashchange 事件，浏览器的进后退也能对其进行控制，所以人们在 html5 的 history 出现前，基本都是使用 hash 来实现前端路由的。 window.location.hash = 'qq' // 设置 url 的 hash，会在当前url后加上 '#qq' var hash = window.location.hash // '#qq' window.addEventListener('hashchange', function()&#123; // 监听hash变化，点击浏览器的前进后退会触发 &#125;) history模式已经有 hash 模式了，而且 hash 能兼容到IE8， history 只能兼容到 IE10，为什么还要搞个 history 呢？首先，hash 本来是拿来做页面定位的，如果拿来做路由的话，原来的锚点功能就不能用了。其次，hash 的传参是基于 url 的，如果要传递复杂的数据，会有体积的限制，而 history 模式不仅可以在url里放参数，还可以将数据存放在一个特定的对象中。 window.history.pushState(state, title, url) // state：需要保存的数据，这个数据在触发popstate事件时，可以在event.state里获取 // title：标题，基本没用，一般传 null // url：设定新的历史记录的 url。新的 url 与当前 url 的 origin 必须是一樣的，否则会抛出错误。url可以是绝对路径，也可以是相对路径。 //如 当前url是 https://www.baidu.com/a/,执行history.pushState(null, null, './qq/')，则变成 https://www.baidu.com/a/qq/， //执行history.pushState(null, null, '/qq/')，则变成 https://www.baidu.com/qq/ window.history.replaceState(state, title, url) // 与 pushState 基本相同，但她是修改当前历史记录，而 pushState 是创建新的历史记录 window.addEventListener(\"popstate\", function() &#123; // 监听浏览器前进后退事件，pushState 与 replaceState 方法不会触发 &#125;); window.history.back() // 后退 window.history.forward() // 前进 window.history.go(1) // 前进一步，-2为后退两步，window.history.lengthk可以查看当前历史堆栈中页面的数量","categories":[],"tags":[{"name":"router","slug":"router","permalink":"http://example.com/tags/router/"}]},{"title":"Promise","slug":"js/promise","date":"2021-07-19T16:00:00.000Z","updated":"2021-07-23T09:48:56.629Z","comments":true,"path":"2021/07/20/js/promise/","link":"","permalink":"http://example.com/2021/07/20/js/promise/","excerpt":"","text":"promise是什么？1、主要用于异步计算2、可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果3、可以在对象之间传递和操作promise，帮助我们处理队列 异步回调的问题 之前处理异步是通过纯粹的回调函数的形式进行处理 很容易进入到回调地狱中，剥夺了函数return的能力 问题可以解决，但是难以读懂，维护困难 稍有不慎就会踏入回调地狱 - 嵌套层次深，不好维护 new Promisenew Promise( function (resolve, reject) &#123; // 一段耗时的异步操作 resolve('成功') // 数据处理完成 // reject('失败') // 数据处理出错 &#125; ).then( (res) => &#123;console.log(res)&#125;, // 成功 (err) => &#123;console.log(err)&#125; // 失败 ) Promise.all() 批量执行Promise.all([p1, p2, p3])用于将多个promise实例，包装成一个新的Promise实例，返回的实例就是普通的promise它接收一个数组作为参数数组里可以是Promise对象，也可以是别的值，只有Promise会等待状态改变当所有的子Promise都完成，该Promise完成，返回值是全部值得数组有任何一个失败，该Promise失败，返回值是第一个失败的子Promise结果 //切菜 function cutUp()&#123; console.log('开始切菜。'); var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('切菜完毕！'); resolve('切好的菜'); &#125;, 1000); &#125;); return p; &#125; //烧水 function boil()&#123; console.log('开始烧水。'); var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('烧水完毕！'); resolve('烧好的水'); &#125;, 1000); &#125;); return p; &#125; Promise.all([cutUp(), boil()]) .then((result) => &#123; console.log('准备工作完毕'); console.log(result); &#125;) Promise.race() 它有任意一个完成就算完成let p1 = new Promise(resolve => &#123; setTimeout(() => &#123; resolve('I\\`m p1 ') &#125;, 1000) &#125;); let p2 = new Promise(resolve => &#123; setTimeout(() => &#123; resolve('I\\`m p2 ') &#125;, 2000) &#125;); Promise.race([p1, p2]) .then(value => &#123; console.log(value) &#125;) 回调地狱和promise对比 回调地狱/*** 第一步：找到北京的id 第二步：根据北京的id -> 找到北京公司的id 第三步：根据北京公司的id -> 找到北京公司的详情 目的：模拟链式调用、回调地狱 ***/ // 回调地狱 // 请求第一个API: 地址在北京的公司的id $.ajax(&#123; url: 'https://www.easy-mock.com/mock/5a52256ad408383e0e3868d7/lagou/city', success (resCity) &#123; let findCityId = resCity.filter(item => &#123; if (item.id == 'c1') &#123; return item &#125; &#125;)[0].id $.ajax(&#123; // 请求第二个API: 根据上一个返回的在北京公司的id “findCityId”，找到北京公司的第一家公司的id url: 'https://www.easy-mock.com/mock/5a52256ad408383e0e3868d7/lagou/position-list', success (resPosition) &#123; let findPostionId = resPosition.filter(item => &#123; if(item.cityId == findCityId) &#123; return item &#125; &#125;)[0].id // 请求第三个API: 根据上一个API的id(findPostionId)找到具体公司，然后返回公司详情 $.ajax(&#123; url: 'https://www.easy-mock.com/mock/5a52256ad408383e0e3868d7/lagou/company', success (resCom) &#123; let comInfo = resCom.filter(item => &#123; if (findPostionId == item.id) &#123; return item &#125; &#125;)[0] console.log(comInfo) &#125; &#125;) &#125; &#125;) &#125; &#125;) // Promise 写法 // 第一步：获取城市列表 const cityList = new Promise((resolve, reject) => &#123; $.ajax(&#123; url: 'https://www.easy-mock.com/mock/5a52256ad408383e0e3868d7/lagou/city', success (res) &#123; resolve(res) &#125; &#125;) &#125;) // 第二步：找到城市是北京的id cityList.then(res => &#123; let findCityId = res.filter(item => &#123; if (item.id == 'c1') &#123; return item &#125; &#125;)[0].id findCompanyId().then(res => &#123; // 第三步（2）：根据北京的id -> 找到北京公司的id let findPostionId = res.filter(item => &#123; if(item.cityId == findCityId) &#123; return item &#125; &#125;)[0].id // 第四步（2）：传入公司的id companyInfo(findPostionId) &#125;) &#125;) // 第三步（1）：根据北京的id -> 找到北京公司的id function findCompanyId () &#123; let aaa = new Promise((resolve, reject) => &#123; $.ajax(&#123; url: 'https://www.easy-mock.com/mock/5a52256ad408383e0e3868d7/lagou/position-list', success (res) &#123; resolve(res) &#125; &#125;) &#125;) return aaa &#125; // 第四步：根据上一个API的id(findPostionId)找到具体公司，然后返回公司详情 function companyInfo (id) &#123; let companyList = new Promise((resolve, reject) => &#123; $.ajax(&#123; url: 'https://www.easy-mock.com/mock/5a52256ad408383e0e3868d7/lagou/company', success (res) &#123; let comInfo = res.filter(item => &#123; if (id == item.id) &#123; return item &#125; &#125;)[0] console.log(comInfo) &#125; &#125;) &#125;) &#125;","categories":[],"tags":[]},{"title":"this词法","slug":"js/js-this词法","date":"2021-07-18T16:00:00.000Z","updated":"2021-07-23T09:48:56.630Z","comments":true,"path":"2021/07/19/js/js-this词法/","link":"","permalink":"http://example.com/2021/07/19/js/js-this%E8%AF%8D%E6%B3%95/","excerpt":"","text":"ES6添加了一个特殊的词法形式的函数声明，叫做箭头函数，箭头函数在涉及this绑定的行为和普通函数的行为完全不一样，他放弃了所有的普通函数this绑定的规则，取而代之的是用当前的词法作用域覆盖了this原本的值。 var obj = &#123; count: 0, cool: function coolFn() &#123; if(this.count &lt; 1) &#123; setTimeout(() => &#123; this.count++; console.log('awesome?'); &#125;,1000); &#125; &#125; &#125; obj.cool();//awesome? 这个箭头函数中的this直接是cool()的this绑定（因此调用它并不会出错） 它将程序员们经常犯的一个错误给标准化了，也就是混淆了this绑定规则和词法作用域规则。 另一个导致箭头函数不够理想的原因是他不是具名的，而是一个匿名函数。 误解： 人们很容易把this理解成指向函数自身。那么为什么函数要从内部引用函数自身呢？常见的原因是递归（从函数内部调用这个函数）或者可以写在第一次被调用后自己解除绑定事件处理器。 新手通常会认为，既然把函数看做一个对象，那就可以在调用函数时储存状态。 call function foo(num) &#123; console.log(\"foo\" + num); this.count ++; &#125; foo.count = 0; var i; for(i = 0; i &lt; 10; i++)&#123; if(i > 5) &#123; // 使用call(...) 可以确保this指向函数本身 foo.call(foo, i) &#125; &#125; // foo: 6 // foo: 7 // foo: 8 // foo: 9 cnosole.log(foo.count); // 4 它的作用域还有一种常见的错误是，this指向函数的作用域。这个问题在某中情况下是正确的，但是有时候又是错误的。需要明确的是this在任何情况下都不指向函数的词法作域。 function foo()&#123; var a = 2; this.bar(); // 能调用到bar也是意外，正常应该通过词法作用域，直接执行 &#125; function bar()&#123; console.log(this.a) &#125; foo(); // a not defined ==当你想把this和词法作用域的查找混合使用的时候，一定要提醒自己这是无法实现的== 是什么this不是在写代码时候绑定的而是代码在执行的时候绑定的，它的上下文取决于函数调用时的各种条件。 this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。 ==当一个函数被执行时，会创建一个活动记录（有时候也被称之为执行上下文）。这个记录会包含函数在哪里被调用、函数的调用方式、传入参数等信息。this就是这个记录的一个属性，会在函数执行的过程中调用到。== this实际上是在函数被调用的时候发生绑定，他指向什么完全取决于函数在哪里被调用。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"闭包","slug":"js/js-闭包","date":"2021-07-18T16:00:00.000Z","updated":"2021-07-23T09:48:56.630Z","comments":true,"path":"2021/07/19/js/js-闭包/","link":"","permalink":"http://example.com/2021/07/19/js/js-%E9%97%AD%E5%8C%85/","excerpt":"","text":"闭包是基于词法作用域书写代码时所产生的自然结果 闭包的产生：函数在被定义的地方之外被执行就会产生闭包！！！ function foo() &#123; var a = 2; function bar()&#123; console.log(a); &#125; return bar; &#125; var bza = foo(); baz(); // 2 这就是闭包！ 通常情况下foo执行之后整个内部作用域都会被销毁，因为引擎会销毁不再使用的空间来释放内存空间。 然而闭包会阻止这一情况的发生，会让作用域依然存在，因为bar函数还在使用foo这个作用域，需要给bar在任何时候执行提供支持。所以foo的作用域不会被销毁，bar依然持有对该作用域的引用，这个引用就是闭包！ ==无论通过何种手段将内部函数传递到所在的词法作用域以外，他都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。== function wait(message)&#123; setTimeout( function timer() &#123; console.log(message); &#125;,1000) &#125; wait('hello') wait执行1000毫秒以后，他的内部作用域并不会消失，还能保持message的引用。 ==只要是使用了回调函数，实际上就是在使用闭包。== 闭包和循环for(var i = 1;i &lt;= 5; i++;)&#123; setTimeout(function timer() &#123; console.log(i); &#125;,1*1000) &#125; // 每秒一次输出五个6 这个循环终止的条件是6.条件首次成立的时候i === 6，因此输出的显示是循环结束时i的值。因为这里所用的i，是同一个作用域下的i，所有的函数共享一个i。 for(var i = 1;i &lt;= 5; i++;)&#123; (function() &#123; setTimeout(function timer() &#123; console.log(i); &#125;,1*1000) &#125;(); &#125; //这样也不行 因为我们的IIFE的作用域是空的，我们使用的依然是外层的i，他要包含一点实质的内容才能够我们使用。 for(var i = 1;i &lt;= 5; i++;)&#123; (function(j) &#123; setTimeout(function timer() &#123; console.log(j); &#125;,j*1000) &#125;(i); &#125; // 这样就达到我们预期的目的，每秒一个，一次输出1-5 重返块作用域前面说let可以劫持块级作用域，，并且在这个块级作用域中声明一个变量。看下面代码 for(var i = 1; i &lt;= 5; i++) &#123; let j = i; setTimeout(function timer() &#123; console.log(j); &#125;,j*1000) &#125;; 还可以更完善 for(let i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;,i*1000) &#125;; 模块function foo()&#123; var a = 'cool'; var b = [1,2,3]; function bar() &#123; console.log(a); &#125; function baz() &#123; console.log(b); &#125; &#125; 这里并没有明显的闭包，只有两个私有数据变量a和b，以及bar和baz两个内部函数，他们的词法作用域就是闭包，也就是foo（）的内部作用域。 function CoolModule() &#123; var something = 'cool'; var another = [1,2,3]; function doSomething() &#123; console.log(something)); &#125; function doAnother() &#123; console.log(another.join(\"!\")); &#125; return &#123; doSomething: doSomething, doAnother: doAnother, &#125;; &#125; var foo = CoolModule; foo.doSomething(); // cool foo.doAnother(); // 1!2!3 首先，CoolModule() 只是一个函数，必须通过调用它来创建一个模块实例，如果不执行外部函数，内部作用域和闭包都无法被创建。 其次，CoolModule() 返回一个用对象字面量语法来表示的对象，这个返回的对象中含有内部函数，而不是内部数据变量的引用。我们保持内部数据变量是隐藏且私有状态。 这个对象类型的返回值最终被赋值给外部变量foo，然后我们就可以通过它来访问API中的属性方法。 模块模式必须具有两个条件 必须有外部的封闭函数，该函数必须至少被调用一次。（每次调用都会创建一个新的模块实例） 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。 一个具有函数属性的对象本身并不是真正的模块。从方便观察角度来看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。 改进上面的代码 var foo = (function CoolModule() &#123; var something = 'cool'; var another = [1,2,3]; function doSomething() &#123; console.log(something)); &#125; function doAnother() &#123; console.log(another.join(\"!\")); &#125; return &#123; doSomething: doSomething, doAnother: doAnother, &#125;; &#125;)(); foo.doSomething(); // cool foo.doAnother(); // 1!2!3 模块是普通函数，因此也可以传参。 function CoolModule(id) &#123; function doSomething() &#123; console.log(id); &#125; return &#123; doSomething: doSomething, &#125;; &#125; var foo = CoolModule('foo'); foo.doSomething(); // foo 模块另一个简单但又强大的用法是命名将要作为公共API返回的对象。 var foo = (function Cool(id)&#123; function change() &#123; publicAPI.identify = identify2; &#125;; function identify1() &#123; console.log(id); &#125;; function identify2() &#123; console.log(id.toUppeCase()); &#125;; var publicAPI = &#123; change: change, identify: identify1 &#125; return publicAPI; &#125;)('foo module'); foo.identify(); // foo module foo.change(); foo.identify(); // FOO MODULE 通过模块在实例的内部保留的公共API对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法，以及修改他们的值。 现代的模块机制创建一个模块 var MyModules = (function Manager()&#123; // 存储方法 var modules = &#123;&#125;; // 添加方法 function define(name,deps,impl)&#123; for(var i = 0;i &lt; deps.length; i++) &#123; deps[i] = modules[deps[i]]; &#125; modules[name] = impl.apply(impl,deps); &#125; // 根据名字获取方法 function get(name) &#123; return modules[name]; &#125; // 返回内部函数（方法） return &#123; define: define, get: get &#125; &#125;)() Function.apply(obj,args)方法能接收两个参数 obj：这个对象将代替Function类里this对象 args：这个是数组，它将作为参数传给Function(args–&gt;arguments) 使用它来定义模块： MyModules.define(\"bar\",[], function() &#123; function hello(who) &#123; return \"let me introduce:\" + who; &#125; retrun &#123; hello : hello &#125;; &#125;); MyModules.define(\"foo\",['bar'], function(bar) &#123; var hungry = 'hippo'; function awesome(who) &#123; console.log(bar.hello(hungry).toUpperCase()); &#125; retrun &#123; awesome : awesome &#125;; &#125;); var bar = MyModules.get('bar'); var foo = MyModules.get('foo'); console.log(bar.hello('hippo'));// let me introduce: hippo foo.awesome(); // 大写的 foo 和 bar 都是通过一个返回的公共的API的函数来定义的。foo 甚至接受 bar 的实例作为依赖参数，并且相应地使用它。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"函数中的作用域","slug":"js/js-函数作用域、作用域快","date":"2021-07-17T16:00:00.000Z","updated":"2021-07-23T09:48:56.630Z","comments":true,"path":"2021/07/18/js/js-函数作用域、作用域快/","link":"","permalink":"http://example.com/2021/07/18/js/js-%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%BF%AB/","excerpt":"","text":"函数中的作用域js有基于函数的作用域，每声明一个函数都会为其自身创建一个气泡，可以在附属气泡里获取外层的变量，但是不能从外层气泡中获取附属气泡种的变量 隐藏内部实现 暴露在外面的写法，很不安全 function foo(a) &#123; b = a + fff(a * 2); console.log(b * 3); &#125; function fff(a) &#123; return a - 1; &#125; var b; foo(2) // 15 隐藏的写法 function foo(a) &#123; function fff(a) &#123; return a - 1; &#125; var b; b = a + fff(a * 2); console.log(b * 3); &#125; foo(2) // 15 规避冲突，可以避免同名标识符之间的冲突，避免被覆盖 方法： 全局命名空间，在全局声明一个独特的变量，通常是一个对象，所有需要暴露给外界的功能都会成为这个对象的属性，而不是将自己的标识符暴露在顶级的词法作用域种。 模块管理，从众多模块中挑选一个来使用，任何库都无需将标识符加入到全局作用域中。 函数作用域在任意代码片段外部添加包装函数都可以将内部的变量和函数定义‘隐藏’起来，外部作用域无法访问包装函数内部的任何内容 通过定义一个函数来达到是变量在函数作用域之内，虽然可以解决问题，但是并不理想，因为这个函数名称本身污染了所在的作用域，其次是必须通过显式的调用这个函数才能运行其中的代码。 var a = 2; (function foo()&#123; var a = 3; console.log( a ); // 3 &#125;)(); console.log( a ); // 2 这样函数会被当作函数表达式而不是一个标准的函数声明来处理。– 如果function是声明中的第一个第一个词，那么就是函数声明，否则就是函数表达式。 函数表达式和函数声明最大的区别是它们的名称标识符将会绑定在何处。 foo只能在所代表的位置中被访问，外部不行。 匿名和具名 匿名函数表达式 setTimeout( function()&#123; console.log('aaa'); &#125;,1000); fun没有标识符，函数声明则是不可以省略函数名称 匿名函数在栈追踪中不会显示出有意义的函数名称，使得调用很困难。 如果没有函数名，需要引用的时候就只能使用已经过期的arguments.callee引用，比如在递归中 匿名函数省略了对于代码的可读性/可理解性很重要的函数名 行内函数表达式 setTimeout( function timeoutHandler()&#123; console.log('aaa'); &#125;,1000); 立即执行函数表达式var a = 2; (function foo()&#123; var a = 3; console.log( a ); // 3 &#125;)(); console.log( a ); // 2 第一个（）将函数变成了表达式，第二个（）执行了这个函数 IIFE代表立即执行函数表达式 var a = 2; (function IIFE()&#123; //传统的形式 var a = 3; console.log( a ); // 3 &#125;)(); console.log( a ); // 2 ==以上两种写法功能上是一样的== 用途： 可以传参数进去 var a = 2; (function IIFE(global)&#123; //传统的形式 var a = 3; console.log( a ); // 3 console.log( global.a ); // 3 &#125;)(window); console.log( a ); // 2 块作用域除了函数能产生一个作用域气泡，for循环，if，with,try/catch等都会产生一个作用域气泡。 块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块，通常指{..}的内部 var 其实val一个变量无论在什么地方，都会提升到全局变量，把它写在作用域内部，只是为了风格更易读而伪装出的形式上的块作用域，如果使用这种，要确保在其他地方没有重复的使用同名的变量。 let ES6引入了关键字let，可以将变量绑定到所在的任意作用域中，为其声明的变量隐式的劫持了所在的块作用域。 let进行声明的不会在代码在块作用域中进行提升，声明的代码在运行前，声明并不‘存在’。 &#123; console.log(a); // ReferenceError(没有找到) let a = 2; &#125; let 声明附属于一个新的作用域而不是当前函数作用域（也不属于全局作用域） const 同样可以用来创建块作用域变量，但其值是固定的，之后的任何试图修改值的操作都会引起错误。 var foo = true; if(foo)&#123; var a = 2; const b = 3; a = 4; // 正确 b = 6; // 错误 &#125; console.log(a) // 4 console.log(b) // ReferenceError 任何声明在某个作用域内部的变量，都将附属于这个作用域 小思考a = 2; val a; console.log(a);//2 输出2的原因是：声明会提升，也就是先声明再赋值，在执行查询 console.log(a); // undefind var a = 2; // 执行顺序 val a; console.log(a); // undefind a = 2; 原因：函数声明会提升，然后执行查询，此时是没有赋值的，所以是undefind foo(); // 不是ReferenceError，而是TypeEerror var foo = funcyion bar() &#123; //... &#125;; 原因：函数表达式不会被提升 函数优先 函数声明和变量声明都会被提升，但是一个值得注意的细节是函数会被首先提升，然后才是变量。 foo(); //1 var foo; function foo() &#123; console.log(1); &#125; foo = function() &#123; console.log(2); &#125; 输出的是1而不是2是因为函数声明先被提升到上面，然后在执行。var foo 尽管出现在function foo… 之前，但是他是重复声明会被忽略。 后面的声明会覆盖掉前面的声明 foo(); //3 function foo() &#123; console.log(1); &#125; var foo = function() &#123; console.log(2); &#125; function foo() &#123; console.log(3); &#125;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"js数据类型","slug":"js/js-数据类型","date":"2021-07-16T16:00:00.000Z","updated":"2021-11-25T03:48:38.802Z","comments":true,"path":"2021/07/17/js/js-数据类型/","link":"","permalink":"http://example.com/2021/07/17/js/js-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"基本数据类型、引用数据类型 ECMAScript包括两个不同类型的值：基本数据类型和引用数据类型。基本数据类型指的是简单的数据段，引用数据类型指的是有多个值构成的对象。当我们把变量赋值给一个变量时，解析器首先要确认的就是这个值是基本类型值还是引用类型值。JavaScript目前有八种内置类型： Number String Boolean Null Undefined Object Symbol BigInt 常见的基本数据类型Number、String 、Boolean、Null和Undefined。基本数据类型是按值访问的，因为可以直接操作保存在变量中的实际值。示例： var a = 10; var b = a; b = 20; console.log(a); // 10值 上面，b获取的是a值得一份拷贝，虽然，两个变量的值相等，但是两个变量保存了两个不同的基本数据类型值。 b只是保存了a复制的一个副本。所以，b的改变，对a没有影响。 引用类型数据 也就是对象类型Object type，比如：Object 、Array 、Function 、Data等。 js的引用数据类型是保存在堆内存中的对象。 与其他语言的不同是，你不可以直接访问堆内存空间中的位置和操作堆内存空间。只能操作对象在栈内存中的引用地址。 所以，引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存中堆内存中的对象。 var obj1 = new Object(); var obj2 = obj1; obj2.name = \"我有名字了\"; console.log(obj1.name); // 我有名字了 说明这两个引用数据类型指向了同一个堆内存对象。obj1赋值给onj2，实际上这个堆内存对象在栈内存的引用地址复制了一份给了obj2， 但是实际上他们共同指向了同一个堆内存对象。实际上改变的是堆内存对象。 查看一个值的是数据类型 js中变量是没有数据类型的，只有值才有。变量可以持有任何数据类型的值。 typeof 用来查看变量的类型会返回一字符串： typeof 1; // \"number\" typeof '1'; // \"string\" typeof undefined; // \"undefined\" typeof true; // \"boolean\" typeof &#123;a:1&#125;; // \"object\" typeod Symbol(); //'symbo' typeof null; // 'object' null 使用typeof 返回的类型是object，所以查看是不是null是需要用复合条件来检测typeof null === ‘object’ 是因为js中的数据在底层是以二进制存储，比如null所有存储值都是0，但是底层的判断机制，只要前三位为0，就会判定为object var a = null (!a &amp;&amp; typeof a ===\"object\"); //true JSON.stringify(a) === 'null' 总结区别声明变量时不同的内存分配： 1）原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。 这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – 栈中。这样存储便于迅速查寻变量的值。 2）引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。 这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。 地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。 不同的内存分配机制也带来了不同的访问机制 1）在js中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时， 首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的按引用访问。 2）而原始类型的值则是可以直接访问到的。 c 复制变量时的不同 1）原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的value而已。 2）引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量， 也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。 （这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了）。多了一个指针 参数传递的不同（把实参复制给形参的过程） 首先我们应该明确一点：ECMAScript中所有函数的参数都是按值来传递的。 但是为什么涉及到原始类型与引用类型的值时仍然有区别呢？还不就是因为内存分配时的差别。 1）原始值：只是把变量里的值传递给参数，之后参数和这个变量互不影响。 2）引用值：对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！ 因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"浅拷贝与深拷贝","slug":"js/js-深拷贝与浅拷贝","date":"2021-07-16T16:00:00.000Z","updated":"2021-07-23T09:48:56.630Z","comments":true,"path":"2021/07/17/js/js-深拷贝与浅拷贝/","link":"","permalink":"http://example.com/2021/07/17/js/js-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"浅拷贝与深拷贝 (深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的)浅拷贝只复制指向某个对象的指针而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。 赋值和浅拷贝的区别 当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即：默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。 浅拷贝的实现方式 var obj1 = &#123; 'name' : 'zhangsan', 'age' : '18', 'language' : [1,[2,3],[4,5]], //Array &#125;; var obj3 = shallowCopy(obj1); obj3.name = \"lisi\"; obj3.language[1] = [\"二\",\"三\"]; function shallowCopy(src) &#123; var dst = &#123;&#125;; for (var prop in src) &#123; if (src.hasOwnProperty(prop)) &#123; dst[prop] = src[prop]; &#125; &#125; return dst; &#125; console.log('obj1',obj1) console.log('obj3',obj3) .Object.assign()Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。 var obj = &#123; a: &#123;a: \"kobe\", b: 39&#125; &#125;; var initalObj = Object.assign(&#123;&#125;, obj); initalObj.a.a = \"wade\"; console.log(obj.a.a); //wade 注意：当object只有一层的时候，是深拷贝 Array.prototype.concat() let arr = [1, 3, &#123; username: 'kobe' &#125;]; let arr2=arr.concat(); arr2[2].username = 'wade'; console.log(arr); 深拷贝的实现方式1.JSON.parse(JSON.stringify()) let arr = [1, 3, &#123; username: ' kobe' &#125;]; let arr4 = JSON.parse(JSON.stringify(arr)); arr4[2].username = 'duncan'; console.log(arr, arr4) 原理： 用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。这种方法虽然可以实现数组或对象深拷贝,但不能处理函数 2.手写递归方法 //定义检测数据类型的功能函数 function checkedType(target) &#123; return Object.prototype.toString.call(target).slice(8, -1) &#125; //实现深度克隆---对象/数组 function clone(target) &#123; //判断拷贝的数据类型 //初始化变量result 成为最终克隆的数据 let result, targetType = checkedType(target) if (targetType === 'object') &#123; result = &#123;&#125; &#125; else if (targetType === 'Array') &#123; result = [] &#125; else &#123; return target &#125; //遍历目标数据 for (let i in target) &#123; //获取遍历数据结构的每一项值。 let value = target[i] //判断目标结构里的每一值是否存在对象/数组 if (checkedType(value) === 'Object' || checkedType(value) === 'Array') &#123; //对象/数组里嵌套了对象/数组 //继续遍历获取到value值 result[i] = clone(value) &#125; else &#123; //获取到value值是基本的数据类型或者是函数。 result[i] = value; &#125; &#125; return result &#125; 3.函数库lodash该函数库也有提供_.cloneDeep用来做 Deep Copy var _ = require('lodash'); var obj1 = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [1, 2, 3] &#125;; var obj2 = _.cloneDeep(obj1); console.log(obj1.b.f === obj2.b.f); // false","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"js语法收集","slug":"js/js-语法收集","date":"2021-07-16T16:00:00.000Z","updated":"2021-08-05T09:51:47.469Z","comments":true,"path":"2021/07/17/js/js-语法收集/","link":"","permalink":"http://example.com/2021/07/17/js/js-%E8%AF%AD%E6%B3%95%E6%94%B6%E9%9B%86/","excerpt":"","text":"判断执行if(el)&#123; query(el) &#125; el &amp;&amp; query(el) if(el)&#123; el = query(el) &#125; el = el &amp;&amp; query(el); if(!el) return el = query(el) // 是否存执行方法 或者读取数据 let object = &#123; name:'张三', hobby:&#123; a:'钓鱼', b:'滑板' &#125; &#125; // 意思是如果object存在就取hobby(否则终止),如果hobby存在就取a(否则终止)。当有一个不存在的时候就取|| 后面的默认值 let a = object?.hobby?.a || '暂无数据' // || 与 ?? // ?? 只会过 null 与 undefined // || 当数据为 '', 0, null, undefined, false 都会走默认值 axios.get('/...').then(res => &#123; if(res.code === 200) &#123; this.data = res.data || &#123;&#125; &#125; &#125;) axios.get('/...').then(res => &#123; if(res.code === 200) &#123; this.data = res.data ?? &#123;&#125; &#125; &#125;) 少用三目运算符这个我个人理解是如果判断的东西非常简单，就是用三目(判断有两种情况，对应两种值、或者两个方法)如果情况来判断比较多 就使用if（判断的东西有三种情况，对应三种）如果更多的话就使用switch let whether = true whether ？ this.yes() : this.no() let index = 0 if (index &lt; 0) &#123; this.beLessThan() &#125; else if(index === 0)&#123; this.equal() &#125; else &#123; this.moreThanThe() &#125; switch (index) &#123; case 0: // ... break; case 1: // ... break; case 2: // ... break; case 3: // ... break; case 4: // ... break; default: // ... break; &#125; 传参使用默认值function logicProcessingFunction( name = 'defaults' ) &#123; // ... &#125; 使用 Object.assign 设置默认属性const menuConfig = &#123; title: 'Order', body: 'Send' &#125;; function createMenu(config) &#123; config = Object.assign(&#123; title: 'Foo', body: 'Bar' &#125;, config); // config : &#123;title: \"Order\", body: \"Bar\"&#125; // ... &#125; createMenu(menuConfig); 函数参数( 最好 2 个或更少 )，如果参数超过两个，建议使用 ES6 的解构语法，不用考虑参数的顺序。function logicProcessingFunction(&#123;name, age, gender, height, weight, hobby = '钓鱼'&#125;) &#123; console.log(name, age, gender, height, weight, hobby) &#125; let data = &#123; name: 'zhangSan', age:3 , gender: '男', height:180, weight: 80 &#125; logicProcessingFunction(data) 每个方法只做一件事情在处理一个需求的时候，将需求拆分细化：例如，第一步、第二步、第三步或者，第一种情况、第二种情况、第三种情况这样有利于维护,处理事件的逻辑不会混乱 var getUserInfo = function()&#123; ajax( 'http:// xxx.com/userInfo', function( data )&#123; console.log( 'userId: ' + data.userId ); console.log( 'userName: ' + data.userName ); console.log( 'nickName: ' + data.nickName ); &#125;); &#125;; //改成： var getUserInfo = function()&#123; ajax( 'http:// xxx.com/userInfo', function( data )&#123; printDetails( data ); &#125;); &#125;; var printDetails = function( data )&#123; console.log( 'userId: ' + data.userId ); console.log( 'userName: ' + data.userName ); console.log( 'nickName: ' + data.nickName ); &#125;; 把条件分支语句提炼成函数var getPrice = function( price )&#123; var date = new Date(); if ( date.getMonth() >= 6 &amp;&amp; date.getMonth() &lt;= 9 )&#123; // 夏天 return price * 0.8; &#125; return price; &#125;; // 改成 var isSummer = function()&#123; var date = new Date(); return date.getMonth() >= 6 &amp;&amp; date.getMonth() &lt;= 9; &#125;; var getPrice = function( price )&#123; if ( isSummer() )&#123; // 夏天 return price * 0.8; &#125; return price; &#125;; 类// bad function Person(name, age)&#123; this.name = name; this.age = age; &#125; Person.prototype.addAge = function()&#123; this.age++; &#125;; Person.prototype.setName = function(name)&#123; this.name = name; &#125;; // good class Person&#123; constructor(name, age)&#123; this.name = name; this.age = age; &#125; addAge()&#123; this.age++; &#125; setName(name)&#123; this.name = name; &#125; &#125; 尽量不要写全局方法// Bad: Array.prototype.diff = function diff(comparisonArray) &#123; const hash = new Set(comparisonArray); return this.filter(elem => !hash.has(elem)); &#125;; // Good: class SuperArray extends Array &#123; diff(comparisonArray) &#123; const hash = new Set(comparisonArray); return this.filter(elem => !hash.has(elem)); &#125; &#125;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"markdown 写法备注","slug":"其他/remarks","date":"2021-07-16T16:00:00.000Z","updated":"2022-06-13T08:23:09.979Z","comments":true,"path":"2021/07/17/其他/remarks/","link":"","permalink":"http://example.com/2021/07/17/%E5%85%B6%E4%BB%96/remarks/","excerpt":"","text":"标题 一级标题二级标题三级标题四级标题 无序列表 1 2 3 有序列表 列表 列表 列表 分割线 代码块 ``` 文本样式 字体倾斜 &gt; 字体倾斜 字体倾斜 字体加粗 &gt; 字体加粗 字体加粗 字体删除 &gt; 字体删除 ! 符号与字体之间不要有空格","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://example.com/tags/markdown/"}]},{"title":"作用域是什么-词法作用域","slug":"js/js-作用域是什么-词法作用域","date":"2021-07-07T16:00:00.000Z","updated":"2021-07-23T09:48:56.629Z","comments":true,"path":"2021/07/08/js/js-作用域是什么-词法作用域/","link":"","permalink":"http://example.com/2021/07/08/js/js-%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88-%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/","excerpt":"","text":"作用域是什么 存储变量的规则存储在哪里？怎么获取？ var a = 2 为一个变量分配内存，名字为a，将值为2保存进这个变量（不完全正确） var a 编译器会询问作用域是否已经存在这样一个变量存在于同一个作用域内，如果有编译器会忽略该声明，继续编译，如果没有，他会要求作用域在当前作用域内声明一个新的变量，并命名为a。 接下载编译器会为引擎生成运行时所需要的代码，这些代码被用来处理a = 2 的操作，引擎运行时会询问作用域当前作用域集合中是否存在叫做a的变量，如果有，就是用该变量，如果没有会再向再外层的作用域询问，最终会到全局作用域。找到后会将2赋值给它，找不到就会抛出异常 总结：变量的赋值操作会执行两个动作，编译器在作用域中声明，运行时引擎会查找该变量并进行赋值。 编译器：LHS查询 查找类型RHS（LHS，RHS），当变量出现在赋值操作的左侧时进行进行LHS查询，出现在右侧时进行RHS查询。 console.log（a） 执行的是RHS，要去找a的值； a = 2 执行的是LHS 要为=2找到赋值的目标。 LHS：赋值操作的目标是谁；目的是对变量进行赋值 RHS：谁是赋值操作的源头；目的是获取变量的值 ReferenceError 这个错误是找不到定义的变量 词法作用域作用域有两种主要的工作模型：词法作用域，动态作用域。 词法作用域：定义在词法阶段的作用域，就是由你写代码时将变量和块作用域写在哪里决定的，因此词法解析器处理代码时会保持作用域不变（大部分情况下是这样） 词法欺骗： eval( ) function foo(str, a) &#123; eval(str); // 欺骗 console.log(a, b); &#125; var b = 2; foo('val b = 3;', 1); // 1, 3 with(){} function foo(obj) &#123; with(obj)&#123; a = 2; &#125; &#125; var o1 = &#123; a: 3 &#125; var o2 = &#123; a: 3 &#125; foo(o1); console.log(o1.a) // 2 foo(o2); console.log(o2.a) // undefined console.log(a) // 2 ==a被泄漏到全局上面去了== 总结eval（）函数如果接受了一个或多个声明的代码，就会修改其所处的词法作用域；with声明实际上是根据传递给他的对象凭空创建了一个全新的词法作用域 eval，with会降低性能，所以不建议使用","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]}],"categories":[],"tags":[{"name":"工程化","slug":"工程化","permalink":"http://example.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"美逆项目","slug":"美逆项目","permalink":"http://example.com/tags/%E7%BE%8E%E9%80%86%E9%A1%B9%E7%9B%AE/"},{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"},{"name":"项目总结","slug":"项目总结","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"name":"管理系统","slug":"管理系统","permalink":"http://example.com/tags/%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"网络基础","slug":"网络基础","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"name":"面试题","slug":"面试题","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"},{"name":"服务器","slug":"服务器","permalink":"http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"vue3","slug":"vue3","permalink":"http://example.com/tags/vue3/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"ts","slug":"ts","permalink":"http://example.com/tags/ts/"},{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"前端自检清单","slug":"前端自检清单","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E8%87%AA%E6%A3%80%E6%B8%85%E5%8D%95/"},{"name":"底层存储方式","slug":"底层存储方式","permalink":"http://example.com/tags/%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/"},{"name":"webpack","slug":"webpack","permalink":"http://example.com/tags/webpack/"},{"name":"vue2.0","slug":"vue2-0","permalink":"http://example.com/tags/vue2-0/"},{"name":"vue.2.0","slug":"vue-2-0","permalink":"http://example.com/tags/vue-2-0/"},{"name":"异步","slug":"异步","permalink":"http://example.com/tags/%E5%BC%82%E6%AD%A5/"},{"name":"router","slug":"router","permalink":"http://example.com/tags/router/"},{"name":"markdown","slug":"markdown","permalink":"http://example.com/tags/markdown/"}]}