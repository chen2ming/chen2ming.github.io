<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>vue双向绑定原理 | chenMing</title><meta name="keywords" content="vue2.0"><meta name="author" content="chenMing"><meta name="copyright" content="chenMing"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Vue双向绑定分为两个部分：对象和数组  object双向绑定原理实现方式 通过Object.defineProperty()定义一个observer类，将正常的object转换成一个可观测的object，并且加上了_ob_属性，如果读取了会通过触发get，如果改变了会触发set   &#x2F;&#x2F; 源码位置：src&#x2F;core&#x2F;observer&#x2F;index">
<meta property="og:type" content="article">
<meta property="og:title" content="vue双向绑定原理">
<meta property="og:url" content="http://example.com/2021/07/21/vue-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="chenMing">
<meta property="og:description" content="Vue双向绑定分为两个部分：对象和数组  object双向绑定原理实现方式 通过Object.defineProperty()定义一个observer类，将正常的object转换成一个可观测的object，并且加上了_ob_属性，如果读取了会通过触发get，如果改变了会触发set   &#x2F;&#x2F; 源码位置：src&#x2F;core&#x2F;observer&#x2F;index">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/imgs/2.jpg">
<meta property="article:published_time" content="2021-07-20T16:00:00.000Z">
<meta property="article:modified_time" content="2021-07-21T03:36:47.105Z">
<meta property="article:author" content="chenMing">
<meta property="article:tag" content="vue2.0">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/imgs/2.jpg"><link rel="shortcut icon" href="/img/toux.jpg"><link rel="canonical" href="http://example.com/2021/07/21/vue-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'vue双向绑定原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-21 11:36:47'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/static-butterfly/dist/css/index.min.css"><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="chenMing" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/toux.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-fw fa fa-book"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa-fw fas fa-sitemap"></i><span> 友链朋友圈</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-fw fas fa-heart card-announcement-animation"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">chenMing</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-fw fa fa-book"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa-fw fas fa-sitemap"></i><span> 友链朋友圈</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-fw fas fa-heart card-announcement-animation"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">vue双向绑定原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-20T16:00:00.000Z" title="发表于 2021-07-21 00:00:00">2021-07-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-21T03:36:47.105Z" title="更新于 2021-07-21 11:36:47">2021-07-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="vue双向绑定原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><blockquote>
<p>Vue双向绑定分为两个部分：对象和数组</p>
</blockquote>
<h1 id="object双向绑定原理"><a href="#object双向绑定原理" class="headerlink" title="object双向绑定原理"></a><strong>object</strong>双向绑定原理</h1><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol>
<li><p>通过Object.defineProperty()定义一个observer类，将正常的object转换成一个可观测的object，并且加上了_ob_属性，如果读取了会通过触发get，如果改变了会触发set</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">  &#x2F;&#x2F; 源码位置：src&#x2F;core&#x2F;observer&#x2F;index.js

&#x2F;**
 * Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象
 *&#x2F;
export class Observer &#123;
  constructor (value) &#123;
    this.value &#x3D; value
    &#x2F;&#x2F; 给value新增一个__ob__属性，值为该value的Observer实例
    &#x2F;&#x2F; 相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作
    def(value,&#39;__ob__&#39;,this)
    if (Array.isArray(value)) &#123;
      &#x2F;&#x2F; 当value为数组时的逻辑
      &#x2F;&#x2F; ...
    &#125; else &#123;
      this.walk(value)
    &#125;
  &#125;

  walk (obj: Object) &#123;
    const keys &#x3D; Object.keys(obj)
    for (let i &#x3D; 0; i &lt; keys.length; i++) &#123;
      defineReactive(obj, keys[i])
    &#125;
  &#125;
&#125;
&#x2F;**
 * 使一个对象转化成可观测对象
 * @param &#123; Object &#125; obj 对象
 * @param &#123; String &#125; key 对象的key
 * @param &#123; Any &#125; val 对象的某个key的值
 *&#x2F;
function defineReactive (obj,key,val) &#123;
  &#x2F;&#x2F; 如果只传了obj和key，那么val &#x3D; obj[key]
  if (arguments.length &#x3D;&#x3D;&#x3D; 2) &#123;
    val &#x3D; obj[key]
  &#125;
  if(typeof val &#x3D;&#x3D;&#x3D; &#39;object&#39;)&#123;
      new Observer(val)
  &#125;
  Object.defineProperty(obj, key, &#123;
    enumerable: true,
    configurable: true,
    get()&#123;
      console.log(&#96;$&#123;key&#125;属性被读取了&#96;);
      return val;
    &#125;,
    set(newVal)&#123;
      if(val &#x3D;&#x3D;&#x3D; newVal)&#123;
          return
      &#125;
      console.log(&#96;$&#123;key&#125;属性被修改了&#96;);
      val &#x3D; newVal;
    &#125;
  &#125;)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>收集依赖，也就是收集那里用到了这个数据的。具体做法是定义一个dep类，其实就是一个数组，那里用到了就在数据里面push进去。dep里面有几个方法，在observer的get里面depend负责收集依赖（其实就是Watcher），在set里面notify通知所有依赖更新（通知的也是Watcher，最后由Watcher通知视图更新）</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 源码位置：src&#x2F;core&#x2F;observer&#x2F;dep.js
export default class Dep &#123;
  constructor () &#123;
    this.subs &#x3D; []
  &#125;

  addSub (sub) &#123;
    this.subs.push(sub)
  &#125;
  &#x2F;&#x2F; 删除一个依赖
  removeSub (sub) &#123;
    remove(this.subs, sub)
  &#125;
  &#x2F;&#x2F; 添加一个依赖
  depend () &#123;
    if (window.target) &#123;
      this.addSub(window.target)
    &#125;
  &#125;
  &#x2F;&#x2F; 通知所有依赖更新
  notify () &#123;
    const subs &#x3D; this.subs.slice()
    for (let i &#x3D; 0, l &#x3D; subs.length; i &lt; l; i++) &#123;
      subs[i].update()
    &#125;
  &#125;
&#125;

&#x2F;**
 * Remove an item from an array
 *&#x2F;
export function remove (arr, item) &#123;
  if (arr.length) &#123;
    const index &#x3D; arr.indexOf(item)
    if (index &gt; -1) &#123;
      return arr.splice(index, 1)
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>Watcher类，Watcher先把自己设置到全局唯一的指定位置（window.target），然后读取数据。因为读取了数据，所以会触发这个数据的getter。接着，在getter中就会从全局唯一的那个位置读取当前正在读取数据的Watcher，并把这个watcher收集到Dep中去。收集好之后，当数据发生变化时，会向Dep中的每个Watcher发送通知。通过这样的方式，Watcher可以主动去订阅任意一个数据的变化。</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">export default class Watcher &#123;
  constructor (vm,expOrFn,cb) &#123;
    this.vm &#x3D; vm;
    this.cb &#x3D; cb;
    this.getter &#x3D; parsePath(expOrFn)
    this.value &#x3D; this.get()
  &#125;
  get () &#123;
    window.target &#x3D; this;
    const vm &#x3D; this.vm
    let value &#x3D; this.getter.call(vm, vm)
    window.target &#x3D; undefined;
    return value
  &#125;
  update () &#123;
    const oldValue &#x3D; this.value
    this.value &#x3D; this.get()
    this.cb.call(this.vm, this.value, oldValue)
  &#125;
&#125;

&#x2F;**
 * Parse simple path.
 * 把一个形如&#39;data.a.b.c&#39;的字符串路径所表示的值，从真实的data对象中取出来
 * 例如：
 * data &#x3D; &#123;a:&#123;b:&#123;c:2&#125;&#125;&#125;
 * parsePath(&#39;a.b.c&#39;)(data)  &#x2F;&#x2F; 2
 *&#x2F;
const bailRE &#x3D; &#x2F;[^\w.$]&#x2F;
export function parsePath (path) &#123;
  if (bailRE.test(path)) &#123;
    return
  &#125;
  const segments &#x3D; path.split(&#39;.&#39;)
  return function (obj) &#123;
    for (let i &#x3D; 0; i &lt; segments.length; i++) &#123;
      if (!obj) return
      obj &#x3D; obj[segments[i]]
    &#125;
    return obj
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Data通过observer转换成了getter/setter的形式来追踪变化。<br>当外界通过Watcher读取数据时，会触发getter从而将Watcher添加到依赖中。<br>当数据发生了变化时，会触发setter，从而向Dep中的依赖（即Watcher）发送通知。<br>Watcher接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。</p>
<h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>虽然我们通过Object.defineProperty方法实现了对object数据的可观测，但是这个方法仅仅只能观测到object数据的取值及设置值，当我们向object数据里添加一对新的key/value或删除一对已有的key/value时，它是无法观测到的，导致当我们对object数据添加或删除值时，无法通知依赖，无法驱动视图进行响应式更新。</p>
<p>当然，Vue也注意到了这一点，为了解决这一问题，Vue增加了两个全局API:Vue.set和Vue.delete，这两个API的实现原理将会在后面学习全局API的时候说到。</p>
<h1 id="Array双向绑定原理"><a href="#Array双向绑定原理" class="headerlink" title="Array双向绑定原理"></a><strong>Array</strong>双向绑定原理</h1><p>为什么Object数据和Array型数据会有两种不同的变化侦测方式？</p>
<p>这是因为对于Object数据我们使用的是JS提供的对象原型上的方法Object.defineProperty，而这个方法是对象原型上的，所以Array无法使用这个方法，所以我们需要对Array型数据设计一套另外的变化侦测机制。</p>
<p>万变不离其宗，虽然对Array型数据设计了新的变化侦测机制，但是其根本思路还是不变的。那就是：还是在获取数据时收集依赖，数据变化时通知依赖更新。</p>
<h2 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h2><ol>
<li><p>收集依赖</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">data()&#123;
  return &#123;
    arr:[1,2,3]
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>arr这个数据始终都存在于一个object数据对象中，而且我们也说了，谁用到了数据谁就是依赖，那么要用到arr这个数据，是不是得先从object数据对象中获取一下arr数据，而从object数据对象中获取arr数据自然就会触发arr的getter，所以我们就可以在getter中收集依赖。<br>总结一句话就是：<strong>Array型数据还是在getter中收集依赖。</strong></p>
</li>
<li><p>使Array型数据可观测</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let arr &#x3D; [1,2,3]
arr.push(4)
Array.prototype.newPush &#x3D; function(val)&#123;
  console.log(&#39;arr被修改了&#39;)
  this.push(val)
&#125;
arr.newPush(4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上面这个例子中，我们针对数组的原生push方法定义个一个新的newPush方法，这个newPush方法内部调用了原生push方法，这样就保证了新的newPush方法跟原生push方法具有相同的功能，而且我们还可以在新的newPush方法内部干一些别的事情，比如通知变化</p>
<h3 id="数组方法拦截器"><a href="#数组方法拦截器" class="headerlink" title="数组方法拦截器"></a>数组方法拦截器</h3><p>在Vue中创建了一个数组方法拦截器，它拦截在数组实例与Array.prototype之间，在拦截器内重写了操作数组的一些方法，当数组实例使用操作数组方法时，其实使用的是拦截器中重写的方法，而不再使用Array.prototype上的原生方法<br><img src="/imgs/vue1.png" alt="Image text"></p>
</li>
</ol>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const arrayProto &#x3D; Array.prototype
&#x2F;&#x2F; 创建一个对象作为拦截器
export const arrayMethods &#x3D; Object.create(arrayProto)

&#x2F;&#x2F; 改变数组自身内容的7个方法
const methodsToPatch &#x3D; [
  &#39;push&#39;,
  &#39;pop&#39;,
  &#39;shift&#39;,
  &#39;unshift&#39;,
  &#39;splice&#39;,
  &#39;sort&#39;,
  &#39;reverse&#39;
]

&#x2F;**
 * Intercept mutating methods and emit events
 *&#x2F;
methodsToPatch.forEach(function (method) &#123;
  const original &#x3D; arrayProto[method]      &#x2F;&#x2F; 缓存原生方法
  Object.defineProperty(arrayMethods, method, &#123;
    enumerable: false,
    configurable: true,
    writable: true,
    value:function mutator(...args)&#123;
      const result &#x3D; original.apply(this, args)
      return result
    &#125;
  &#125;)
&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上面的代码中，首先创建了继承自Array原型的空对象arrayMethods，接着在arrayMethods上使用object.defineProperty方法将那些可以改变数组自身的7个方法遍历逐个进行封装。最后，当我们使用push方法的时候，其实用的是arrayMethods.push，而arrayMethods.push就是封装的新函数mutator，也就后说，实标上执行的是函数mutator，而mutator函数内部执行了original函数，这个original函数就是Array.prototype上对应的原生方法。 那么，接下来我们就可以在mutator函数中做一些其他的事，比如说发送变化通知。</p>
<h3 id="使用拦截器"><a href="#使用拦截器" class="headerlink" title="使用拦截器"></a>使用拦截器</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 源码位置：&#x2F;src&#x2F;core&#x2F;observer&#x2F;index.js
export class Observer &#123;
  constructor (value) &#123;
    this.value &#x3D; value
    if (Array.isArray(value)) &#123;
      const augment &#x3D; hasProto
        ? protoAugment
        : copyAugment
      augment(value, arrayMethods, arrayKeys)
    &#125; else &#123;
      this.walk(value)
    &#125;
  &#125;
&#125;
&#x2F;&#x2F; 能力检测：判断__proto__是否可用，因为有的浏览器不支持该属性
export const hasProto &#x3D; &#39;__proto__&#39; in &#123;&#125;

const arrayKeys &#x3D; Object.getOwnPropertyNames(arrayMethods)

&#x2F;**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 *&#x2F;
function protoAugment (target, src: Object, keys: any) &#123;
  target.__proto__ &#x3D; src
&#125;

&#x2F;**
 * Augment an target Object or Array by defining
 * hidden properties.
 *&#x2F;
&#x2F;* istanbul ignore next *&#x2F;
function copyAugment (target: Object, src: Object, keys: Array&lt;string&gt;) &#123;
  for (let i &#x3D; 0, l &#x3D; keys.length; i &lt; l; i++) &#123;
    const key &#x3D; keys[i]
    def(target, key, src[key])
  &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 源码位置：&#x2F;src&#x2F;core&#x2F;observer&#x2F;index.js
export class Observer &#123;
  constructor (value) &#123;
    this.value &#x3D; value
    this.dep &#x3D; new Dep()    &#x2F;&#x2F; 实例化一个依赖管理器，用来收集数组依赖
    if (Array.isArray(value)) &#123;
      const augment &#x3D; hasProto
        ? protoAugment
        : copyAugment
      augment(value, arrayMethods, arrayKeys)
    &#125; else &#123;
      this.walk(value)
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function defineReactive (obj,key,val) &#123;
  let childOb &#x3D; observe(val)
  Object.defineProperty(obj, key, &#123;
    enumerable: true,
    configurable: true,
    get()&#123;
      if (childOb) &#123;
        childOb.dep.depend()
      &#125;
      return val;
    &#125;,
    set(newVal)&#123;
      if(val &#x3D;&#x3D;&#x3D; newVal)&#123;
        return
      &#125;
      val &#x3D; newVal;
      dep.notify()   &#x2F;&#x2F; 在setter中通知依赖更新
    &#125;
  &#125;)
&#125;

&#x2F;**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 * 尝试为value创建一个0bserver实例，如果创建成功，直接返回新创建的Observer实例。
 * 如果 Value 已经存在一个Observer实例，则直接返回它
 *&#x2F;
export function observe (value, asRootData)&#123;
  if (!isObject(value) || value instanceof VNode) &#123;
    return
  &#125;
  let ob
  if (hasOwn(value, &#39;__ob__&#39;) &amp;&amp; value.__ob__ instanceof Observer) &#123;
    ob &#x3D; value.__ob__
  &#125; else &#123;
    ob &#x3D; new Observer(value)
  &#125;
  return ob
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="通知依赖"><a href="#通知依赖" class="headerlink" title="通知依赖"></a>通知依赖</h3><p>我们只要能访问到被转化成响应式的数据value即可，因为vaule上的__ob__就是其对应的Observer类实例，有了Observer类实例我们就能访问到它上面的依赖管理器，然后只需调用依赖管理器的dep.notify()方法，让它去通知依赖更新即可</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;**
 * Intercept mutating methods and emit events
 *&#x2F;
methodsToPatch.forEach(function (method) &#123;
  const original &#x3D; arrayProto[method]
  def(arrayMethods, method, function mutator (...args) &#123;
    const result &#x3D; original.apply(this, args)
    const ob &#x3D; this.__ob__
    &#x2F;&#x2F; notify change
    ob.dep.notify()
    return result
  &#125;)
&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="不足-1"><a href="#不足-1" class="headerlink" title="不足"></a>不足</h2><p>前文中我们说过，对于数组变化侦测是通过拦截器实现的，也就是说只要是通过数组原型上的方法对数组进行操作就都可以侦测到，但是别忘了，我们在日常开发中，还可以通过数组的下标来操作数据，如下</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let arr &#x3D; [1,2,3]
arr[0] &#x3D; 5;       &#x2F;&#x2F; 通过数组下标修改数组中的数据
arr.length &#x3D; 0    &#x2F;&#x2F; 通过修改数组长度清空数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>而使用上述例子中的操作方式来修改数组是无法侦测到的。 同样，Vue也注意到了这个问题， 为了解决这一问题，Vue增加了两个全局API:Vue.set和Vue.delete，这两个API的实现原理将会在后面学习全局API的时候说到</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>首先我们分析了对于Array型数据也在getter中进行依赖收集；其次我们发现，当数组数据被访问时我们轻而易举可以知道，但是被修改时我们却很难知道，为了解决这一问题，我们创建了数组方法拦截器，从而成功的将数组数据变的可观测。接着我们对数组的依赖收集及数据变化如何通知依赖进行了深入分析；最后我们发现Vue不但对数组自身进行了变化侦测，还对数组中的每一个元素以及新增的元素都进行了变化侦测</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">chenMing</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/07/21/vue-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/">http://example.com/2021/07/21/vue-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">chenMing</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/vue2-0/">vue2.0</a></div><div class="post_share"><div class="social-share" data-image="/imgs/2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/21/async%E3%80%81await/"><img class="prev-cover" src="/imgs/8.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">async、await</div></div></a></div><div class="next-post pull-right"><a href="/2021/07/21/http-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/"><img class="next-cover" src="/imgs/3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">浏览器渲染</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/07/23/vue-diff算法/" title="diff算法"><img class="cover" src="/imgs/9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-23</div><div class="title">diff算法</div></div></a></div><div><a href="/2021/07/22/vue-虚拟dom/" title="vue虚拟dom"><img class="cover" src="/imgs/9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-22</div><div class="title">vue虚拟dom</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/toux.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">chenMing</div><div class="author-info__description">技术博客</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/chen2ming"><i class="fab fa-github"></i><span>github</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">今天你学习了吗？今天你快乐了吗？</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#object%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">object双向绑定原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E8%B6%B3"><span class="toc-number">1.3.</span> <span class="toc-text">不足</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Array%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">Array双向绑定原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-1"><span class="toc-number">2.1.</span> <span class="toc-text">实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">2.1.1.</span> <span class="toc-text">数组方法拦截器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">2.1.2.</span> <span class="toc-text">使用拦截器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86"><span class="toc-number">2.1.3.</span> <span class="toc-text">依赖收集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%9F%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">2.1.4.</span> <span class="toc-text">通知依赖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E8%B6%B3-1"><span class="toc-number">2.2.</span> <span class="toc-text">不足</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">2.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/07/23/vue-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/" title="vue模板编译"><img src="/imgs/7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vue模板编译"/></a><div class="content"><a class="title" href="/2021/07/23/vue-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/" title="vue模板编译">vue模板编译</a><time datetime="2021-07-22T16:00:00.000Z" title="发表于 2021-07-23 00:00:00">2021-07-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/23/vue-diff%E7%AE%97%E6%B3%95/" title="diff算法"><img src="/imgs/9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="diff算法"/></a><div class="content"><a class="title" href="/2021/07/23/vue-diff%E7%AE%97%E6%B3%95/" title="diff算法">diff算法</a><time datetime="2021-07-22T16:00:00.000Z" title="发表于 2021-07-23 00:00:00">2021-07-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/22/vue-%E8%99%9A%E6%8B%9Fdom/" title="vue虚拟dom"><img src="/imgs/9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vue虚拟dom"/></a><div class="content"><a class="title" href="/2021/07/22/vue-%E8%99%9A%E6%8B%9Fdom/" title="vue虚拟dom">vue虚拟dom</a><time datetime="2021-07-21T16:00:00.000Z" title="发表于 2021-07-22 00:00:00">2021-07-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/21/async%E3%80%81await/" title="async、await"><img src="/imgs/8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="async、await"/></a><div class="content"><a class="title" href="/2021/07/21/async%E3%80%81await/" title="async、await">async、await</a><time datetime="2021-07-20T16:00:00.000Z" title="发表于 2021-07-21 00:00:00">2021-07-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/21/vue-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/" title="vue双向绑定原理"><img src="/imgs/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vue双向绑定原理"/></a><div class="content"><a class="title" href="/2021/07/21/vue-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/" title="vue双向绑定原理">vue双向绑定原理</a><time datetime="2021-07-20T16:00:00.000Z" title="发表于 2021-07-21 00:00:00">2021-07-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2021 By chenMing</div><div class="footer_custom_text"><div>嗨，欢迎来到我的博客，希望能帮助到您！</div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>